
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';


/**
 * Model answers
 */

export type answers = {
  id: number
  content: string
  created_at: Date
  updated_at: Date
  question_id: number
}

/**
 * Model applicants
 */

export type applicants = {
  id: number
  company_id: number
  project_id: number
  business_brief: string | null
  business_model: string | null
  created_at: Date
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model applicant_documents
 */

export type applicant_documents = {
  id: number
  applicant_id: number
  document_id: number
}

/**
 * Model business_types
 */

export type business_types = {
  id: number
  name: string
}

/**
 * Model companies
 */

export type companies = {
  id: number
  type_id: number | null
  name: string | null
  logo_img: string | null
  established_date: Date | null
  homepage: string | null
  description: string | null
  team_intro: string | null
  member_count: number | null
  is_saved: boolean
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model company_documents
 */

export type company_documents = {
  id: number
  company_id: number
  doc_url: string
  type_id: number
  name: string
  file_type: string
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model company_members
 */

export type company_members = {
  id: number
  company_id: number | null
  name: string | null
  img: string | null
  position: string | null
}

/**
 * Model company_news
 */

export type company_news = {
  id: number
  company_id: number
  URL: string
}

/**
 * Model company_types
 */

export type company_types = {
  id: number
  name: string
}

/**
 * Model demodays
 */

export type demodays = {
  id: number
  name: string | null
  company_id: number | null
  streaming_url: string | null
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model document_types
 */

export type document_types = {
  id: number
  name: string
}

/**
 * Model eligibilities
 */

export type eligibilities = {
  id: number
  name: string
}

/**
 * Model eligible_sectors
 */

export type eligible_sectors = {
  id: number
  name: string
}

/**
 * Model email_auth
 */

export type email_auth = {
  email: string
  auth_number: string
}

/**
 * Model invested_from
 */

export type invested_from = {
  id: number
  startup_id: number
  date: Date
  invested_institution: string
  invested_fund_id: number
  corporate_value: number
  series_id: number
}

/**
 * Model invested_to
 */

export type invested_to = {
  id: number
  partner_id: number
  date: Date
  invested_startup: string
  invested_fund_id: number
  corporate_value: number
  series_id: number
}

/**
 * Model investment_funds
 */

export type investment_funds = {
  id: number
  name: string
}

/**
 * Model investment_portfolio
 */

export type investment_portfolio = {
  id: number
  partner_id: number
  img_url: string
}

/**
 * Model investment_series
 */

export type investment_series = {
  id: number
  name: string
}

/**
 * Model IR_requests
 */

export type IR_requests = {
  id: number
  startup_id: number
  partner_id: number
  document_id: number | null
  is_checked: number
  from_partner: number
  created_at: Date
  updated_at: Date
  companiesId: number | null
}

/**
 * Model participants
 */

export type participants = {
  id: number
  demoday_id: number
  order: number
  company_id: number
}

/**
 * Model partners
 */

export type partners = {
  id: number
  company_id: number
  interst_technology_id: number | null
  invested_total_id: number | null
  invested_counts: number | null
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model partner_likes
 */

export type partner_likes = {
  id: number
  user_id: number
  company_id: number
  is_liked: boolean
  created_at: Date
  updated_at: Date
}

/**
 * Model phone_auth
 */

export type phone_auth = {
  id: number
  phone_number: string
  auth_number: string
}

/**
 * Model project_images
 */

export type project_images = {
  id: number
  project_id: number
  img_url: string | null
}

/**
 * Model project_likes
 */

export type project_likes = {
  id: number
  user_id: number
  project_id: number
  is_liked: boolean
  created_at: Date
  updated_at: Date
  companiesId: number | null
}

/**
 * Model projects
 */

export type projects = {
  id: number
  name: string | null
  introduction: string | null
  company_id: number | null
  host: string | null
  due_date: Date | null
  eligible_sector: number | null
  eligibility: number | null
  outline: string | null
  detail: string | null
  application_method: string | null
  caution: string | null
  contact: string | null
  is_opened: boolean
  hit: number
  application_url: string | null
  is_saved: boolean
  request_open: boolean
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model questions
 */

export type questions = {
  id: number
  content: string
  company_id: number
  user_id: number
  created_at: Date
  updated_at: Date
  demoday_id: number
}

/**
 * Model recent_views_project
 */

export type recent_views_project = {
  id: number
  project_id: number
  company_id: number
  created_at: Date
  updated_at: Date
}

/**
 * Model required_documents
 */

export type required_documents = {
  id: number
  project_id: number
  document_id: number
}

/**
 * Model sectors
 */

export type sectors = {
  id: number
  name: string
}

/**
 * Model service_types
 */

export type service_types = {
  id: number
  name: string
}

/**
 * Model signup_methods
 */

export type signup_methods = {
  id: number
  name: string
}

/**
 * Model startup_images
 */

export type startup_images = {
  id: number
  startup_id: number
  img_url: string
}

/**
 * Model startups
 */

export type startups = {
  id: number
  company_id: number
  rep: string | null
  sector_id: number | null
  core_technology_id: number | null
  item_description: string | null
  contact: string | null
  investment_series_id: number | null
  investment_fund_id: number | null
  address_road: string | null
  address_detail: string | null
  service_type_id: number | null
  business_type_id: number | null
  business_license_number: string | null
  email: string | null
  instagram_url: string | null
  facebook_url: string | null
  thumbnail: string | null
  created_at: Date | null
  updated_at: Date | null
  deleted_at: Date | null
}

/**
 * Model wish_investment_series
 */

export type wish_investment_series = {
  id: number
  startup_id: number
  investment_series_id: number
}

/**
 * Model startup_likes
 */

export type startup_likes = {
  id: number
  user_id: number
  company_id: number
  is_liked: boolean
  created_at: Date
  updated_at: Date
}

/**
 * Model technologies
 */

export type technologies = {
  id: number
  name: string
}

/**
 * Model terms
 */

export type terms = {
  id: number
  name: string
  content: string
  required: boolean
}

/**
 * Model user_agreements
 */

export type user_agreements = {
  id: number
  user_id: number
  term_id: number
}

/**
 * Model user_types
 */

export type user_types = {
  id: number
  name: string
}

/**
 * Model users
 */

export type users = {
  id: number
  sns_id: string | null
  name: string
  type_id: number | null
  profile_picture: string | null
  email: string
  password: string | null
  signup_method_id: number
  company_id: number | null
  phone_number: string | null
  is_verified: boolean
  created_at: Date
  updated_at: Date
}

/**
 * Model votes
 */

export type votes = {
  id: number
  user_id: number
  participants_id: number
  created_at: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Answers
 * const answers = await prisma.answers.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Answers
   * const answers = await prisma.answers.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.answers`: Exposes CRUD operations for the **answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answers.findMany()
    * ```
    */
  get answers(): Prisma.answersDelegate;

  /**
   * `prisma.applicants`: Exposes CRUD operations for the **applicants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicants
    * const applicants = await prisma.applicants.findMany()
    * ```
    */
  get applicants(): Prisma.applicantsDelegate;

  /**
   * `prisma.applicant_documents`: Exposes CRUD operations for the **applicant_documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicant_documents
    * const applicant_documents = await prisma.applicant_documents.findMany()
    * ```
    */
  get applicant_documents(): Prisma.applicant_documentsDelegate;

  /**
   * `prisma.business_types`: Exposes CRUD operations for the **business_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Business_types
    * const business_types = await prisma.business_types.findMany()
    * ```
    */
  get business_types(): Prisma.business_typesDelegate;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate;

  /**
   * `prisma.company_documents`: Exposes CRUD operations for the **company_documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_documents
    * const company_documents = await prisma.company_documents.findMany()
    * ```
    */
  get company_documents(): Prisma.company_documentsDelegate;

  /**
   * `prisma.company_members`: Exposes CRUD operations for the **company_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_members
    * const company_members = await prisma.company_members.findMany()
    * ```
    */
  get company_members(): Prisma.company_membersDelegate;

  /**
   * `prisma.company_news`: Exposes CRUD operations for the **company_news** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_news
    * const company_news = await prisma.company_news.findMany()
    * ```
    */
  get company_news(): Prisma.company_newsDelegate;

  /**
   * `prisma.company_types`: Exposes CRUD operations for the **company_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_types
    * const company_types = await prisma.company_types.findMany()
    * ```
    */
  get company_types(): Prisma.company_typesDelegate;

  /**
   * `prisma.demodays`: Exposes CRUD operations for the **demodays** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Demodays
    * const demodays = await prisma.demodays.findMany()
    * ```
    */
  get demodays(): Prisma.demodaysDelegate;

  /**
   * `prisma.document_types`: Exposes CRUD operations for the **document_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Document_types
    * const document_types = await prisma.document_types.findMany()
    * ```
    */
  get document_types(): Prisma.document_typesDelegate;

  /**
   * `prisma.eligibilities`: Exposes CRUD operations for the **eligibilities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eligibilities
    * const eligibilities = await prisma.eligibilities.findMany()
    * ```
    */
  get eligibilities(): Prisma.eligibilitiesDelegate;

  /**
   * `prisma.eligible_sectors`: Exposes CRUD operations for the **eligible_sectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eligible_sectors
    * const eligible_sectors = await prisma.eligible_sectors.findMany()
    * ```
    */
  get eligible_sectors(): Prisma.eligible_sectorsDelegate;

  /**
   * `prisma.email_auth`: Exposes CRUD operations for the **email_auth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_auths
    * const email_auths = await prisma.email_auth.findMany()
    * ```
    */
  get email_auth(): Prisma.email_authDelegate;

  /**
   * `prisma.invested_from`: Exposes CRUD operations for the **invested_from** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invested_froms
    * const invested_froms = await prisma.invested_from.findMany()
    * ```
    */
  get invested_from(): Prisma.invested_fromDelegate;

  /**
   * `prisma.invested_to`: Exposes CRUD operations for the **invested_to** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invested_tos
    * const invested_tos = await prisma.invested_to.findMany()
    * ```
    */
  get invested_to(): Prisma.invested_toDelegate;

  /**
   * `prisma.investment_funds`: Exposes CRUD operations for the **investment_funds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investment_funds
    * const investment_funds = await prisma.investment_funds.findMany()
    * ```
    */
  get investment_funds(): Prisma.investment_fundsDelegate;

  /**
   * `prisma.investment_portfolio`: Exposes CRUD operations for the **investment_portfolio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investment_portfolios
    * const investment_portfolios = await prisma.investment_portfolio.findMany()
    * ```
    */
  get investment_portfolio(): Prisma.investment_portfolioDelegate;

  /**
   * `prisma.investment_series`: Exposes CRUD operations for the **investment_series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investment_series
    * const investment_series = await prisma.investment_series.findMany()
    * ```
    */
  get investment_series(): Prisma.investment_seriesDelegate;

  /**
   * `prisma.iR_requests`: Exposes CRUD operations for the **IR_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IR_requests
    * const iR_requests = await prisma.iR_requests.findMany()
    * ```
    */
  get iR_requests(): Prisma.IR_requestsDelegate;

  /**
   * `prisma.participants`: Exposes CRUD operations for the **participants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Participants
    * const participants = await prisma.participants.findMany()
    * ```
    */
  get participants(): Prisma.participantsDelegate;

  /**
   * `prisma.partners`: Exposes CRUD operations for the **partners** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partners.findMany()
    * ```
    */
  get partners(): Prisma.partnersDelegate;

  /**
   * `prisma.partner_likes`: Exposes CRUD operations for the **partner_likes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partner_likes
    * const partner_likes = await prisma.partner_likes.findMany()
    * ```
    */
  get partner_likes(): Prisma.partner_likesDelegate;

  /**
   * `prisma.phone_auth`: Exposes CRUD operations for the **phone_auth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phone_auths
    * const phone_auths = await prisma.phone_auth.findMany()
    * ```
    */
  get phone_auth(): Prisma.phone_authDelegate;

  /**
   * `prisma.project_images`: Exposes CRUD operations for the **project_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Project_images
    * const project_images = await prisma.project_images.findMany()
    * ```
    */
  get project_images(): Prisma.project_imagesDelegate;

  /**
   * `prisma.project_likes`: Exposes CRUD operations for the **project_likes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Project_likes
    * const project_likes = await prisma.project_likes.findMany()
    * ```
    */
  get project_likes(): Prisma.project_likesDelegate;

  /**
   * `prisma.projects`: Exposes CRUD operations for the **projects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.projects.findMany()
    * ```
    */
  get projects(): Prisma.projectsDelegate;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.questionsDelegate;

  /**
   * `prisma.recent_views_project`: Exposes CRUD operations for the **recent_views_project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recent_views_projects
    * const recent_views_projects = await prisma.recent_views_project.findMany()
    * ```
    */
  get recent_views_project(): Prisma.recent_views_projectDelegate;

  /**
   * `prisma.required_documents`: Exposes CRUD operations for the **required_documents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Required_documents
    * const required_documents = await prisma.required_documents.findMany()
    * ```
    */
  get required_documents(): Prisma.required_documentsDelegate;

  /**
   * `prisma.sectors`: Exposes CRUD operations for the **sectors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sectors
    * const sectors = await prisma.sectors.findMany()
    * ```
    */
  get sectors(): Prisma.sectorsDelegate;

  /**
   * `prisma.service_types`: Exposes CRUD operations for the **service_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_types
    * const service_types = await prisma.service_types.findMany()
    * ```
    */
  get service_types(): Prisma.service_typesDelegate;

  /**
   * `prisma.signup_methods`: Exposes CRUD operations for the **signup_methods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signup_methods
    * const signup_methods = await prisma.signup_methods.findMany()
    * ```
    */
  get signup_methods(): Prisma.signup_methodsDelegate;

  /**
   * `prisma.startup_images`: Exposes CRUD operations for the **startup_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Startup_images
    * const startup_images = await prisma.startup_images.findMany()
    * ```
    */
  get startup_images(): Prisma.startup_imagesDelegate;

  /**
   * `prisma.startups`: Exposes CRUD operations for the **startups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Startups
    * const startups = await prisma.startups.findMany()
    * ```
    */
  get startups(): Prisma.startupsDelegate;

  /**
   * `prisma.wish_investment_series`: Exposes CRUD operations for the **wish_investment_series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wish_investment_series
    * const wish_investment_series = await prisma.wish_investment_series.findMany()
    * ```
    */
  get wish_investment_series(): Prisma.wish_investment_seriesDelegate;

  /**
   * `prisma.startup_likes`: Exposes CRUD operations for the **startup_likes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Startup_likes
    * const startup_likes = await prisma.startup_likes.findMany()
    * ```
    */
  get startup_likes(): Prisma.startup_likesDelegate;

  /**
   * `prisma.technologies`: Exposes CRUD operations for the **technologies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Technologies
    * const technologies = await prisma.technologies.findMany()
    * ```
    */
  get technologies(): Prisma.technologiesDelegate;

  /**
   * `prisma.terms`: Exposes CRUD operations for the **terms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terms
    * const terms = await prisma.terms.findMany()
    * ```
    */
  get terms(): Prisma.termsDelegate;

  /**
   * `prisma.user_agreements`: Exposes CRUD operations for the **user_agreements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_agreements
    * const user_agreements = await prisma.user_agreements.findMany()
    * ```
    */
  get user_agreements(): Prisma.user_agreementsDelegate;

  /**
   * `prisma.user_types`: Exposes CRUD operations for the **user_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_types
    * const user_types = await prisma.user_types.findMany()
    * ```
    */
  get user_types(): Prisma.user_typesDelegate;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate;

  /**
   * `prisma.votes`: Exposes CRUD operations for the **votes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.votes.findMany()
    * ```
    */
  get votes(): Prisma.votesDelegate;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.15.0
   * Query Engine version: e51dc3b5a9ee790a07104bec1c9477d51740fe54
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    answers: 'answers',
    applicants: 'applicants',
    applicant_documents: 'applicant_documents',
    business_types: 'business_types',
    companies: 'companies',
    company_documents: 'company_documents',
    company_members: 'company_members',
    company_news: 'company_news',
    company_types: 'company_types',
    demodays: 'demodays',
    document_types: 'document_types',
    eligibilities: 'eligibilities',
    eligible_sectors: 'eligible_sectors',
    email_auth: 'email_auth',
    invested_from: 'invested_from',
    invested_to: 'invested_to',
    investment_funds: 'investment_funds',
    investment_portfolio: 'investment_portfolio',
    investment_series: 'investment_series',
    IR_requests: 'IR_requests',
    participants: 'participants',
    partners: 'partners',
    partner_likes: 'partner_likes',
    phone_auth: 'phone_auth',
    project_images: 'project_images',
    project_likes: 'project_likes',
    projects: 'projects',
    questions: 'questions',
    recent_views_project: 'recent_views_project',
    required_documents: 'required_documents',
    sectors: 'sectors',
    service_types: 'service_types',
    signup_methods: 'signup_methods',
    startup_images: 'startup_images',
    startups: 'startups',
    wish_investment_series: 'wish_investment_series',
    startup_likes: 'startup_likes',
    technologies: 'technologies',
    terms: 'terms',
    user_agreements: 'user_agreements',
    user_types: 'user_types',
    users: 'users',
    votes: 'votes'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 

  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model answers
   */


  export type AggregateAnswers = {
    count: AnswersCountAggregateOutputType | null
    avg: AnswersAvgAggregateOutputType | null
    sum: AnswersSumAggregateOutputType | null
    min: AnswersMinAggregateOutputType | null
    max: AnswersMaxAggregateOutputType | null
  }

  export type AnswersAvgAggregateOutputType = {
    id: number
    question_id: number
  }

  export type AnswersSumAggregateOutputType = {
    id: number
    question_id: number
  }

  export type AnswersMinAggregateOutputType = {
    id: number
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    question_id: number
  }

  export type AnswersMaxAggregateOutputType = {
    id: number
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    question_id: number
  }

  export type AnswersCountAggregateOutputType = {
    id: number
    content: number | null
    created_at: number | null
    updated_at: number | null
    question_id: number
    _all: number
  }


  export type AnswersAvgAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type AnswersSumAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type AnswersMinAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    updated_at?: true
    question_id?: true
  }

  export type AnswersMaxAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    updated_at?: true
    question_id?: true
  }

  export type AnswersCountAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    updated_at?: true
    question_id?: true
    _all?: true
  }

  export type AnswersAggregateArgs = {
    /**
     * Filter which answers to aggregate.
    **/
    where?: answersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of answers to fetch.
    **/
    orderBy?: Enumerable<answersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned answers
    **/
    count?: true | AnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AnswersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AnswersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AnswersMaxAggregateInputType
  }

  export type GetAnswersAggregateType<T extends AnswersAggregateArgs> = {
    [P in keyof T & keyof AggregateAnswers]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswers[P]>
      : GetScalarType<T[P], AggregateAnswers[P]>
  }



  export type answersSelect = {
    id?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    question_id?: boolean
    questions?: boolean | questionsArgs
  }

  export type answersInclude = {
    questions?: boolean | questionsArgs
  }

  export type answersGetPayload<
    S extends boolean | null | undefined | answersArgs,
    U = keyof S
      > = S extends true
        ? answers
    : S extends undefined
    ? never
    : S extends answersArgs | answersFindManyArgs
    ?'include' extends U
    ? answers  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'questions'
        ? questionsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof answers ?answers [P]
  : 
          P extends 'questions'
        ? questionsGetPayload<S['select'][P]> : never
  } 
    : answers
  : answers


  type answersCountArgs = Merge<
    Omit<answersFindManyArgs, 'select' | 'include'> & {
      select?: AnswersCountAggregateInputType | true
    }
  >

  export interface answersDelegate {
    /**
     * Find zero or one Answers that matches the filter.
     * @param {answersFindUniqueArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends answersFindUniqueArgs>(
      args: SelectSubset<T, answersFindUniqueArgs>
    ): CheckSelect<T, Prisma__answersClient<answers | null>, Prisma__answersClient<answersGetPayload<T> | null>>

    /**
     * Find the first Answers that matches the filter.
     * @param {answersFindFirstArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends answersFindFirstArgs>(
      args?: SelectSubset<T, answersFindFirstArgs>
    ): CheckSelect<T, Prisma__answersClient<answers | null>, Prisma__answersClient<answersGetPayload<T> | null>>

    /**
     * Find zero or more Answers that matches the filter.
     * @param {answersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answers.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answersWithIdOnly = await prisma.answers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends answersFindManyArgs>(
      args?: SelectSubset<T, answersFindManyArgs>
    ): CheckSelect<T, Promise<Array<answers>>, Promise<Array<answersGetPayload<T>>>>

    /**
     * Create a Answers.
     * @param {answersCreateArgs} args - Arguments to create a Answers.
     * @example
     * // Create one Answers
     * const Answers = await prisma.answers.create({
     *   data: {
     *     // ... data to create a Answers
     *   }
     * })
     * 
    **/
    create<T extends answersCreateArgs>(
      args: SelectSubset<T, answersCreateArgs>
    ): CheckSelect<T, Prisma__answersClient<answers>, Prisma__answersClient<answersGetPayload<T>>>

    /**
     * Delete a Answers.
     * @param {answersDeleteArgs} args - Arguments to delete one Answers.
     * @example
     * // Delete one Answers
     * const Answers = await prisma.answers.delete({
     *   where: {
     *     // ... filter to delete one Answers
     *   }
     * })
     * 
    **/
    delete<T extends answersDeleteArgs>(
      args: SelectSubset<T, answersDeleteArgs>
    ): CheckSelect<T, Prisma__answersClient<answers>, Prisma__answersClient<answersGetPayload<T>>>

    /**
     * Update one Answers.
     * @param {answersUpdateArgs} args - Arguments to update one Answers.
     * @example
     * // Update one Answers
     * const answers = await prisma.answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends answersUpdateArgs>(
      args: SelectSubset<T, answersUpdateArgs>
    ): CheckSelect<T, Prisma__answersClient<answers>, Prisma__answersClient<answersGetPayload<T>>>

    /**
     * Delete zero or more Answers.
     * @param {answersDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends answersDeleteManyArgs>(
      args?: SelectSubset<T, answersDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Answers.
     * @param {answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends answersUpdateManyArgs>(
      args: SelectSubset<T, answersUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Answers.
     * @param {answersUpsertArgs} args - Arguments to update or create a Answers.
     * @example
     * // Update or create a Answers
     * const answers = await prisma.answers.upsert({
     *   create: {
     *     // ... data to create a Answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answers we want to update
     *   }
     * })
    **/
    upsert<T extends answersUpsertArgs>(
      args: SelectSubset<T, answersUpsertArgs>
    ): CheckSelect<T, Prisma__answersClient<answers>, Prisma__answersClient<answersGetPayload<T>>>

    /**
     * Count the number of Answers.
     * @param {answersCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answers.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends answersCountArgs>(
      args?: Subset<T, answersCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answers.
     * @param {AnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswersAggregateArgs>(args: Subset<T, AnswersAggregateArgs>): Promise<GetAnswersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__answersClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    questions<T extends questionsArgs = {}>(args?: Subset<T, questionsArgs>): CheckSelect<T, Prisma__questionsClient<questions | null>, Prisma__questionsClient<questionsGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * answers findUnique
   */
  export type answersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the answers
    **/
    select?: answersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: answersInclude | null
    /**
     * Throw an Error if a answers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which answers to fetch.
    **/
    where: answersWhereUniqueInput
  }


  /**
   * answers findFirst
   */
  export type answersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the answers
    **/
    select?: answersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: answersInclude | null
    /**
     * Throw an Error if a answers can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which answers to fetch.
    **/
    where?: answersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of answers to fetch.
    **/
    orderBy?: Enumerable<answersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answers.
    **/
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of answers.
    **/
    distinct?: Enumerable<AnswersScalarFieldEnum>
  }


  /**
   * answers findMany
   */
  export type answersFindManyArgs = {
    /**
     * Select specific fields to fetch from the answers
    **/
    select?: answersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: answersInclude | null
    /**
     * Filter, which answers to fetch.
    **/
    where?: answersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of answers to fetch.
    **/
    orderBy?: Enumerable<answersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing answers.
    **/
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
    **/
    skip?: number
    distinct?: Enumerable<AnswersScalarFieldEnum>
  }


  /**
   * answers create
   */
  export type answersCreateArgs = {
    /**
     * Select specific fields to fetch from the answers
    **/
    select?: answersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: answersInclude | null
    /**
     * The data needed to create a answers.
    **/
    data: XOR<answersUncheckedCreateInput, answersCreateInput>
  }


  /**
   * answers update
   */
  export type answersUpdateArgs = {
    /**
     * Select specific fields to fetch from the answers
    **/
    select?: answersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: answersInclude | null
    /**
     * The data needed to update a answers.
    **/
    data: XOR<answersUncheckedUpdateInput, answersUpdateInput>
    /**
     * Choose, which answers to update.
    **/
    where: answersWhereUniqueInput
  }


  /**
   * answers updateMany
   */
  export type answersUpdateManyArgs = {
    data: XOR<answersUncheckedUpdateManyInput, answersUpdateManyMutationInput>
    where?: answersWhereInput
  }


  /**
   * answers upsert
   */
  export type answersUpsertArgs = {
    /**
     * Select specific fields to fetch from the answers
    **/
    select?: answersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: answersInclude | null
    /**
     * The filter to search for the answers to update in case it exists.
    **/
    where: answersWhereUniqueInput
    /**
     * In case the answers found by the `where` argument doesn't exist, create a new answers with this data.
    **/
    create: XOR<answersUncheckedCreateInput, answersCreateInput>
    /**
     * In case the answers was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<answersUncheckedUpdateInput, answersUpdateInput>
  }


  /**
   * answers delete
   */
  export type answersDeleteArgs = {
    /**
     * Select specific fields to fetch from the answers
    **/
    select?: answersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: answersInclude | null
    /**
     * Filter which answers to delete.
    **/
    where: answersWhereUniqueInput
  }


  /**
   * answers deleteMany
   */
  export type answersDeleteManyArgs = {
    where?: answersWhereInput
  }


  /**
   * answers without action
   */
  export type answersArgs = {
    /**
     * Select specific fields to fetch from the answers
    **/
    select?: answersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: answersInclude | null
  }



  /**
   * Model applicants
   */


  export type AggregateApplicants = {
    count: ApplicantsCountAggregateOutputType | null
    avg: ApplicantsAvgAggregateOutputType | null
    sum: ApplicantsSumAggregateOutputType | null
    min: ApplicantsMinAggregateOutputType | null
    max: ApplicantsMaxAggregateOutputType | null
  }

  export type ApplicantsAvgAggregateOutputType = {
    id: number
    company_id: number
    project_id: number
  }

  export type ApplicantsSumAggregateOutputType = {
    id: number
    company_id: number
    project_id: number
  }

  export type ApplicantsMinAggregateOutputType = {
    id: number
    company_id: number
    project_id: number
    business_brief: string | null
    business_model: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ApplicantsMaxAggregateOutputType = {
    id: number
    company_id: number
    project_id: number
    business_brief: string | null
    business_model: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ApplicantsCountAggregateOutputType = {
    id: number
    company_id: number
    project_id: number
    business_brief: number | null
    business_model: number | null
    created_at: number | null
    updated_at: number | null
    deleted_at: number | null
    _all: number
  }


  export type ApplicantsAvgAggregateInputType = {
    id?: true
    company_id?: true
    project_id?: true
  }

  export type ApplicantsSumAggregateInputType = {
    id?: true
    company_id?: true
    project_id?: true
  }

  export type ApplicantsMinAggregateInputType = {
    id?: true
    company_id?: true
    project_id?: true
    business_brief?: true
    business_model?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ApplicantsMaxAggregateInputType = {
    id?: true
    company_id?: true
    project_id?: true
    business_brief?: true
    business_model?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ApplicantsCountAggregateInputType = {
    id?: true
    company_id?: true
    project_id?: true
    business_brief?: true
    business_model?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ApplicantsAggregateArgs = {
    /**
     * Filter which applicants to aggregate.
    **/
    where?: applicantsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of applicants to fetch.
    **/
    orderBy?: Enumerable<applicantsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicants from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicants.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicants
    **/
    count?: true | ApplicantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ApplicantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ApplicantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ApplicantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ApplicantsMaxAggregateInputType
  }

  export type GetApplicantsAggregateType<T extends ApplicantsAggregateArgs> = {
    [P in keyof T & keyof AggregateApplicants]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicants[P]>
      : GetScalarType<T[P], AggregateApplicants[P]>
  }



  export type applicantsSelect = {
    id?: boolean
    company_id?: boolean
    project_id?: boolean
    business_brief?: boolean
    business_model?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    companies?: boolean | companiesArgs
    projects?: boolean | projectsArgs
    applicant_documents?: boolean | applicant_documentsFindManyArgs
  }

  export type applicantsInclude = {
    companies?: boolean | companiesArgs
    projects?: boolean | projectsArgs
    applicant_documents?: boolean | applicant_documentsFindManyArgs
  }

  export type applicantsGetPayload<
    S extends boolean | null | undefined | applicantsArgs,
    U = keyof S
      > = S extends true
        ? applicants
    : S extends undefined
    ? never
    : S extends applicantsArgs | applicantsFindManyArgs
    ?'include' extends U
    ? applicants  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'projects'
        ? projectsGetPayload<S['include'][P]> :
        P extends 'applicant_documents'
        ? Array < applicant_documentsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof applicants ?applicants [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'projects'
        ? projectsGetPayload<S['select'][P]> :
        P extends 'applicant_documents'
        ? Array < applicant_documentsGetPayload<S['select'][P]>>  : never
  } 
    : applicants
  : applicants


  type applicantsCountArgs = Merge<
    Omit<applicantsFindManyArgs, 'select' | 'include'> & {
      select?: ApplicantsCountAggregateInputType | true
    }
  >

  export interface applicantsDelegate {
    /**
     * Find zero or one Applicants that matches the filter.
     * @param {applicantsFindUniqueArgs} args - Arguments to find a Applicants
     * @example
     * // Get one Applicants
     * const applicants = await prisma.applicants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends applicantsFindUniqueArgs>(
      args: SelectSubset<T, applicantsFindUniqueArgs>
    ): CheckSelect<T, Prisma__applicantsClient<applicants | null>, Prisma__applicantsClient<applicantsGetPayload<T> | null>>

    /**
     * Find the first Applicants that matches the filter.
     * @param {applicantsFindFirstArgs} args - Arguments to find a Applicants
     * @example
     * // Get one Applicants
     * const applicants = await prisma.applicants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends applicantsFindFirstArgs>(
      args?: SelectSubset<T, applicantsFindFirstArgs>
    ): CheckSelect<T, Prisma__applicantsClient<applicants | null>, Prisma__applicantsClient<applicantsGetPayload<T> | null>>

    /**
     * Find zero or more Applicants that matches the filter.
     * @param {applicantsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicants
     * const applicants = await prisma.applicants.findMany()
     * 
     * // Get first 10 Applicants
     * const applicants = await prisma.applicants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicantsWithIdOnly = await prisma.applicants.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends applicantsFindManyArgs>(
      args?: SelectSubset<T, applicantsFindManyArgs>
    ): CheckSelect<T, Promise<Array<applicants>>, Promise<Array<applicantsGetPayload<T>>>>

    /**
     * Create a Applicants.
     * @param {applicantsCreateArgs} args - Arguments to create a Applicants.
     * @example
     * // Create one Applicants
     * const Applicants = await prisma.applicants.create({
     *   data: {
     *     // ... data to create a Applicants
     *   }
     * })
     * 
    **/
    create<T extends applicantsCreateArgs>(
      args: SelectSubset<T, applicantsCreateArgs>
    ): CheckSelect<T, Prisma__applicantsClient<applicants>, Prisma__applicantsClient<applicantsGetPayload<T>>>

    /**
     * Delete a Applicants.
     * @param {applicantsDeleteArgs} args - Arguments to delete one Applicants.
     * @example
     * // Delete one Applicants
     * const Applicants = await prisma.applicants.delete({
     *   where: {
     *     // ... filter to delete one Applicants
     *   }
     * })
     * 
    **/
    delete<T extends applicantsDeleteArgs>(
      args: SelectSubset<T, applicantsDeleteArgs>
    ): CheckSelect<T, Prisma__applicantsClient<applicants>, Prisma__applicantsClient<applicantsGetPayload<T>>>

    /**
     * Update one Applicants.
     * @param {applicantsUpdateArgs} args - Arguments to update one Applicants.
     * @example
     * // Update one Applicants
     * const applicants = await prisma.applicants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends applicantsUpdateArgs>(
      args: SelectSubset<T, applicantsUpdateArgs>
    ): CheckSelect<T, Prisma__applicantsClient<applicants>, Prisma__applicantsClient<applicantsGetPayload<T>>>

    /**
     * Delete zero or more Applicants.
     * @param {applicantsDeleteManyArgs} args - Arguments to filter Applicants to delete.
     * @example
     * // Delete a few Applicants
     * const { count } = await prisma.applicants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends applicantsDeleteManyArgs>(
      args?: SelectSubset<T, applicantsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Applicants.
     * @param {applicantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicants
     * const applicants = await prisma.applicants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends applicantsUpdateManyArgs>(
      args: SelectSubset<T, applicantsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Applicants.
     * @param {applicantsUpsertArgs} args - Arguments to update or create a Applicants.
     * @example
     * // Update or create a Applicants
     * const applicants = await prisma.applicants.upsert({
     *   create: {
     *     // ... data to create a Applicants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicants we want to update
     *   }
     * })
    **/
    upsert<T extends applicantsUpsertArgs>(
      args: SelectSubset<T, applicantsUpsertArgs>
    ): CheckSelect<T, Prisma__applicantsClient<applicants>, Prisma__applicantsClient<applicantsGetPayload<T>>>

    /**
     * Count the number of Applicants.
     * @param {applicantsCountArgs} args - Arguments to filter Applicants to count.
     * @example
     * // Count the number of Applicants
     * const count = await prisma.applicants.count({
     *   where: {
     *     // ... the filter for the Applicants we want to count
     *   }
     * })
    **/
    count<T extends applicantsCountArgs>(
      args?: Subset<T, applicantsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicants.
     * @param {ApplicantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicantsAggregateArgs>(args: Subset<T, ApplicantsAggregateArgs>): Promise<GetApplicantsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for applicants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__applicantsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    projects<T extends projectsArgs = {}>(args?: Subset<T, projectsArgs>): CheckSelect<T, Prisma__projectsClient<projects | null>, Prisma__projectsClient<projectsGetPayload<T> | null>>;

    applicant_documents<T extends applicant_documentsFindManyArgs = {}>(args?: Subset<T, applicant_documentsFindManyArgs>): CheckSelect<T, Promise<Array<applicant_documents>>, Promise<Array<applicant_documentsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * applicants findUnique
   */
  export type applicantsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the applicants
    **/
    select?: applicantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicantsInclude | null
    /**
     * Throw an Error if a applicants can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which applicants to fetch.
    **/
    where: applicantsWhereUniqueInput
  }


  /**
   * applicants findFirst
   */
  export type applicantsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the applicants
    **/
    select?: applicantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicantsInclude | null
    /**
     * Throw an Error if a applicants can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which applicants to fetch.
    **/
    where?: applicantsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of applicants to fetch.
    **/
    orderBy?: Enumerable<applicantsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicants.
    **/
    cursor?: applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicants from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicants.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of applicants.
    **/
    distinct?: Enumerable<ApplicantsScalarFieldEnum>
  }


  /**
   * applicants findMany
   */
  export type applicantsFindManyArgs = {
    /**
     * Select specific fields to fetch from the applicants
    **/
    select?: applicantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicantsInclude | null
    /**
     * Filter, which applicants to fetch.
    **/
    where?: applicantsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of applicants to fetch.
    **/
    orderBy?: Enumerable<applicantsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicants.
    **/
    cursor?: applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicants from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicants.
    **/
    skip?: number
    distinct?: Enumerable<ApplicantsScalarFieldEnum>
  }


  /**
   * applicants create
   */
  export type applicantsCreateArgs = {
    /**
     * Select specific fields to fetch from the applicants
    **/
    select?: applicantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicantsInclude | null
    /**
     * The data needed to create a applicants.
    **/
    data: XOR<applicantsUncheckedCreateInput, applicantsCreateInput>
  }


  /**
   * applicants update
   */
  export type applicantsUpdateArgs = {
    /**
     * Select specific fields to fetch from the applicants
    **/
    select?: applicantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicantsInclude | null
    /**
     * The data needed to update a applicants.
    **/
    data: XOR<applicantsUncheckedUpdateInput, applicantsUpdateInput>
    /**
     * Choose, which applicants to update.
    **/
    where: applicantsWhereUniqueInput
  }


  /**
   * applicants updateMany
   */
  export type applicantsUpdateManyArgs = {
    data: XOR<applicantsUncheckedUpdateManyInput, applicantsUpdateManyMutationInput>
    where?: applicantsWhereInput
  }


  /**
   * applicants upsert
   */
  export type applicantsUpsertArgs = {
    /**
     * Select specific fields to fetch from the applicants
    **/
    select?: applicantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicantsInclude | null
    /**
     * The filter to search for the applicants to update in case it exists.
    **/
    where: applicantsWhereUniqueInput
    /**
     * In case the applicants found by the `where` argument doesn't exist, create a new applicants with this data.
    **/
    create: XOR<applicantsUncheckedCreateInput, applicantsCreateInput>
    /**
     * In case the applicants was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<applicantsUncheckedUpdateInput, applicantsUpdateInput>
  }


  /**
   * applicants delete
   */
  export type applicantsDeleteArgs = {
    /**
     * Select specific fields to fetch from the applicants
    **/
    select?: applicantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicantsInclude | null
    /**
     * Filter which applicants to delete.
    **/
    where: applicantsWhereUniqueInput
  }


  /**
   * applicants deleteMany
   */
  export type applicantsDeleteManyArgs = {
    where?: applicantsWhereInput
  }


  /**
   * applicants without action
   */
  export type applicantsArgs = {
    /**
     * Select specific fields to fetch from the applicants
    **/
    select?: applicantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicantsInclude | null
  }



  /**
   * Model applicant_documents
   */


  export type AggregateApplicant_documents = {
    count: Applicant_documentsCountAggregateOutputType | null
    avg: Applicant_documentsAvgAggregateOutputType | null
    sum: Applicant_documentsSumAggregateOutputType | null
    min: Applicant_documentsMinAggregateOutputType | null
    max: Applicant_documentsMaxAggregateOutputType | null
  }

  export type Applicant_documentsAvgAggregateOutputType = {
    id: number
    applicant_id: number
    document_id: number
  }

  export type Applicant_documentsSumAggregateOutputType = {
    id: number
    applicant_id: number
    document_id: number
  }

  export type Applicant_documentsMinAggregateOutputType = {
    id: number
    applicant_id: number
    document_id: number
  }

  export type Applicant_documentsMaxAggregateOutputType = {
    id: number
    applicant_id: number
    document_id: number
  }

  export type Applicant_documentsCountAggregateOutputType = {
    id: number
    applicant_id: number
    document_id: number
    _all: number
  }


  export type Applicant_documentsAvgAggregateInputType = {
    id?: true
    applicant_id?: true
    document_id?: true
  }

  export type Applicant_documentsSumAggregateInputType = {
    id?: true
    applicant_id?: true
    document_id?: true
  }

  export type Applicant_documentsMinAggregateInputType = {
    id?: true
    applicant_id?: true
    document_id?: true
  }

  export type Applicant_documentsMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    document_id?: true
  }

  export type Applicant_documentsCountAggregateInputType = {
    id?: true
    applicant_id?: true
    document_id?: true
    _all?: true
  }

  export type Applicant_documentsAggregateArgs = {
    /**
     * Filter which applicant_documents to aggregate.
    **/
    where?: applicant_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of applicant_documents to fetch.
    **/
    orderBy?: Enumerable<applicant_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: applicant_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicant_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicant_documents.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicant_documents
    **/
    count?: true | Applicant_documentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Applicant_documentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Applicant_documentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Applicant_documentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Applicant_documentsMaxAggregateInputType
  }

  export type GetApplicant_documentsAggregateType<T extends Applicant_documentsAggregateArgs> = {
    [P in keyof T & keyof AggregateApplicant_documents]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicant_documents[P]>
      : GetScalarType<T[P], AggregateApplicant_documents[P]>
  }



  export type applicant_documentsSelect = {
    id?: boolean
    applicant_id?: boolean
    document_id?: boolean
    applicants?: boolean | applicantsArgs
    company_documents?: boolean | company_documentsArgs
  }

  export type applicant_documentsInclude = {
    applicants?: boolean | applicantsArgs
    company_documents?: boolean | company_documentsArgs
  }

  export type applicant_documentsGetPayload<
    S extends boolean | null | undefined | applicant_documentsArgs,
    U = keyof S
      > = S extends true
        ? applicant_documents
    : S extends undefined
    ? never
    : S extends applicant_documentsArgs | applicant_documentsFindManyArgs
    ?'include' extends U
    ? applicant_documents  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'applicants'
        ? applicantsGetPayload<S['include'][P]> :
        P extends 'company_documents'
        ? company_documentsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof applicant_documents ?applicant_documents [P]
  : 
          P extends 'applicants'
        ? applicantsGetPayload<S['select'][P]> :
        P extends 'company_documents'
        ? company_documentsGetPayload<S['select'][P]> : never
  } 
    : applicant_documents
  : applicant_documents


  type applicant_documentsCountArgs = Merge<
    Omit<applicant_documentsFindManyArgs, 'select' | 'include'> & {
      select?: Applicant_documentsCountAggregateInputType | true
    }
  >

  export interface applicant_documentsDelegate {
    /**
     * Find zero or one Applicant_documents that matches the filter.
     * @param {applicant_documentsFindUniqueArgs} args - Arguments to find a Applicant_documents
     * @example
     * // Get one Applicant_documents
     * const applicant_documents = await prisma.applicant_documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends applicant_documentsFindUniqueArgs>(
      args: SelectSubset<T, applicant_documentsFindUniqueArgs>
    ): CheckSelect<T, Prisma__applicant_documentsClient<applicant_documents | null>, Prisma__applicant_documentsClient<applicant_documentsGetPayload<T> | null>>

    /**
     * Find the first Applicant_documents that matches the filter.
     * @param {applicant_documentsFindFirstArgs} args - Arguments to find a Applicant_documents
     * @example
     * // Get one Applicant_documents
     * const applicant_documents = await prisma.applicant_documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends applicant_documentsFindFirstArgs>(
      args?: SelectSubset<T, applicant_documentsFindFirstArgs>
    ): CheckSelect<T, Prisma__applicant_documentsClient<applicant_documents | null>, Prisma__applicant_documentsClient<applicant_documentsGetPayload<T> | null>>

    /**
     * Find zero or more Applicant_documents that matches the filter.
     * @param {applicant_documentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicant_documents
     * const applicant_documents = await prisma.applicant_documents.findMany()
     * 
     * // Get first 10 Applicant_documents
     * const applicant_documents = await prisma.applicant_documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applicant_documentsWithIdOnly = await prisma.applicant_documents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends applicant_documentsFindManyArgs>(
      args?: SelectSubset<T, applicant_documentsFindManyArgs>
    ): CheckSelect<T, Promise<Array<applicant_documents>>, Promise<Array<applicant_documentsGetPayload<T>>>>

    /**
     * Create a Applicant_documents.
     * @param {applicant_documentsCreateArgs} args - Arguments to create a Applicant_documents.
     * @example
     * // Create one Applicant_documents
     * const Applicant_documents = await prisma.applicant_documents.create({
     *   data: {
     *     // ... data to create a Applicant_documents
     *   }
     * })
     * 
    **/
    create<T extends applicant_documentsCreateArgs>(
      args: SelectSubset<T, applicant_documentsCreateArgs>
    ): CheckSelect<T, Prisma__applicant_documentsClient<applicant_documents>, Prisma__applicant_documentsClient<applicant_documentsGetPayload<T>>>

    /**
     * Delete a Applicant_documents.
     * @param {applicant_documentsDeleteArgs} args - Arguments to delete one Applicant_documents.
     * @example
     * // Delete one Applicant_documents
     * const Applicant_documents = await prisma.applicant_documents.delete({
     *   where: {
     *     // ... filter to delete one Applicant_documents
     *   }
     * })
     * 
    **/
    delete<T extends applicant_documentsDeleteArgs>(
      args: SelectSubset<T, applicant_documentsDeleteArgs>
    ): CheckSelect<T, Prisma__applicant_documentsClient<applicant_documents>, Prisma__applicant_documentsClient<applicant_documentsGetPayload<T>>>

    /**
     * Update one Applicant_documents.
     * @param {applicant_documentsUpdateArgs} args - Arguments to update one Applicant_documents.
     * @example
     * // Update one Applicant_documents
     * const applicant_documents = await prisma.applicant_documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends applicant_documentsUpdateArgs>(
      args: SelectSubset<T, applicant_documentsUpdateArgs>
    ): CheckSelect<T, Prisma__applicant_documentsClient<applicant_documents>, Prisma__applicant_documentsClient<applicant_documentsGetPayload<T>>>

    /**
     * Delete zero or more Applicant_documents.
     * @param {applicant_documentsDeleteManyArgs} args - Arguments to filter Applicant_documents to delete.
     * @example
     * // Delete a few Applicant_documents
     * const { count } = await prisma.applicant_documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends applicant_documentsDeleteManyArgs>(
      args?: SelectSubset<T, applicant_documentsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Applicant_documents.
     * @param {applicant_documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicant_documents
     * const applicant_documents = await prisma.applicant_documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends applicant_documentsUpdateManyArgs>(
      args: SelectSubset<T, applicant_documentsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Applicant_documents.
     * @param {applicant_documentsUpsertArgs} args - Arguments to update or create a Applicant_documents.
     * @example
     * // Update or create a Applicant_documents
     * const applicant_documents = await prisma.applicant_documents.upsert({
     *   create: {
     *     // ... data to create a Applicant_documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicant_documents we want to update
     *   }
     * })
    **/
    upsert<T extends applicant_documentsUpsertArgs>(
      args: SelectSubset<T, applicant_documentsUpsertArgs>
    ): CheckSelect<T, Prisma__applicant_documentsClient<applicant_documents>, Prisma__applicant_documentsClient<applicant_documentsGetPayload<T>>>

    /**
     * Count the number of Applicant_documents.
     * @param {applicant_documentsCountArgs} args - Arguments to filter Applicant_documents to count.
     * @example
     * // Count the number of Applicant_documents
     * const count = await prisma.applicant_documents.count({
     *   where: {
     *     // ... the filter for the Applicant_documents we want to count
     *   }
     * })
    **/
    count<T extends applicant_documentsCountArgs>(
      args?: Subset<T, applicant_documentsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Applicant_documentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicant_documents.
     * @param {Applicant_documentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Applicant_documentsAggregateArgs>(args: Subset<T, Applicant_documentsAggregateArgs>): Promise<GetApplicant_documentsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for applicant_documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__applicant_documentsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    applicants<T extends applicantsArgs = {}>(args?: Subset<T, applicantsArgs>): CheckSelect<T, Prisma__applicantsClient<applicants | null>, Prisma__applicantsClient<applicantsGetPayload<T> | null>>;

    company_documents<T extends company_documentsArgs = {}>(args?: Subset<T, company_documentsArgs>): CheckSelect<T, Prisma__company_documentsClient<company_documents | null>, Prisma__company_documentsClient<company_documentsGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * applicant_documents findUnique
   */
  export type applicant_documentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the applicant_documents
    **/
    select?: applicant_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicant_documentsInclude | null
    /**
     * Throw an Error if a applicant_documents can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which applicant_documents to fetch.
    **/
    where: applicant_documentsWhereUniqueInput
  }


  /**
   * applicant_documents findFirst
   */
  export type applicant_documentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the applicant_documents
    **/
    select?: applicant_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicant_documentsInclude | null
    /**
     * Throw an Error if a applicant_documents can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which applicant_documents to fetch.
    **/
    where?: applicant_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of applicant_documents to fetch.
    **/
    orderBy?: Enumerable<applicant_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicant_documents.
    **/
    cursor?: applicant_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicant_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicant_documents.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of applicant_documents.
    **/
    distinct?: Enumerable<Applicant_documentsScalarFieldEnum>
  }


  /**
   * applicant_documents findMany
   */
  export type applicant_documentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the applicant_documents
    **/
    select?: applicant_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicant_documentsInclude | null
    /**
     * Filter, which applicant_documents to fetch.
    **/
    where?: applicant_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of applicant_documents to fetch.
    **/
    orderBy?: Enumerable<applicant_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicant_documents.
    **/
    cursor?: applicant_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicant_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicant_documents.
    **/
    skip?: number
    distinct?: Enumerable<Applicant_documentsScalarFieldEnum>
  }


  /**
   * applicant_documents create
   */
  export type applicant_documentsCreateArgs = {
    /**
     * Select specific fields to fetch from the applicant_documents
    **/
    select?: applicant_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicant_documentsInclude | null
    /**
     * The data needed to create a applicant_documents.
    **/
    data: XOR<applicant_documentsUncheckedCreateInput, applicant_documentsCreateInput>
  }


  /**
   * applicant_documents update
   */
  export type applicant_documentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the applicant_documents
    **/
    select?: applicant_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicant_documentsInclude | null
    /**
     * The data needed to update a applicant_documents.
    **/
    data: XOR<applicant_documentsUncheckedUpdateInput, applicant_documentsUpdateInput>
    /**
     * Choose, which applicant_documents to update.
    **/
    where: applicant_documentsWhereUniqueInput
  }


  /**
   * applicant_documents updateMany
   */
  export type applicant_documentsUpdateManyArgs = {
    data: XOR<applicant_documentsUncheckedUpdateManyInput, applicant_documentsUpdateManyMutationInput>
    where?: applicant_documentsWhereInput
  }


  /**
   * applicant_documents upsert
   */
  export type applicant_documentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the applicant_documents
    **/
    select?: applicant_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicant_documentsInclude | null
    /**
     * The filter to search for the applicant_documents to update in case it exists.
    **/
    where: applicant_documentsWhereUniqueInput
    /**
     * In case the applicant_documents found by the `where` argument doesn't exist, create a new applicant_documents with this data.
    **/
    create: XOR<applicant_documentsUncheckedCreateInput, applicant_documentsCreateInput>
    /**
     * In case the applicant_documents was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<applicant_documentsUncheckedUpdateInput, applicant_documentsUpdateInput>
  }


  /**
   * applicant_documents delete
   */
  export type applicant_documentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the applicant_documents
    **/
    select?: applicant_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicant_documentsInclude | null
    /**
     * Filter which applicant_documents to delete.
    **/
    where: applicant_documentsWhereUniqueInput
  }


  /**
   * applicant_documents deleteMany
   */
  export type applicant_documentsDeleteManyArgs = {
    where?: applicant_documentsWhereInput
  }


  /**
   * applicant_documents without action
   */
  export type applicant_documentsArgs = {
    /**
     * Select specific fields to fetch from the applicant_documents
    **/
    select?: applicant_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: applicant_documentsInclude | null
  }



  /**
   * Model business_types
   */


  export type AggregateBusiness_types = {
    count: Business_typesCountAggregateOutputType | null
    avg: Business_typesAvgAggregateOutputType | null
    sum: Business_typesSumAggregateOutputType | null
    min: Business_typesMinAggregateOutputType | null
    max: Business_typesMaxAggregateOutputType | null
  }

  export type Business_typesAvgAggregateOutputType = {
    id: number
  }

  export type Business_typesSumAggregateOutputType = {
    id: number
  }

  export type Business_typesMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Business_typesMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Business_typesCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type Business_typesAvgAggregateInputType = {
    id?: true
  }

  export type Business_typesSumAggregateInputType = {
    id?: true
  }

  export type Business_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Business_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Business_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Business_typesAggregateArgs = {
    /**
     * Filter which business_types to aggregate.
    **/
    where?: business_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of business_types to fetch.
    **/
    orderBy?: Enumerable<business_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: business_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_types.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned business_types
    **/
    count?: true | Business_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Business_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Business_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Business_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Business_typesMaxAggregateInputType
  }

  export type GetBusiness_typesAggregateType<T extends Business_typesAggregateArgs> = {
    [P in keyof T & keyof AggregateBusiness_types]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness_types[P]>
      : GetScalarType<T[P], AggregateBusiness_types[P]>
  }



  export type business_typesSelect = {
    id?: boolean
    name?: boolean
    startups?: boolean | startupsFindManyArgs
  }

  export type business_typesInclude = {
    startups?: boolean | startupsFindManyArgs
  }

  export type business_typesGetPayload<
    S extends boolean | null | undefined | business_typesArgs,
    U = keyof S
      > = S extends true
        ? business_types
    : S extends undefined
    ? never
    : S extends business_typesArgs | business_typesFindManyArgs
    ?'include' extends U
    ? business_types  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'startups'
        ? Array < startupsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof business_types ?business_types [P]
  : 
          P extends 'startups'
        ? Array < startupsGetPayload<S['select'][P]>>  : never
  } 
    : business_types
  : business_types


  type business_typesCountArgs = Merge<
    Omit<business_typesFindManyArgs, 'select' | 'include'> & {
      select?: Business_typesCountAggregateInputType | true
    }
  >

  export interface business_typesDelegate {
    /**
     * Find zero or one Business_types that matches the filter.
     * @param {business_typesFindUniqueArgs} args - Arguments to find a Business_types
     * @example
     * // Get one Business_types
     * const business_types = await prisma.business_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends business_typesFindUniqueArgs>(
      args: SelectSubset<T, business_typesFindUniqueArgs>
    ): CheckSelect<T, Prisma__business_typesClient<business_types | null>, Prisma__business_typesClient<business_typesGetPayload<T> | null>>

    /**
     * Find the first Business_types that matches the filter.
     * @param {business_typesFindFirstArgs} args - Arguments to find a Business_types
     * @example
     * // Get one Business_types
     * const business_types = await prisma.business_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends business_typesFindFirstArgs>(
      args?: SelectSubset<T, business_typesFindFirstArgs>
    ): CheckSelect<T, Prisma__business_typesClient<business_types | null>, Prisma__business_typesClient<business_typesGetPayload<T> | null>>

    /**
     * Find zero or more Business_types that matches the filter.
     * @param {business_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Business_types
     * const business_types = await prisma.business_types.findMany()
     * 
     * // Get first 10 Business_types
     * const business_types = await prisma.business_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const business_typesWithIdOnly = await prisma.business_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends business_typesFindManyArgs>(
      args?: SelectSubset<T, business_typesFindManyArgs>
    ): CheckSelect<T, Promise<Array<business_types>>, Promise<Array<business_typesGetPayload<T>>>>

    /**
     * Create a Business_types.
     * @param {business_typesCreateArgs} args - Arguments to create a Business_types.
     * @example
     * // Create one Business_types
     * const Business_types = await prisma.business_types.create({
     *   data: {
     *     // ... data to create a Business_types
     *   }
     * })
     * 
    **/
    create<T extends business_typesCreateArgs>(
      args: SelectSubset<T, business_typesCreateArgs>
    ): CheckSelect<T, Prisma__business_typesClient<business_types>, Prisma__business_typesClient<business_typesGetPayload<T>>>

    /**
     * Delete a Business_types.
     * @param {business_typesDeleteArgs} args - Arguments to delete one Business_types.
     * @example
     * // Delete one Business_types
     * const Business_types = await prisma.business_types.delete({
     *   where: {
     *     // ... filter to delete one Business_types
     *   }
     * })
     * 
    **/
    delete<T extends business_typesDeleteArgs>(
      args: SelectSubset<T, business_typesDeleteArgs>
    ): CheckSelect<T, Prisma__business_typesClient<business_types>, Prisma__business_typesClient<business_typesGetPayload<T>>>

    /**
     * Update one Business_types.
     * @param {business_typesUpdateArgs} args - Arguments to update one Business_types.
     * @example
     * // Update one Business_types
     * const business_types = await prisma.business_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends business_typesUpdateArgs>(
      args: SelectSubset<T, business_typesUpdateArgs>
    ): CheckSelect<T, Prisma__business_typesClient<business_types>, Prisma__business_typesClient<business_typesGetPayload<T>>>

    /**
     * Delete zero or more Business_types.
     * @param {business_typesDeleteManyArgs} args - Arguments to filter Business_types to delete.
     * @example
     * // Delete a few Business_types
     * const { count } = await prisma.business_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends business_typesDeleteManyArgs>(
      args?: SelectSubset<T, business_typesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Business_types.
     * @param {business_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Business_types
     * const business_types = await prisma.business_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends business_typesUpdateManyArgs>(
      args: SelectSubset<T, business_typesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Business_types.
     * @param {business_typesUpsertArgs} args - Arguments to update or create a Business_types.
     * @example
     * // Update or create a Business_types
     * const business_types = await prisma.business_types.upsert({
     *   create: {
     *     // ... data to create a Business_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business_types we want to update
     *   }
     * })
    **/
    upsert<T extends business_typesUpsertArgs>(
      args: SelectSubset<T, business_typesUpsertArgs>
    ): CheckSelect<T, Prisma__business_typesClient<business_types>, Prisma__business_typesClient<business_typesGetPayload<T>>>

    /**
     * Count the number of Business_types.
     * @param {business_typesCountArgs} args - Arguments to filter Business_types to count.
     * @example
     * // Count the number of Business_types
     * const count = await prisma.business_types.count({
     *   where: {
     *     // ... the filter for the Business_types we want to count
     *   }
     * })
    **/
    count<T extends business_typesCountArgs>(
      args?: Subset<T, business_typesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Business_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business_types.
     * @param {Business_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Business_typesAggregateArgs>(args: Subset<T, Business_typesAggregateArgs>): Promise<GetBusiness_typesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for business_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__business_typesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    startups<T extends startupsFindManyArgs = {}>(args?: Subset<T, startupsFindManyArgs>): CheckSelect<T, Promise<Array<startups>>, Promise<Array<startupsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * business_types findUnique
   */
  export type business_typesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the business_types
    **/
    select?: business_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: business_typesInclude | null
    /**
     * Throw an Error if a business_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which business_types to fetch.
    **/
    where: business_typesWhereUniqueInput
  }


  /**
   * business_types findFirst
   */
  export type business_typesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the business_types
    **/
    select?: business_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: business_typesInclude | null
    /**
     * Throw an Error if a business_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which business_types to fetch.
    **/
    where?: business_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of business_types to fetch.
    **/
    orderBy?: Enumerable<business_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for business_types.
    **/
    cursor?: business_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_types.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of business_types.
    **/
    distinct?: Enumerable<Business_typesScalarFieldEnum>
  }


  /**
   * business_types findMany
   */
  export type business_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the business_types
    **/
    select?: business_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: business_typesInclude | null
    /**
     * Filter, which business_types to fetch.
    **/
    where?: business_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of business_types to fetch.
    **/
    orderBy?: Enumerable<business_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing business_types.
    **/
    cursor?: business_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` business_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` business_types.
    **/
    skip?: number
    distinct?: Enumerable<Business_typesScalarFieldEnum>
  }


  /**
   * business_types create
   */
  export type business_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the business_types
    **/
    select?: business_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: business_typesInclude | null
    /**
     * The data needed to create a business_types.
    **/
    data: XOR<business_typesUncheckedCreateInput, business_typesCreateInput>
  }


  /**
   * business_types update
   */
  export type business_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the business_types
    **/
    select?: business_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: business_typesInclude | null
    /**
     * The data needed to update a business_types.
    **/
    data: XOR<business_typesUncheckedUpdateInput, business_typesUpdateInput>
    /**
     * Choose, which business_types to update.
    **/
    where: business_typesWhereUniqueInput
  }


  /**
   * business_types updateMany
   */
  export type business_typesUpdateManyArgs = {
    data: XOR<business_typesUncheckedUpdateManyInput, business_typesUpdateManyMutationInput>
    where?: business_typesWhereInput
  }


  /**
   * business_types upsert
   */
  export type business_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the business_types
    **/
    select?: business_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: business_typesInclude | null
    /**
     * The filter to search for the business_types to update in case it exists.
    **/
    where: business_typesWhereUniqueInput
    /**
     * In case the business_types found by the `where` argument doesn't exist, create a new business_types with this data.
    **/
    create: XOR<business_typesUncheckedCreateInput, business_typesCreateInput>
    /**
     * In case the business_types was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<business_typesUncheckedUpdateInput, business_typesUpdateInput>
  }


  /**
   * business_types delete
   */
  export type business_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the business_types
    **/
    select?: business_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: business_typesInclude | null
    /**
     * Filter which business_types to delete.
    **/
    where: business_typesWhereUniqueInput
  }


  /**
   * business_types deleteMany
   */
  export type business_typesDeleteManyArgs = {
    where?: business_typesWhereInput
  }


  /**
   * business_types without action
   */
  export type business_typesArgs = {
    /**
     * Select specific fields to fetch from the business_types
    **/
    select?: business_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: business_typesInclude | null
  }



  /**
   * Model companies
   */


  export type AggregateCompanies = {
    count: CompaniesCountAggregateOutputType | null
    avg: CompaniesAvgAggregateOutputType | null
    sum: CompaniesSumAggregateOutputType | null
    min: CompaniesMinAggregateOutputType | null
    max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    id: number
    type_id: number | null
    member_count: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    id: number
    type_id: number | null
    member_count: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: number
    type_id: number | null
    name: string | null
    logo_img: string | null
    established_date: Date | null
    homepage: string | null
    description: string | null
    team_intro: string | null
    member_count: number | null
    is_saved: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: number
    type_id: number | null
    name: string | null
    logo_img: string | null
    established_date: Date | null
    homepage: string | null
    description: string | null
    team_intro: string | null
    member_count: number | null
    is_saved: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    type_id: number | null
    name: number | null
    logo_img: number | null
    established_date: number | null
    homepage: number | null
    description: number | null
    team_intro: number | null
    member_count: number | null
    is_saved: number | null
    created_at: number | null
    updated_at: number | null
    deleted_at: number | null
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    id?: true
    type_id?: true
    member_count?: true
  }

  export type CompaniesSumAggregateInputType = {
    id?: true
    type_id?: true
    member_count?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    type_id?: true
    name?: true
    logo_img?: true
    established_date?: true
    homepage?: true
    description?: true
    team_intro?: true
    member_count?: true
    is_saved?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    type_id?: true
    name?: true
    logo_img?: true
    established_date?: true
    homepage?: true
    description?: true
    team_intro?: true
    member_count?: true
    is_saved?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    type_id?: true
    name?: true
    logo_img?: true
    established_date?: true
    homepage?: true
    description?: true
    team_intro?: true
    member_count?: true
    is_saved?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type CompaniesAggregateArgs = {
    /**
     * Filter which companies to aggregate.
    **/
    where?: companiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of companies to fetch.
    **/
    orderBy?: Enumerable<companiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
    [P in keyof T & keyof AggregateCompanies]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }



  export type companiesSelect = {
    id?: boolean
    type_id?: boolean
    name?: boolean
    logo_img?: boolean
    established_date?: boolean
    homepage?: boolean
    description?: boolean
    team_intro?: boolean
    member_count?: boolean
    is_saved?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    company_types?: boolean | company_typesArgs
    applicants?: boolean | applicantsFindManyArgs
    company_documents?: boolean | company_documentsFindManyArgs
    company_members?: boolean | company_membersFindManyArgs
    company_news?: boolean | company_newsFindManyArgs
    demodays?: boolean | demodaysFindManyArgs
    IR_requests?: boolean | IR_requestsFindManyArgs
    participants?: boolean | participantsFindManyArgs
    partners?: boolean | partnersFindManyArgs
    partner_likes?: boolean | partner_likesFindManyArgs
    project_likes?: boolean | project_likesFindManyArgs
    projects?: boolean | projectsFindManyArgs
    questions?: boolean | questionsFindManyArgs
    recent_views_project?: boolean | recent_views_projectFindManyArgs
    startups?: boolean | startupsFindManyArgs
    startup_likes?: boolean | startup_likesFindManyArgs
    users?: boolean | usersFindManyArgs
  }

  export type companiesInclude = {
    company_types?: boolean | company_typesArgs
    applicants?: boolean | applicantsFindManyArgs
    company_documents?: boolean | company_documentsFindManyArgs
    company_members?: boolean | company_membersFindManyArgs
    company_news?: boolean | company_newsFindManyArgs
    demodays?: boolean | demodaysFindManyArgs
    IR_requests?: boolean | IR_requestsFindManyArgs
    participants?: boolean | participantsFindManyArgs
    partners?: boolean | partnersFindManyArgs
    partner_likes?: boolean | partner_likesFindManyArgs
    project_likes?: boolean | project_likesFindManyArgs
    projects?: boolean | projectsFindManyArgs
    questions?: boolean | questionsFindManyArgs
    recent_views_project?: boolean | recent_views_projectFindManyArgs
    startups?: boolean | startupsFindManyArgs
    startup_likes?: boolean | startup_likesFindManyArgs
    users?: boolean | usersFindManyArgs
  }

  export type companiesGetPayload<
    S extends boolean | null | undefined | companiesArgs,
    U = keyof S
      > = S extends true
        ? companies
    : S extends undefined
    ? never
    : S extends companiesArgs | companiesFindManyArgs
    ?'include' extends U
    ? companies  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'company_types'
        ? company_typesGetPayload<S['include'][P]> | null :
        P extends 'applicants'
        ? Array < applicantsGetPayload<S['include'][P]>>  :
        P extends 'company_documents'
        ? Array < company_documentsGetPayload<S['include'][P]>>  :
        P extends 'company_members'
        ? Array < company_membersGetPayload<S['include'][P]>>  :
        P extends 'company_news'
        ? Array < company_newsGetPayload<S['include'][P]>>  :
        P extends 'demodays'
        ? Array < demodaysGetPayload<S['include'][P]>>  :
        P extends 'IR_requests'
        ? Array < IR_requestsGetPayload<S['include'][P]>>  :
        P extends 'participants'
        ? Array < participantsGetPayload<S['include'][P]>>  :
        P extends 'partners'
        ? Array < partnersGetPayload<S['include'][P]>>  :
        P extends 'partner_likes'
        ? Array < partner_likesGetPayload<S['include'][P]>>  :
        P extends 'project_likes'
        ? Array < project_likesGetPayload<S['include'][P]>>  :
        P extends 'projects'
        ? Array < projectsGetPayload<S['include'][P]>>  :
        P extends 'questions'
        ? Array < questionsGetPayload<S['include'][P]>>  :
        P extends 'recent_views_project'
        ? Array < recent_views_projectGetPayload<S['include'][P]>>  :
        P extends 'startups'
        ? Array < startupsGetPayload<S['include'][P]>>  :
        P extends 'startup_likes'
        ? Array < startup_likesGetPayload<S['include'][P]>>  :
        P extends 'users'
        ? Array < usersGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof companies ?companies [P]
  : 
          P extends 'company_types'
        ? company_typesGetPayload<S['select'][P]> | null :
        P extends 'applicants'
        ? Array < applicantsGetPayload<S['select'][P]>>  :
        P extends 'company_documents'
        ? Array < company_documentsGetPayload<S['select'][P]>>  :
        P extends 'company_members'
        ? Array < company_membersGetPayload<S['select'][P]>>  :
        P extends 'company_news'
        ? Array < company_newsGetPayload<S['select'][P]>>  :
        P extends 'demodays'
        ? Array < demodaysGetPayload<S['select'][P]>>  :
        P extends 'IR_requests'
        ? Array < IR_requestsGetPayload<S['select'][P]>>  :
        P extends 'participants'
        ? Array < participantsGetPayload<S['select'][P]>>  :
        P extends 'partners'
        ? Array < partnersGetPayload<S['select'][P]>>  :
        P extends 'partner_likes'
        ? Array < partner_likesGetPayload<S['select'][P]>>  :
        P extends 'project_likes'
        ? Array < project_likesGetPayload<S['select'][P]>>  :
        P extends 'projects'
        ? Array < projectsGetPayload<S['select'][P]>>  :
        P extends 'questions'
        ? Array < questionsGetPayload<S['select'][P]>>  :
        P extends 'recent_views_project'
        ? Array < recent_views_projectGetPayload<S['select'][P]>>  :
        P extends 'startups'
        ? Array < startupsGetPayload<S['select'][P]>>  :
        P extends 'startup_likes'
        ? Array < startup_likesGetPayload<S['select'][P]>>  :
        P extends 'users'
        ? Array < usersGetPayload<S['select'][P]>>  : never
  } 
    : companies
  : companies


  type companiesCountArgs = Merge<
    Omit<companiesFindManyArgs, 'select' | 'include'> & {
      select?: CompaniesCountAggregateInputType | true
    }
  >

  export interface companiesDelegate {
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companiesFindUniqueArgs>(
      args: SelectSubset<T, companiesFindUniqueArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>

    /**
     * Find the first Companies that matches the filter.
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companiesFindFirstArgs>(
      args?: SelectSubset<T, companiesFindFirstArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>

    /**
     * Find zero or more Companies that matches the filter.
     * @param {companiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends companiesFindManyArgs>(
      args?: SelectSubset<T, companiesFindManyArgs>
    ): CheckSelect<T, Promise<Array<companies>>, Promise<Array<companiesGetPayload<T>>>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
    **/
    create<T extends companiesCreateArgs>(
      args: SelectSubset<T, companiesCreateArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
    **/
    delete<T extends companiesDeleteArgs>(
      args: SelectSubset<T, companiesDeleteArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companiesUpdateArgs>(
      args: SelectSubset<T, companiesUpdateArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companiesDeleteManyArgs>(
      args?: SelectSubset<T, companiesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Companies.
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companiesUpdateManyArgs>(
      args: SelectSubset<T, companiesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
    **/
    upsert<T extends companiesUpsertArgs>(
      args: SelectSubset<T, companiesUpsertArgs>
    ): CheckSelect<T, Prisma__companiesClient<companies>, Prisma__companiesClient<companiesGetPayload<T>>>

    /**
     * Count the number of Companies.
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Promise<GetCompaniesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companiesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    company_types<T extends company_typesArgs = {}>(args?: Subset<T, company_typesArgs>): CheckSelect<T, Prisma__company_typesClient<company_types | null>, Prisma__company_typesClient<company_typesGetPayload<T> | null>>;

    applicants<T extends applicantsFindManyArgs = {}>(args?: Subset<T, applicantsFindManyArgs>): CheckSelect<T, Promise<Array<applicants>>, Promise<Array<applicantsGetPayload<T>>>>;

    company_documents<T extends company_documentsFindManyArgs = {}>(args?: Subset<T, company_documentsFindManyArgs>): CheckSelect<T, Promise<Array<company_documents>>, Promise<Array<company_documentsGetPayload<T>>>>;

    company_members<T extends company_membersFindManyArgs = {}>(args?: Subset<T, company_membersFindManyArgs>): CheckSelect<T, Promise<Array<company_members>>, Promise<Array<company_membersGetPayload<T>>>>;

    company_news<T extends company_newsFindManyArgs = {}>(args?: Subset<T, company_newsFindManyArgs>): CheckSelect<T, Promise<Array<company_news>>, Promise<Array<company_newsGetPayload<T>>>>;

    demodays<T extends demodaysFindManyArgs = {}>(args?: Subset<T, demodaysFindManyArgs>): CheckSelect<T, Promise<Array<demodays>>, Promise<Array<demodaysGetPayload<T>>>>;

    IR_requests<T extends IR_requestsFindManyArgs = {}>(args?: Subset<T, IR_requestsFindManyArgs>): CheckSelect<T, Promise<Array<IR_requests>>, Promise<Array<IR_requestsGetPayload<T>>>>;

    participants<T extends participantsFindManyArgs = {}>(args?: Subset<T, participantsFindManyArgs>): CheckSelect<T, Promise<Array<participants>>, Promise<Array<participantsGetPayload<T>>>>;

    partners<T extends partnersFindManyArgs = {}>(args?: Subset<T, partnersFindManyArgs>): CheckSelect<T, Promise<Array<partners>>, Promise<Array<partnersGetPayload<T>>>>;

    partner_likes<T extends partner_likesFindManyArgs = {}>(args?: Subset<T, partner_likesFindManyArgs>): CheckSelect<T, Promise<Array<partner_likes>>, Promise<Array<partner_likesGetPayload<T>>>>;

    project_likes<T extends project_likesFindManyArgs = {}>(args?: Subset<T, project_likesFindManyArgs>): CheckSelect<T, Promise<Array<project_likes>>, Promise<Array<project_likesGetPayload<T>>>>;

    projects<T extends projectsFindManyArgs = {}>(args?: Subset<T, projectsFindManyArgs>): CheckSelect<T, Promise<Array<projects>>, Promise<Array<projectsGetPayload<T>>>>;

    questions<T extends questionsFindManyArgs = {}>(args?: Subset<T, questionsFindManyArgs>): CheckSelect<T, Promise<Array<questions>>, Promise<Array<questionsGetPayload<T>>>>;

    recent_views_project<T extends recent_views_projectFindManyArgs = {}>(args?: Subset<T, recent_views_projectFindManyArgs>): CheckSelect<T, Promise<Array<recent_views_project>>, Promise<Array<recent_views_projectGetPayload<T>>>>;

    startups<T extends startupsFindManyArgs = {}>(args?: Subset<T, startupsFindManyArgs>): CheckSelect<T, Promise<Array<startups>>, Promise<Array<startupsGetPayload<T>>>>;

    startup_likes<T extends startup_likesFindManyArgs = {}>(args?: Subset<T, startup_likesFindManyArgs>): CheckSelect<T, Promise<Array<startup_likes>>, Promise<Array<startup_likesGetPayload<T>>>>;

    users<T extends usersFindManyArgs = {}>(args?: Subset<T, usersFindManyArgs>): CheckSelect<T, Promise<Array<users>>, Promise<Array<usersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the companies
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companiesInclude | null
    /**
     * Throw an Error if a companies can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companies to fetch.
    **/
    where: companiesWhereUniqueInput
  }


  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the companies
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companiesInclude | null
    /**
     * Throw an Error if a companies can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companies to fetch.
    **/
    where?: companiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of companies to fetch.
    **/
    orderBy?: Enumerable<companiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
    **/
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of companies.
    **/
    distinct?: Enumerable<CompaniesScalarFieldEnum>
  }


  /**
   * companies findMany
   */
  export type companiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the companies
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companiesInclude | null
    /**
     * Filter, which companies to fetch.
    **/
    where?: companiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of companies to fetch.
    **/
    orderBy?: Enumerable<companiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
    **/
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
    **/
    skip?: number
    distinct?: Enumerable<CompaniesScalarFieldEnum>
  }


  /**
   * companies create
   */
  export type companiesCreateArgs = {
    /**
     * Select specific fields to fetch from the companies
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companiesInclude | null
    /**
     * The data needed to create a companies.
    **/
    data: XOR<companiesUncheckedCreateInput, companiesCreateInput>
  }


  /**
   * companies update
   */
  export type companiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the companies
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companiesInclude | null
    /**
     * The data needed to update a companies.
    **/
    data: XOR<companiesUncheckedUpdateInput, companiesUpdateInput>
    /**
     * Choose, which companies to update.
    **/
    where: companiesWhereUniqueInput
  }


  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs = {
    data: XOR<companiesUncheckedUpdateManyInput, companiesUpdateManyMutationInput>
    where?: companiesWhereInput
  }


  /**
   * companies upsert
   */
  export type companiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the companies
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companiesInclude | null
    /**
     * The filter to search for the companies to update in case it exists.
    **/
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
    **/
    create: XOR<companiesUncheckedCreateInput, companiesCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<companiesUncheckedUpdateInput, companiesUpdateInput>
  }


  /**
   * companies delete
   */
  export type companiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the companies
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companiesInclude | null
    /**
     * Filter which companies to delete.
    **/
    where: companiesWhereUniqueInput
  }


  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs = {
    where?: companiesWhereInput
  }


  /**
   * companies without action
   */
  export type companiesArgs = {
    /**
     * Select specific fields to fetch from the companies
    **/
    select?: companiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: companiesInclude | null
  }



  /**
   * Model company_documents
   */


  export type AggregateCompany_documents = {
    count: Company_documentsCountAggregateOutputType | null
    avg: Company_documentsAvgAggregateOutputType | null
    sum: Company_documentsSumAggregateOutputType | null
    min: Company_documentsMinAggregateOutputType | null
    max: Company_documentsMaxAggregateOutputType | null
  }

  export type Company_documentsAvgAggregateOutputType = {
    id: number
    company_id: number
    type_id: number
  }

  export type Company_documentsSumAggregateOutputType = {
    id: number
    company_id: number
    type_id: number
  }

  export type Company_documentsMinAggregateOutputType = {
    id: number
    company_id: number
    doc_url: string | null
    type_id: number
    name: string | null
    file_type: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Company_documentsMaxAggregateOutputType = {
    id: number
    company_id: number
    doc_url: string | null
    type_id: number
    name: string | null
    file_type: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type Company_documentsCountAggregateOutputType = {
    id: number
    company_id: number
    doc_url: number | null
    type_id: number
    name: number | null
    file_type: number | null
    created_at: number | null
    updated_at: number | null
    deleted_at: number | null
    _all: number
  }


  export type Company_documentsAvgAggregateInputType = {
    id?: true
    company_id?: true
    type_id?: true
  }

  export type Company_documentsSumAggregateInputType = {
    id?: true
    company_id?: true
    type_id?: true
  }

  export type Company_documentsMinAggregateInputType = {
    id?: true
    company_id?: true
    doc_url?: true
    type_id?: true
    name?: true
    file_type?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Company_documentsMaxAggregateInputType = {
    id?: true
    company_id?: true
    doc_url?: true
    type_id?: true
    name?: true
    file_type?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type Company_documentsCountAggregateInputType = {
    id?: true
    company_id?: true
    doc_url?: true
    type_id?: true
    name?: true
    file_type?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type Company_documentsAggregateArgs = {
    /**
     * Filter which company_documents to aggregate.
    **/
    where?: company_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_documents to fetch.
    **/
    orderBy?: Enumerable<company_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: company_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_documents.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_documents
    **/
    count?: true | Company_documentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Company_documentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Company_documentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Company_documentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Company_documentsMaxAggregateInputType
  }

  export type GetCompany_documentsAggregateType<T extends Company_documentsAggregateArgs> = {
    [P in keyof T & keyof AggregateCompany_documents]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_documents[P]>
      : GetScalarType<T[P], AggregateCompany_documents[P]>
  }



  export type company_documentsSelect = {
    id?: boolean
    company_id?: boolean
    doc_url?: boolean
    type_id?: boolean
    name?: boolean
    file_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    companies?: boolean | companiesArgs
    document_types?: boolean | document_typesArgs
    IR_requests?: boolean | IR_requestsFindManyArgs
    applicant_documents?: boolean | applicant_documentsFindManyArgs
  }

  export type company_documentsInclude = {
    companies?: boolean | companiesArgs
    document_types?: boolean | document_typesArgs
    IR_requests?: boolean | IR_requestsFindManyArgs
    applicant_documents?: boolean | applicant_documentsFindManyArgs
  }

  export type company_documentsGetPayload<
    S extends boolean | null | undefined | company_documentsArgs,
    U = keyof S
      > = S extends true
        ? company_documents
    : S extends undefined
    ? never
    : S extends company_documentsArgs | company_documentsFindManyArgs
    ?'include' extends U
    ? company_documents  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'document_types'
        ? document_typesGetPayload<S['include'][P]> :
        P extends 'IR_requests'
        ? Array < IR_requestsGetPayload<S['include'][P]>>  :
        P extends 'applicant_documents'
        ? Array < applicant_documentsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof company_documents ?company_documents [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'document_types'
        ? document_typesGetPayload<S['select'][P]> :
        P extends 'IR_requests'
        ? Array < IR_requestsGetPayload<S['select'][P]>>  :
        P extends 'applicant_documents'
        ? Array < applicant_documentsGetPayload<S['select'][P]>>  : never
  } 
    : company_documents
  : company_documents


  type company_documentsCountArgs = Merge<
    Omit<company_documentsFindManyArgs, 'select' | 'include'> & {
      select?: Company_documentsCountAggregateInputType | true
    }
  >

  export interface company_documentsDelegate {
    /**
     * Find zero or one Company_documents that matches the filter.
     * @param {company_documentsFindUniqueArgs} args - Arguments to find a Company_documents
     * @example
     * // Get one Company_documents
     * const company_documents = await prisma.company_documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends company_documentsFindUniqueArgs>(
      args: SelectSubset<T, company_documentsFindUniqueArgs>
    ): CheckSelect<T, Prisma__company_documentsClient<company_documents | null>, Prisma__company_documentsClient<company_documentsGetPayload<T> | null>>

    /**
     * Find the first Company_documents that matches the filter.
     * @param {company_documentsFindFirstArgs} args - Arguments to find a Company_documents
     * @example
     * // Get one Company_documents
     * const company_documents = await prisma.company_documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends company_documentsFindFirstArgs>(
      args?: SelectSubset<T, company_documentsFindFirstArgs>
    ): CheckSelect<T, Prisma__company_documentsClient<company_documents | null>, Prisma__company_documentsClient<company_documentsGetPayload<T> | null>>

    /**
     * Find zero or more Company_documents that matches the filter.
     * @param {company_documentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_documents
     * const company_documents = await prisma.company_documents.findMany()
     * 
     * // Get first 10 Company_documents
     * const company_documents = await prisma.company_documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_documentsWithIdOnly = await prisma.company_documents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends company_documentsFindManyArgs>(
      args?: SelectSubset<T, company_documentsFindManyArgs>
    ): CheckSelect<T, Promise<Array<company_documents>>, Promise<Array<company_documentsGetPayload<T>>>>

    /**
     * Create a Company_documents.
     * @param {company_documentsCreateArgs} args - Arguments to create a Company_documents.
     * @example
     * // Create one Company_documents
     * const Company_documents = await prisma.company_documents.create({
     *   data: {
     *     // ... data to create a Company_documents
     *   }
     * })
     * 
    **/
    create<T extends company_documentsCreateArgs>(
      args: SelectSubset<T, company_documentsCreateArgs>
    ): CheckSelect<T, Prisma__company_documentsClient<company_documents>, Prisma__company_documentsClient<company_documentsGetPayload<T>>>

    /**
     * Delete a Company_documents.
     * @param {company_documentsDeleteArgs} args - Arguments to delete one Company_documents.
     * @example
     * // Delete one Company_documents
     * const Company_documents = await prisma.company_documents.delete({
     *   where: {
     *     // ... filter to delete one Company_documents
     *   }
     * })
     * 
    **/
    delete<T extends company_documentsDeleteArgs>(
      args: SelectSubset<T, company_documentsDeleteArgs>
    ): CheckSelect<T, Prisma__company_documentsClient<company_documents>, Prisma__company_documentsClient<company_documentsGetPayload<T>>>

    /**
     * Update one Company_documents.
     * @param {company_documentsUpdateArgs} args - Arguments to update one Company_documents.
     * @example
     * // Update one Company_documents
     * const company_documents = await prisma.company_documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends company_documentsUpdateArgs>(
      args: SelectSubset<T, company_documentsUpdateArgs>
    ): CheckSelect<T, Prisma__company_documentsClient<company_documents>, Prisma__company_documentsClient<company_documentsGetPayload<T>>>

    /**
     * Delete zero or more Company_documents.
     * @param {company_documentsDeleteManyArgs} args - Arguments to filter Company_documents to delete.
     * @example
     * // Delete a few Company_documents
     * const { count } = await prisma.company_documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends company_documentsDeleteManyArgs>(
      args?: SelectSubset<T, company_documentsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Company_documents.
     * @param {company_documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_documents
     * const company_documents = await prisma.company_documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends company_documentsUpdateManyArgs>(
      args: SelectSubset<T, company_documentsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Company_documents.
     * @param {company_documentsUpsertArgs} args - Arguments to update or create a Company_documents.
     * @example
     * // Update or create a Company_documents
     * const company_documents = await prisma.company_documents.upsert({
     *   create: {
     *     // ... data to create a Company_documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_documents we want to update
     *   }
     * })
    **/
    upsert<T extends company_documentsUpsertArgs>(
      args: SelectSubset<T, company_documentsUpsertArgs>
    ): CheckSelect<T, Prisma__company_documentsClient<company_documents>, Prisma__company_documentsClient<company_documentsGetPayload<T>>>

    /**
     * Count the number of Company_documents.
     * @param {company_documentsCountArgs} args - Arguments to filter Company_documents to count.
     * @example
     * // Count the number of Company_documents
     * const count = await prisma.company_documents.count({
     *   where: {
     *     // ... the filter for the Company_documents we want to count
     *   }
     * })
    **/
    count<T extends company_documentsCountArgs>(
      args?: Subset<T, company_documentsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_documentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_documents.
     * @param {Company_documentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_documentsAggregateArgs>(args: Subset<T, Company_documentsAggregateArgs>): Promise<GetCompany_documentsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for company_documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__company_documentsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    document_types<T extends document_typesArgs = {}>(args?: Subset<T, document_typesArgs>): CheckSelect<T, Prisma__document_typesClient<document_types | null>, Prisma__document_typesClient<document_typesGetPayload<T> | null>>;

    IR_requests<T extends IR_requestsFindManyArgs = {}>(args?: Subset<T, IR_requestsFindManyArgs>): CheckSelect<T, Promise<Array<IR_requests>>, Promise<Array<IR_requestsGetPayload<T>>>>;

    applicant_documents<T extends applicant_documentsFindManyArgs = {}>(args?: Subset<T, applicant_documentsFindManyArgs>): CheckSelect<T, Promise<Array<applicant_documents>>, Promise<Array<applicant_documentsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * company_documents findUnique
   */
  export type company_documentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the company_documents
    **/
    select?: company_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_documentsInclude | null
    /**
     * Throw an Error if a company_documents can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company_documents to fetch.
    **/
    where: company_documentsWhereUniqueInput
  }


  /**
   * company_documents findFirst
   */
  export type company_documentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the company_documents
    **/
    select?: company_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_documentsInclude | null
    /**
     * Throw an Error if a company_documents can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company_documents to fetch.
    **/
    where?: company_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_documents to fetch.
    **/
    orderBy?: Enumerable<company_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_documents.
    **/
    cursor?: company_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_documents.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of company_documents.
    **/
    distinct?: Enumerable<Company_documentsScalarFieldEnum>
  }


  /**
   * company_documents findMany
   */
  export type company_documentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the company_documents
    **/
    select?: company_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_documentsInclude | null
    /**
     * Filter, which company_documents to fetch.
    **/
    where?: company_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_documents to fetch.
    **/
    orderBy?: Enumerable<company_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_documents.
    **/
    cursor?: company_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_documents.
    **/
    skip?: number
    distinct?: Enumerable<Company_documentsScalarFieldEnum>
  }


  /**
   * company_documents create
   */
  export type company_documentsCreateArgs = {
    /**
     * Select specific fields to fetch from the company_documents
    **/
    select?: company_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_documentsInclude | null
    /**
     * The data needed to create a company_documents.
    **/
    data: XOR<company_documentsUncheckedCreateInput, company_documentsCreateInput>
  }


  /**
   * company_documents update
   */
  export type company_documentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the company_documents
    **/
    select?: company_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_documentsInclude | null
    /**
     * The data needed to update a company_documents.
    **/
    data: XOR<company_documentsUncheckedUpdateInput, company_documentsUpdateInput>
    /**
     * Choose, which company_documents to update.
    **/
    where: company_documentsWhereUniqueInput
  }


  /**
   * company_documents updateMany
   */
  export type company_documentsUpdateManyArgs = {
    data: XOR<company_documentsUncheckedUpdateManyInput, company_documentsUpdateManyMutationInput>
    where?: company_documentsWhereInput
  }


  /**
   * company_documents upsert
   */
  export type company_documentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the company_documents
    **/
    select?: company_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_documentsInclude | null
    /**
     * The filter to search for the company_documents to update in case it exists.
    **/
    where: company_documentsWhereUniqueInput
    /**
     * In case the company_documents found by the `where` argument doesn't exist, create a new company_documents with this data.
    **/
    create: XOR<company_documentsUncheckedCreateInput, company_documentsCreateInput>
    /**
     * In case the company_documents was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<company_documentsUncheckedUpdateInput, company_documentsUpdateInput>
  }


  /**
   * company_documents delete
   */
  export type company_documentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the company_documents
    **/
    select?: company_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_documentsInclude | null
    /**
     * Filter which company_documents to delete.
    **/
    where: company_documentsWhereUniqueInput
  }


  /**
   * company_documents deleteMany
   */
  export type company_documentsDeleteManyArgs = {
    where?: company_documentsWhereInput
  }


  /**
   * company_documents without action
   */
  export type company_documentsArgs = {
    /**
     * Select specific fields to fetch from the company_documents
    **/
    select?: company_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_documentsInclude | null
  }



  /**
   * Model company_members
   */


  export type AggregateCompany_members = {
    count: Company_membersCountAggregateOutputType | null
    avg: Company_membersAvgAggregateOutputType | null
    sum: Company_membersSumAggregateOutputType | null
    min: Company_membersMinAggregateOutputType | null
    max: Company_membersMaxAggregateOutputType | null
  }

  export type Company_membersAvgAggregateOutputType = {
    id: number
    company_id: number | null
  }

  export type Company_membersSumAggregateOutputType = {
    id: number
    company_id: number | null
  }

  export type Company_membersMinAggregateOutputType = {
    id: number
    company_id: number | null
    name: string | null
    img: string | null
    position: string | null
  }

  export type Company_membersMaxAggregateOutputType = {
    id: number
    company_id: number | null
    name: string | null
    img: string | null
    position: string | null
  }

  export type Company_membersCountAggregateOutputType = {
    id: number
    company_id: number | null
    name: number | null
    img: number | null
    position: number | null
    _all: number
  }


  export type Company_membersAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_membersSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_membersMinAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    img?: true
    position?: true
  }

  export type Company_membersMaxAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    img?: true
    position?: true
  }

  export type Company_membersCountAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    img?: true
    position?: true
    _all?: true
  }

  export type Company_membersAggregateArgs = {
    /**
     * Filter which company_members to aggregate.
    **/
    where?: company_membersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_members to fetch.
    **/
    orderBy?: Enumerable<company_membersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: company_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_members from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_members.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_members
    **/
    count?: true | Company_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Company_membersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Company_membersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Company_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Company_membersMaxAggregateInputType
  }

  export type GetCompany_membersAggregateType<T extends Company_membersAggregateArgs> = {
    [P in keyof T & keyof AggregateCompany_members]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_members[P]>
      : GetScalarType<T[P], AggregateCompany_members[P]>
  }



  export type company_membersSelect = {
    id?: boolean
    company_id?: boolean
    name?: boolean
    img?: boolean
    position?: boolean
    companies?: boolean | companiesArgs
  }

  export type company_membersInclude = {
    companies?: boolean | companiesArgs
  }

  export type company_membersGetPayload<
    S extends boolean | null | undefined | company_membersArgs,
    U = keyof S
      > = S extends true
        ? company_members
    : S extends undefined
    ? never
    : S extends company_membersArgs | company_membersFindManyArgs
    ?'include' extends U
    ? company_members  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof company_members ?company_members [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> | null : never
  } 
    : company_members
  : company_members


  type company_membersCountArgs = Merge<
    Omit<company_membersFindManyArgs, 'select' | 'include'> & {
      select?: Company_membersCountAggregateInputType | true
    }
  >

  export interface company_membersDelegate {
    /**
     * Find zero or one Company_members that matches the filter.
     * @param {company_membersFindUniqueArgs} args - Arguments to find a Company_members
     * @example
     * // Get one Company_members
     * const company_members = await prisma.company_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends company_membersFindUniqueArgs>(
      args: SelectSubset<T, company_membersFindUniqueArgs>
    ): CheckSelect<T, Prisma__company_membersClient<company_members | null>, Prisma__company_membersClient<company_membersGetPayload<T> | null>>

    /**
     * Find the first Company_members that matches the filter.
     * @param {company_membersFindFirstArgs} args - Arguments to find a Company_members
     * @example
     * // Get one Company_members
     * const company_members = await prisma.company_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends company_membersFindFirstArgs>(
      args?: SelectSubset<T, company_membersFindFirstArgs>
    ): CheckSelect<T, Prisma__company_membersClient<company_members | null>, Prisma__company_membersClient<company_membersGetPayload<T> | null>>

    /**
     * Find zero or more Company_members that matches the filter.
     * @param {company_membersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_members
     * const company_members = await prisma.company_members.findMany()
     * 
     * // Get first 10 Company_members
     * const company_members = await prisma.company_members.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_membersWithIdOnly = await prisma.company_members.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends company_membersFindManyArgs>(
      args?: SelectSubset<T, company_membersFindManyArgs>
    ): CheckSelect<T, Promise<Array<company_members>>, Promise<Array<company_membersGetPayload<T>>>>

    /**
     * Create a Company_members.
     * @param {company_membersCreateArgs} args - Arguments to create a Company_members.
     * @example
     * // Create one Company_members
     * const Company_members = await prisma.company_members.create({
     *   data: {
     *     // ... data to create a Company_members
     *   }
     * })
     * 
    **/
    create<T extends company_membersCreateArgs>(
      args: SelectSubset<T, company_membersCreateArgs>
    ): CheckSelect<T, Prisma__company_membersClient<company_members>, Prisma__company_membersClient<company_membersGetPayload<T>>>

    /**
     * Delete a Company_members.
     * @param {company_membersDeleteArgs} args - Arguments to delete one Company_members.
     * @example
     * // Delete one Company_members
     * const Company_members = await prisma.company_members.delete({
     *   where: {
     *     // ... filter to delete one Company_members
     *   }
     * })
     * 
    **/
    delete<T extends company_membersDeleteArgs>(
      args: SelectSubset<T, company_membersDeleteArgs>
    ): CheckSelect<T, Prisma__company_membersClient<company_members>, Prisma__company_membersClient<company_membersGetPayload<T>>>

    /**
     * Update one Company_members.
     * @param {company_membersUpdateArgs} args - Arguments to update one Company_members.
     * @example
     * // Update one Company_members
     * const company_members = await prisma.company_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends company_membersUpdateArgs>(
      args: SelectSubset<T, company_membersUpdateArgs>
    ): CheckSelect<T, Prisma__company_membersClient<company_members>, Prisma__company_membersClient<company_membersGetPayload<T>>>

    /**
     * Delete zero or more Company_members.
     * @param {company_membersDeleteManyArgs} args - Arguments to filter Company_members to delete.
     * @example
     * // Delete a few Company_members
     * const { count } = await prisma.company_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends company_membersDeleteManyArgs>(
      args?: SelectSubset<T, company_membersDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Company_members.
     * @param {company_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_members
     * const company_members = await prisma.company_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends company_membersUpdateManyArgs>(
      args: SelectSubset<T, company_membersUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Company_members.
     * @param {company_membersUpsertArgs} args - Arguments to update or create a Company_members.
     * @example
     * // Update or create a Company_members
     * const company_members = await prisma.company_members.upsert({
     *   create: {
     *     // ... data to create a Company_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_members we want to update
     *   }
     * })
    **/
    upsert<T extends company_membersUpsertArgs>(
      args: SelectSubset<T, company_membersUpsertArgs>
    ): CheckSelect<T, Prisma__company_membersClient<company_members>, Prisma__company_membersClient<company_membersGetPayload<T>>>

    /**
     * Count the number of Company_members.
     * @param {company_membersCountArgs} args - Arguments to filter Company_members to count.
     * @example
     * // Count the number of Company_members
     * const count = await prisma.company_members.count({
     *   where: {
     *     // ... the filter for the Company_members we want to count
     *   }
     * })
    **/
    count<T extends company_membersCountArgs>(
      args?: Subset<T, company_membersCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_members.
     * @param {Company_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_membersAggregateArgs>(args: Subset<T, Company_membersAggregateArgs>): Promise<GetCompany_membersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for company_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__company_membersClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * company_members findUnique
   */
  export type company_membersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the company_members
    **/
    select?: company_membersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_membersInclude | null
    /**
     * Throw an Error if a company_members can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company_members to fetch.
    **/
    where: company_membersWhereUniqueInput
  }


  /**
   * company_members findFirst
   */
  export type company_membersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the company_members
    **/
    select?: company_membersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_membersInclude | null
    /**
     * Throw an Error if a company_members can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company_members to fetch.
    **/
    where?: company_membersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_members to fetch.
    **/
    orderBy?: Enumerable<company_membersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_members.
    **/
    cursor?: company_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_members from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_members.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of company_members.
    **/
    distinct?: Enumerable<Company_membersScalarFieldEnum>
  }


  /**
   * company_members findMany
   */
  export type company_membersFindManyArgs = {
    /**
     * Select specific fields to fetch from the company_members
    **/
    select?: company_membersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_membersInclude | null
    /**
     * Filter, which company_members to fetch.
    **/
    where?: company_membersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_members to fetch.
    **/
    orderBy?: Enumerable<company_membersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_members.
    **/
    cursor?: company_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_members from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_members.
    **/
    skip?: number
    distinct?: Enumerable<Company_membersScalarFieldEnum>
  }


  /**
   * company_members create
   */
  export type company_membersCreateArgs = {
    /**
     * Select specific fields to fetch from the company_members
    **/
    select?: company_membersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_membersInclude | null
    /**
     * The data needed to create a company_members.
    **/
    data: XOR<company_membersUncheckedCreateInput, company_membersCreateInput>
  }


  /**
   * company_members update
   */
  export type company_membersUpdateArgs = {
    /**
     * Select specific fields to fetch from the company_members
    **/
    select?: company_membersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_membersInclude | null
    /**
     * The data needed to update a company_members.
    **/
    data: XOR<company_membersUncheckedUpdateInput, company_membersUpdateInput>
    /**
     * Choose, which company_members to update.
    **/
    where: company_membersWhereUniqueInput
  }


  /**
   * company_members updateMany
   */
  export type company_membersUpdateManyArgs = {
    data: XOR<company_membersUncheckedUpdateManyInput, company_membersUpdateManyMutationInput>
    where?: company_membersWhereInput
  }


  /**
   * company_members upsert
   */
  export type company_membersUpsertArgs = {
    /**
     * Select specific fields to fetch from the company_members
    **/
    select?: company_membersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_membersInclude | null
    /**
     * The filter to search for the company_members to update in case it exists.
    **/
    where: company_membersWhereUniqueInput
    /**
     * In case the company_members found by the `where` argument doesn't exist, create a new company_members with this data.
    **/
    create: XOR<company_membersUncheckedCreateInput, company_membersCreateInput>
    /**
     * In case the company_members was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<company_membersUncheckedUpdateInput, company_membersUpdateInput>
  }


  /**
   * company_members delete
   */
  export type company_membersDeleteArgs = {
    /**
     * Select specific fields to fetch from the company_members
    **/
    select?: company_membersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_membersInclude | null
    /**
     * Filter which company_members to delete.
    **/
    where: company_membersWhereUniqueInput
  }


  /**
   * company_members deleteMany
   */
  export type company_membersDeleteManyArgs = {
    where?: company_membersWhereInput
  }


  /**
   * company_members without action
   */
  export type company_membersArgs = {
    /**
     * Select specific fields to fetch from the company_members
    **/
    select?: company_membersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_membersInclude | null
  }



  /**
   * Model company_news
   */


  export type AggregateCompany_news = {
    count: Company_newsCountAggregateOutputType | null
    avg: Company_newsAvgAggregateOutputType | null
    sum: Company_newsSumAggregateOutputType | null
    min: Company_newsMinAggregateOutputType | null
    max: Company_newsMaxAggregateOutputType | null
  }

  export type Company_newsAvgAggregateOutputType = {
    id: number
    company_id: number
  }

  export type Company_newsSumAggregateOutputType = {
    id: number
    company_id: number
  }

  export type Company_newsMinAggregateOutputType = {
    id: number
    company_id: number
    URL: string | null
  }

  export type Company_newsMaxAggregateOutputType = {
    id: number
    company_id: number
    URL: string | null
  }

  export type Company_newsCountAggregateOutputType = {
    id: number
    company_id: number
    URL: number | null
    _all: number
  }


  export type Company_newsAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_newsSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_newsMinAggregateInputType = {
    id?: true
    company_id?: true
    URL?: true
  }

  export type Company_newsMaxAggregateInputType = {
    id?: true
    company_id?: true
    URL?: true
  }

  export type Company_newsCountAggregateInputType = {
    id?: true
    company_id?: true
    URL?: true
    _all?: true
  }

  export type Company_newsAggregateArgs = {
    /**
     * Filter which company_news to aggregate.
    **/
    where?: company_newsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_news to fetch.
    **/
    orderBy?: Enumerable<company_newsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: company_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_news from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_news.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_news
    **/
    count?: true | Company_newsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Company_newsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Company_newsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Company_newsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Company_newsMaxAggregateInputType
  }

  export type GetCompany_newsAggregateType<T extends Company_newsAggregateArgs> = {
    [P in keyof T & keyof AggregateCompany_news]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_news[P]>
      : GetScalarType<T[P], AggregateCompany_news[P]>
  }



  export type company_newsSelect = {
    id?: boolean
    company_id?: boolean
    URL?: boolean
    companies?: boolean | companiesArgs
  }

  export type company_newsInclude = {
    companies?: boolean | companiesArgs
  }

  export type company_newsGetPayload<
    S extends boolean | null | undefined | company_newsArgs,
    U = keyof S
      > = S extends true
        ? company_news
    : S extends undefined
    ? never
    : S extends company_newsArgs | company_newsFindManyArgs
    ?'include' extends U
    ? company_news  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof company_news ?company_news [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> : never
  } 
    : company_news
  : company_news


  type company_newsCountArgs = Merge<
    Omit<company_newsFindManyArgs, 'select' | 'include'> & {
      select?: Company_newsCountAggregateInputType | true
    }
  >

  export interface company_newsDelegate {
    /**
     * Find zero or one Company_news that matches the filter.
     * @param {company_newsFindUniqueArgs} args - Arguments to find a Company_news
     * @example
     * // Get one Company_news
     * const company_news = await prisma.company_news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends company_newsFindUniqueArgs>(
      args: SelectSubset<T, company_newsFindUniqueArgs>
    ): CheckSelect<T, Prisma__company_newsClient<company_news | null>, Prisma__company_newsClient<company_newsGetPayload<T> | null>>

    /**
     * Find the first Company_news that matches the filter.
     * @param {company_newsFindFirstArgs} args - Arguments to find a Company_news
     * @example
     * // Get one Company_news
     * const company_news = await prisma.company_news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends company_newsFindFirstArgs>(
      args?: SelectSubset<T, company_newsFindFirstArgs>
    ): CheckSelect<T, Prisma__company_newsClient<company_news | null>, Prisma__company_newsClient<company_newsGetPayload<T> | null>>

    /**
     * Find zero or more Company_news that matches the filter.
     * @param {company_newsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_news
     * const company_news = await prisma.company_news.findMany()
     * 
     * // Get first 10 Company_news
     * const company_news = await prisma.company_news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_newsWithIdOnly = await prisma.company_news.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends company_newsFindManyArgs>(
      args?: SelectSubset<T, company_newsFindManyArgs>
    ): CheckSelect<T, Promise<Array<company_news>>, Promise<Array<company_newsGetPayload<T>>>>

    /**
     * Create a Company_news.
     * @param {company_newsCreateArgs} args - Arguments to create a Company_news.
     * @example
     * // Create one Company_news
     * const Company_news = await prisma.company_news.create({
     *   data: {
     *     // ... data to create a Company_news
     *   }
     * })
     * 
    **/
    create<T extends company_newsCreateArgs>(
      args: SelectSubset<T, company_newsCreateArgs>
    ): CheckSelect<T, Prisma__company_newsClient<company_news>, Prisma__company_newsClient<company_newsGetPayload<T>>>

    /**
     * Delete a Company_news.
     * @param {company_newsDeleteArgs} args - Arguments to delete one Company_news.
     * @example
     * // Delete one Company_news
     * const Company_news = await prisma.company_news.delete({
     *   where: {
     *     // ... filter to delete one Company_news
     *   }
     * })
     * 
    **/
    delete<T extends company_newsDeleteArgs>(
      args: SelectSubset<T, company_newsDeleteArgs>
    ): CheckSelect<T, Prisma__company_newsClient<company_news>, Prisma__company_newsClient<company_newsGetPayload<T>>>

    /**
     * Update one Company_news.
     * @param {company_newsUpdateArgs} args - Arguments to update one Company_news.
     * @example
     * // Update one Company_news
     * const company_news = await prisma.company_news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends company_newsUpdateArgs>(
      args: SelectSubset<T, company_newsUpdateArgs>
    ): CheckSelect<T, Prisma__company_newsClient<company_news>, Prisma__company_newsClient<company_newsGetPayload<T>>>

    /**
     * Delete zero or more Company_news.
     * @param {company_newsDeleteManyArgs} args - Arguments to filter Company_news to delete.
     * @example
     * // Delete a few Company_news
     * const { count } = await prisma.company_news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends company_newsDeleteManyArgs>(
      args?: SelectSubset<T, company_newsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Company_news.
     * @param {company_newsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_news
     * const company_news = await prisma.company_news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends company_newsUpdateManyArgs>(
      args: SelectSubset<T, company_newsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Company_news.
     * @param {company_newsUpsertArgs} args - Arguments to update or create a Company_news.
     * @example
     * // Update or create a Company_news
     * const company_news = await prisma.company_news.upsert({
     *   create: {
     *     // ... data to create a Company_news
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_news we want to update
     *   }
     * })
    **/
    upsert<T extends company_newsUpsertArgs>(
      args: SelectSubset<T, company_newsUpsertArgs>
    ): CheckSelect<T, Prisma__company_newsClient<company_news>, Prisma__company_newsClient<company_newsGetPayload<T>>>

    /**
     * Count the number of Company_news.
     * @param {company_newsCountArgs} args - Arguments to filter Company_news to count.
     * @example
     * // Count the number of Company_news
     * const count = await prisma.company_news.count({
     *   where: {
     *     // ... the filter for the Company_news we want to count
     *   }
     * })
    **/
    count<T extends company_newsCountArgs>(
      args?: Subset<T, company_newsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_newsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_news.
     * @param {Company_newsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_newsAggregateArgs>(args: Subset<T, Company_newsAggregateArgs>): Promise<GetCompany_newsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for company_news.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__company_newsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * company_news findUnique
   */
  export type company_newsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the company_news
    **/
    select?: company_newsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_newsInclude | null
    /**
     * Throw an Error if a company_news can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company_news to fetch.
    **/
    where: company_newsWhereUniqueInput
  }


  /**
   * company_news findFirst
   */
  export type company_newsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the company_news
    **/
    select?: company_newsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_newsInclude | null
    /**
     * Throw an Error if a company_news can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company_news to fetch.
    **/
    where?: company_newsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_news to fetch.
    **/
    orderBy?: Enumerable<company_newsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_news.
    **/
    cursor?: company_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_news from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_news.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of company_news.
    **/
    distinct?: Enumerable<Company_newsScalarFieldEnum>
  }


  /**
   * company_news findMany
   */
  export type company_newsFindManyArgs = {
    /**
     * Select specific fields to fetch from the company_news
    **/
    select?: company_newsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_newsInclude | null
    /**
     * Filter, which company_news to fetch.
    **/
    where?: company_newsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_news to fetch.
    **/
    orderBy?: Enumerable<company_newsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_news.
    **/
    cursor?: company_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_news from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_news.
    **/
    skip?: number
    distinct?: Enumerable<Company_newsScalarFieldEnum>
  }


  /**
   * company_news create
   */
  export type company_newsCreateArgs = {
    /**
     * Select specific fields to fetch from the company_news
    **/
    select?: company_newsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_newsInclude | null
    /**
     * The data needed to create a company_news.
    **/
    data: XOR<company_newsUncheckedCreateInput, company_newsCreateInput>
  }


  /**
   * company_news update
   */
  export type company_newsUpdateArgs = {
    /**
     * Select specific fields to fetch from the company_news
    **/
    select?: company_newsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_newsInclude | null
    /**
     * The data needed to update a company_news.
    **/
    data: XOR<company_newsUncheckedUpdateInput, company_newsUpdateInput>
    /**
     * Choose, which company_news to update.
    **/
    where: company_newsWhereUniqueInput
  }


  /**
   * company_news updateMany
   */
  export type company_newsUpdateManyArgs = {
    data: XOR<company_newsUncheckedUpdateManyInput, company_newsUpdateManyMutationInput>
    where?: company_newsWhereInput
  }


  /**
   * company_news upsert
   */
  export type company_newsUpsertArgs = {
    /**
     * Select specific fields to fetch from the company_news
    **/
    select?: company_newsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_newsInclude | null
    /**
     * The filter to search for the company_news to update in case it exists.
    **/
    where: company_newsWhereUniqueInput
    /**
     * In case the company_news found by the `where` argument doesn't exist, create a new company_news with this data.
    **/
    create: XOR<company_newsUncheckedCreateInput, company_newsCreateInput>
    /**
     * In case the company_news was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<company_newsUncheckedUpdateInput, company_newsUpdateInput>
  }


  /**
   * company_news delete
   */
  export type company_newsDeleteArgs = {
    /**
     * Select specific fields to fetch from the company_news
    **/
    select?: company_newsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_newsInclude | null
    /**
     * Filter which company_news to delete.
    **/
    where: company_newsWhereUniqueInput
  }


  /**
   * company_news deleteMany
   */
  export type company_newsDeleteManyArgs = {
    where?: company_newsWhereInput
  }


  /**
   * company_news without action
   */
  export type company_newsArgs = {
    /**
     * Select specific fields to fetch from the company_news
    **/
    select?: company_newsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_newsInclude | null
  }



  /**
   * Model company_types
   */


  export type AggregateCompany_types = {
    count: Company_typesCountAggregateOutputType | null
    avg: Company_typesAvgAggregateOutputType | null
    sum: Company_typesSumAggregateOutputType | null
    min: Company_typesMinAggregateOutputType | null
    max: Company_typesMaxAggregateOutputType | null
  }

  export type Company_typesAvgAggregateOutputType = {
    id: number
  }

  export type Company_typesSumAggregateOutputType = {
    id: number
  }

  export type Company_typesMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Company_typesMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Company_typesCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type Company_typesAvgAggregateInputType = {
    id?: true
  }

  export type Company_typesSumAggregateInputType = {
    id?: true
  }

  export type Company_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Company_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Company_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Company_typesAggregateArgs = {
    /**
     * Filter which company_types to aggregate.
    **/
    where?: company_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_types to fetch.
    **/
    orderBy?: Enumerable<company_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: company_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_types.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_types
    **/
    count?: true | Company_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Company_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Company_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Company_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Company_typesMaxAggregateInputType
  }

  export type GetCompany_typesAggregateType<T extends Company_typesAggregateArgs> = {
    [P in keyof T & keyof AggregateCompany_types]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_types[P]>
      : GetScalarType<T[P], AggregateCompany_types[P]>
  }



  export type company_typesSelect = {
    id?: boolean
    name?: boolean
    companies?: boolean | companiesFindManyArgs
  }

  export type company_typesInclude = {
    companies?: boolean | companiesFindManyArgs
  }

  export type company_typesGetPayload<
    S extends boolean | null | undefined | company_typesArgs,
    U = keyof S
      > = S extends true
        ? company_types
    : S extends undefined
    ? never
    : S extends company_typesArgs | company_typesFindManyArgs
    ?'include' extends U
    ? company_types  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? Array < companiesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof company_types ?company_types [P]
  : 
          P extends 'companies'
        ? Array < companiesGetPayload<S['select'][P]>>  : never
  } 
    : company_types
  : company_types


  type company_typesCountArgs = Merge<
    Omit<company_typesFindManyArgs, 'select' | 'include'> & {
      select?: Company_typesCountAggregateInputType | true
    }
  >

  export interface company_typesDelegate {
    /**
     * Find zero or one Company_types that matches the filter.
     * @param {company_typesFindUniqueArgs} args - Arguments to find a Company_types
     * @example
     * // Get one Company_types
     * const company_types = await prisma.company_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends company_typesFindUniqueArgs>(
      args: SelectSubset<T, company_typesFindUniqueArgs>
    ): CheckSelect<T, Prisma__company_typesClient<company_types | null>, Prisma__company_typesClient<company_typesGetPayload<T> | null>>

    /**
     * Find the first Company_types that matches the filter.
     * @param {company_typesFindFirstArgs} args - Arguments to find a Company_types
     * @example
     * // Get one Company_types
     * const company_types = await prisma.company_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends company_typesFindFirstArgs>(
      args?: SelectSubset<T, company_typesFindFirstArgs>
    ): CheckSelect<T, Prisma__company_typesClient<company_types | null>, Prisma__company_typesClient<company_typesGetPayload<T> | null>>

    /**
     * Find zero or more Company_types that matches the filter.
     * @param {company_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_types
     * const company_types = await prisma.company_types.findMany()
     * 
     * // Get first 10 Company_types
     * const company_types = await prisma.company_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_typesWithIdOnly = await prisma.company_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends company_typesFindManyArgs>(
      args?: SelectSubset<T, company_typesFindManyArgs>
    ): CheckSelect<T, Promise<Array<company_types>>, Promise<Array<company_typesGetPayload<T>>>>

    /**
     * Create a Company_types.
     * @param {company_typesCreateArgs} args - Arguments to create a Company_types.
     * @example
     * // Create one Company_types
     * const Company_types = await prisma.company_types.create({
     *   data: {
     *     // ... data to create a Company_types
     *   }
     * })
     * 
    **/
    create<T extends company_typesCreateArgs>(
      args: SelectSubset<T, company_typesCreateArgs>
    ): CheckSelect<T, Prisma__company_typesClient<company_types>, Prisma__company_typesClient<company_typesGetPayload<T>>>

    /**
     * Delete a Company_types.
     * @param {company_typesDeleteArgs} args - Arguments to delete one Company_types.
     * @example
     * // Delete one Company_types
     * const Company_types = await prisma.company_types.delete({
     *   where: {
     *     // ... filter to delete one Company_types
     *   }
     * })
     * 
    **/
    delete<T extends company_typesDeleteArgs>(
      args: SelectSubset<T, company_typesDeleteArgs>
    ): CheckSelect<T, Prisma__company_typesClient<company_types>, Prisma__company_typesClient<company_typesGetPayload<T>>>

    /**
     * Update one Company_types.
     * @param {company_typesUpdateArgs} args - Arguments to update one Company_types.
     * @example
     * // Update one Company_types
     * const company_types = await prisma.company_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends company_typesUpdateArgs>(
      args: SelectSubset<T, company_typesUpdateArgs>
    ): CheckSelect<T, Prisma__company_typesClient<company_types>, Prisma__company_typesClient<company_typesGetPayload<T>>>

    /**
     * Delete zero or more Company_types.
     * @param {company_typesDeleteManyArgs} args - Arguments to filter Company_types to delete.
     * @example
     * // Delete a few Company_types
     * const { count } = await prisma.company_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends company_typesDeleteManyArgs>(
      args?: SelectSubset<T, company_typesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Company_types.
     * @param {company_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_types
     * const company_types = await prisma.company_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends company_typesUpdateManyArgs>(
      args: SelectSubset<T, company_typesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Company_types.
     * @param {company_typesUpsertArgs} args - Arguments to update or create a Company_types.
     * @example
     * // Update or create a Company_types
     * const company_types = await prisma.company_types.upsert({
     *   create: {
     *     // ... data to create a Company_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_types we want to update
     *   }
     * })
    **/
    upsert<T extends company_typesUpsertArgs>(
      args: SelectSubset<T, company_typesUpsertArgs>
    ): CheckSelect<T, Prisma__company_typesClient<company_types>, Prisma__company_typesClient<company_typesGetPayload<T>>>

    /**
     * Count the number of Company_types.
     * @param {company_typesCountArgs} args - Arguments to filter Company_types to count.
     * @example
     * // Count the number of Company_types
     * const count = await prisma.company_types.count({
     *   where: {
     *     // ... the filter for the Company_types we want to count
     *   }
     * })
    **/
    count<T extends company_typesCountArgs>(
      args?: Subset<T, company_typesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_types.
     * @param {Company_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_typesAggregateArgs>(args: Subset<T, Company_typesAggregateArgs>): Promise<GetCompany_typesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for company_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__company_typesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesFindManyArgs = {}>(args?: Subset<T, companiesFindManyArgs>): CheckSelect<T, Promise<Array<companies>>, Promise<Array<companiesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * company_types findUnique
   */
  export type company_typesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the company_types
    **/
    select?: company_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_typesInclude | null
    /**
     * Throw an Error if a company_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company_types to fetch.
    **/
    where: company_typesWhereUniqueInput
  }


  /**
   * company_types findFirst
   */
  export type company_typesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the company_types
    **/
    select?: company_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_typesInclude | null
    /**
     * Throw an Error if a company_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which company_types to fetch.
    **/
    where?: company_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_types to fetch.
    **/
    orderBy?: Enumerable<company_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_types.
    **/
    cursor?: company_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_types.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of company_types.
    **/
    distinct?: Enumerable<Company_typesScalarFieldEnum>
  }


  /**
   * company_types findMany
   */
  export type company_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the company_types
    **/
    select?: company_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_typesInclude | null
    /**
     * Filter, which company_types to fetch.
    **/
    where?: company_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of company_types to fetch.
    **/
    orderBy?: Enumerable<company_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_types.
    **/
    cursor?: company_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_types.
    **/
    skip?: number
    distinct?: Enumerable<Company_typesScalarFieldEnum>
  }


  /**
   * company_types create
   */
  export type company_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the company_types
    **/
    select?: company_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_typesInclude | null
    /**
     * The data needed to create a company_types.
    **/
    data: XOR<company_typesUncheckedCreateInput, company_typesCreateInput>
  }


  /**
   * company_types update
   */
  export type company_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the company_types
    **/
    select?: company_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_typesInclude | null
    /**
     * The data needed to update a company_types.
    **/
    data: XOR<company_typesUncheckedUpdateInput, company_typesUpdateInput>
    /**
     * Choose, which company_types to update.
    **/
    where: company_typesWhereUniqueInput
  }


  /**
   * company_types updateMany
   */
  export type company_typesUpdateManyArgs = {
    data: XOR<company_typesUncheckedUpdateManyInput, company_typesUpdateManyMutationInput>
    where?: company_typesWhereInput
  }


  /**
   * company_types upsert
   */
  export type company_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the company_types
    **/
    select?: company_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_typesInclude | null
    /**
     * The filter to search for the company_types to update in case it exists.
    **/
    where: company_typesWhereUniqueInput
    /**
     * In case the company_types found by the `where` argument doesn't exist, create a new company_types with this data.
    **/
    create: XOR<company_typesUncheckedCreateInput, company_typesCreateInput>
    /**
     * In case the company_types was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<company_typesUncheckedUpdateInput, company_typesUpdateInput>
  }


  /**
   * company_types delete
   */
  export type company_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the company_types
    **/
    select?: company_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_typesInclude | null
    /**
     * Filter which company_types to delete.
    **/
    where: company_typesWhereUniqueInput
  }


  /**
   * company_types deleteMany
   */
  export type company_typesDeleteManyArgs = {
    where?: company_typesWhereInput
  }


  /**
   * company_types without action
   */
  export type company_typesArgs = {
    /**
     * Select specific fields to fetch from the company_types
    **/
    select?: company_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: company_typesInclude | null
  }



  /**
   * Model demodays
   */


  export type AggregateDemodays = {
    count: DemodaysCountAggregateOutputType | null
    avg: DemodaysAvgAggregateOutputType | null
    sum: DemodaysSumAggregateOutputType | null
    min: DemodaysMinAggregateOutputType | null
    max: DemodaysMaxAggregateOutputType | null
  }

  export type DemodaysAvgAggregateOutputType = {
    id: number
    company_id: number | null
  }

  export type DemodaysSumAggregateOutputType = {
    id: number
    company_id: number | null
  }

  export type DemodaysMinAggregateOutputType = {
    id: number
    name: string | null
    company_id: number | null
    streaming_url: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type DemodaysMaxAggregateOutputType = {
    id: number
    name: string | null
    company_id: number | null
    streaming_url: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type DemodaysCountAggregateOutputType = {
    id: number
    name: number | null
    company_id: number | null
    streaming_url: number | null
    created_at: number | null
    updated_at: number | null
    deleted_at: number | null
    _all: number
  }


  export type DemodaysAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type DemodaysSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type DemodaysMinAggregateInputType = {
    id?: true
    name?: true
    company_id?: true
    streaming_url?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type DemodaysMaxAggregateInputType = {
    id?: true
    name?: true
    company_id?: true
    streaming_url?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type DemodaysCountAggregateInputType = {
    id?: true
    name?: true
    company_id?: true
    streaming_url?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type DemodaysAggregateArgs = {
    /**
     * Filter which demodays to aggregate.
    **/
    where?: demodaysWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of demodays to fetch.
    **/
    orderBy?: Enumerable<demodaysOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: demodaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demodays from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demodays.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned demodays
    **/
    count?: true | DemodaysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: DemodaysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: DemodaysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: DemodaysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: DemodaysMaxAggregateInputType
  }

  export type GetDemodaysAggregateType<T extends DemodaysAggregateArgs> = {
    [P in keyof T & keyof AggregateDemodays]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDemodays[P]>
      : GetScalarType<T[P], AggregateDemodays[P]>
  }



  export type demodaysSelect = {
    id?: boolean
    name?: boolean
    company_id?: boolean
    streaming_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    companies?: boolean | companiesArgs
    participants?: boolean | participantsFindManyArgs
    questions?: boolean | questionsFindManyArgs
  }

  export type demodaysInclude = {
    companies?: boolean | companiesArgs
    participants?: boolean | participantsFindManyArgs
    questions?: boolean | questionsFindManyArgs
  }

  export type demodaysGetPayload<
    S extends boolean | null | undefined | demodaysArgs,
    U = keyof S
      > = S extends true
        ? demodays
    : S extends undefined
    ? never
    : S extends demodaysArgs | demodaysFindManyArgs
    ?'include' extends U
    ? demodays  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> | null :
        P extends 'participants'
        ? Array < participantsGetPayload<S['include'][P]>>  :
        P extends 'questions'
        ? Array < questionsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof demodays ?demodays [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> | null :
        P extends 'participants'
        ? Array < participantsGetPayload<S['select'][P]>>  :
        P extends 'questions'
        ? Array < questionsGetPayload<S['select'][P]>>  : never
  } 
    : demodays
  : demodays


  type demodaysCountArgs = Merge<
    Omit<demodaysFindManyArgs, 'select' | 'include'> & {
      select?: DemodaysCountAggregateInputType | true
    }
  >

  export interface demodaysDelegate {
    /**
     * Find zero or one Demodays that matches the filter.
     * @param {demodaysFindUniqueArgs} args - Arguments to find a Demodays
     * @example
     * // Get one Demodays
     * const demodays = await prisma.demodays.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends demodaysFindUniqueArgs>(
      args: SelectSubset<T, demodaysFindUniqueArgs>
    ): CheckSelect<T, Prisma__demodaysClient<demodays | null>, Prisma__demodaysClient<demodaysGetPayload<T> | null>>

    /**
     * Find the first Demodays that matches the filter.
     * @param {demodaysFindFirstArgs} args - Arguments to find a Demodays
     * @example
     * // Get one Demodays
     * const demodays = await prisma.demodays.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends demodaysFindFirstArgs>(
      args?: SelectSubset<T, demodaysFindFirstArgs>
    ): CheckSelect<T, Prisma__demodaysClient<demodays | null>, Prisma__demodaysClient<demodaysGetPayload<T> | null>>

    /**
     * Find zero or more Demodays that matches the filter.
     * @param {demodaysFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Demodays
     * const demodays = await prisma.demodays.findMany()
     * 
     * // Get first 10 Demodays
     * const demodays = await prisma.demodays.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const demodaysWithIdOnly = await prisma.demodays.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends demodaysFindManyArgs>(
      args?: SelectSubset<T, demodaysFindManyArgs>
    ): CheckSelect<T, Promise<Array<demodays>>, Promise<Array<demodaysGetPayload<T>>>>

    /**
     * Create a Demodays.
     * @param {demodaysCreateArgs} args - Arguments to create a Demodays.
     * @example
     * // Create one Demodays
     * const Demodays = await prisma.demodays.create({
     *   data: {
     *     // ... data to create a Demodays
     *   }
     * })
     * 
    **/
    create<T extends demodaysCreateArgs>(
      args: SelectSubset<T, demodaysCreateArgs>
    ): CheckSelect<T, Prisma__demodaysClient<demodays>, Prisma__demodaysClient<demodaysGetPayload<T>>>

    /**
     * Delete a Demodays.
     * @param {demodaysDeleteArgs} args - Arguments to delete one Demodays.
     * @example
     * // Delete one Demodays
     * const Demodays = await prisma.demodays.delete({
     *   where: {
     *     // ... filter to delete one Demodays
     *   }
     * })
     * 
    **/
    delete<T extends demodaysDeleteArgs>(
      args: SelectSubset<T, demodaysDeleteArgs>
    ): CheckSelect<T, Prisma__demodaysClient<demodays>, Prisma__demodaysClient<demodaysGetPayload<T>>>

    /**
     * Update one Demodays.
     * @param {demodaysUpdateArgs} args - Arguments to update one Demodays.
     * @example
     * // Update one Demodays
     * const demodays = await prisma.demodays.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends demodaysUpdateArgs>(
      args: SelectSubset<T, demodaysUpdateArgs>
    ): CheckSelect<T, Prisma__demodaysClient<demodays>, Prisma__demodaysClient<demodaysGetPayload<T>>>

    /**
     * Delete zero or more Demodays.
     * @param {demodaysDeleteManyArgs} args - Arguments to filter Demodays to delete.
     * @example
     * // Delete a few Demodays
     * const { count } = await prisma.demodays.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends demodaysDeleteManyArgs>(
      args?: SelectSubset<T, demodaysDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Demodays.
     * @param {demodaysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Demodays
     * const demodays = await prisma.demodays.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends demodaysUpdateManyArgs>(
      args: SelectSubset<T, demodaysUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Demodays.
     * @param {demodaysUpsertArgs} args - Arguments to update or create a Demodays.
     * @example
     * // Update or create a Demodays
     * const demodays = await prisma.demodays.upsert({
     *   create: {
     *     // ... data to create a Demodays
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Demodays we want to update
     *   }
     * })
    **/
    upsert<T extends demodaysUpsertArgs>(
      args: SelectSubset<T, demodaysUpsertArgs>
    ): CheckSelect<T, Prisma__demodaysClient<demodays>, Prisma__demodaysClient<demodaysGetPayload<T>>>

    /**
     * Count the number of Demodays.
     * @param {demodaysCountArgs} args - Arguments to filter Demodays to count.
     * @example
     * // Count the number of Demodays
     * const count = await prisma.demodays.count({
     *   where: {
     *     // ... the filter for the Demodays we want to count
     *   }
     * })
    **/
    count<T extends demodaysCountArgs>(
      args?: Subset<T, demodaysCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DemodaysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Demodays.
     * @param {DemodaysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DemodaysAggregateArgs>(args: Subset<T, DemodaysAggregateArgs>): Promise<GetDemodaysAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for demodays.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__demodaysClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    participants<T extends participantsFindManyArgs = {}>(args?: Subset<T, participantsFindManyArgs>): CheckSelect<T, Promise<Array<participants>>, Promise<Array<participantsGetPayload<T>>>>;

    questions<T extends questionsFindManyArgs = {}>(args?: Subset<T, questionsFindManyArgs>): CheckSelect<T, Promise<Array<questions>>, Promise<Array<questionsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * demodays findUnique
   */
  export type demodaysFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the demodays
    **/
    select?: demodaysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: demodaysInclude | null
    /**
     * Throw an Error if a demodays can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which demodays to fetch.
    **/
    where: demodaysWhereUniqueInput
  }


  /**
   * demodays findFirst
   */
  export type demodaysFindFirstArgs = {
    /**
     * Select specific fields to fetch from the demodays
    **/
    select?: demodaysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: demodaysInclude | null
    /**
     * Throw an Error if a demodays can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which demodays to fetch.
    **/
    where?: demodaysWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of demodays to fetch.
    **/
    orderBy?: Enumerable<demodaysOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for demodays.
    **/
    cursor?: demodaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demodays from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demodays.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of demodays.
    **/
    distinct?: Enumerable<DemodaysScalarFieldEnum>
  }


  /**
   * demodays findMany
   */
  export type demodaysFindManyArgs = {
    /**
     * Select specific fields to fetch from the demodays
    **/
    select?: demodaysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: demodaysInclude | null
    /**
     * Filter, which demodays to fetch.
    **/
    where?: demodaysWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of demodays to fetch.
    **/
    orderBy?: Enumerable<demodaysOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing demodays.
    **/
    cursor?: demodaysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` demodays from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` demodays.
    **/
    skip?: number
    distinct?: Enumerable<DemodaysScalarFieldEnum>
  }


  /**
   * demodays create
   */
  export type demodaysCreateArgs = {
    /**
     * Select specific fields to fetch from the demodays
    **/
    select?: demodaysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: demodaysInclude | null
    /**
     * The data needed to create a demodays.
    **/
    data: XOR<demodaysUncheckedCreateInput, demodaysCreateInput>
  }


  /**
   * demodays update
   */
  export type demodaysUpdateArgs = {
    /**
     * Select specific fields to fetch from the demodays
    **/
    select?: demodaysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: demodaysInclude | null
    /**
     * The data needed to update a demodays.
    **/
    data: XOR<demodaysUncheckedUpdateInput, demodaysUpdateInput>
    /**
     * Choose, which demodays to update.
    **/
    where: demodaysWhereUniqueInput
  }


  /**
   * demodays updateMany
   */
  export type demodaysUpdateManyArgs = {
    data: XOR<demodaysUncheckedUpdateManyInput, demodaysUpdateManyMutationInput>
    where?: demodaysWhereInput
  }


  /**
   * demodays upsert
   */
  export type demodaysUpsertArgs = {
    /**
     * Select specific fields to fetch from the demodays
    **/
    select?: demodaysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: demodaysInclude | null
    /**
     * The filter to search for the demodays to update in case it exists.
    **/
    where: demodaysWhereUniqueInput
    /**
     * In case the demodays found by the `where` argument doesn't exist, create a new demodays with this data.
    **/
    create: XOR<demodaysUncheckedCreateInput, demodaysCreateInput>
    /**
     * In case the demodays was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<demodaysUncheckedUpdateInput, demodaysUpdateInput>
  }


  /**
   * demodays delete
   */
  export type demodaysDeleteArgs = {
    /**
     * Select specific fields to fetch from the demodays
    **/
    select?: demodaysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: demodaysInclude | null
    /**
     * Filter which demodays to delete.
    **/
    where: demodaysWhereUniqueInput
  }


  /**
   * demodays deleteMany
   */
  export type demodaysDeleteManyArgs = {
    where?: demodaysWhereInput
  }


  /**
   * demodays without action
   */
  export type demodaysArgs = {
    /**
     * Select specific fields to fetch from the demodays
    **/
    select?: demodaysSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: demodaysInclude | null
  }



  /**
   * Model document_types
   */


  export type AggregateDocument_types = {
    count: Document_typesCountAggregateOutputType | null
    avg: Document_typesAvgAggregateOutputType | null
    sum: Document_typesSumAggregateOutputType | null
    min: Document_typesMinAggregateOutputType | null
    max: Document_typesMaxAggregateOutputType | null
  }

  export type Document_typesAvgAggregateOutputType = {
    id: number
  }

  export type Document_typesSumAggregateOutputType = {
    id: number
  }

  export type Document_typesMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Document_typesMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Document_typesCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type Document_typesAvgAggregateInputType = {
    id?: true
  }

  export type Document_typesSumAggregateInputType = {
    id?: true
  }

  export type Document_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Document_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Document_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Document_typesAggregateArgs = {
    /**
     * Filter which document_types to aggregate.
    **/
    where?: document_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of document_types to fetch.
    **/
    orderBy?: Enumerable<document_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: document_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_types.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned document_types
    **/
    count?: true | Document_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Document_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Document_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Document_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Document_typesMaxAggregateInputType
  }

  export type GetDocument_typesAggregateType<T extends Document_typesAggregateArgs> = {
    [P in keyof T & keyof AggregateDocument_types]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument_types[P]>
      : GetScalarType<T[P], AggregateDocument_types[P]>
  }



  export type document_typesSelect = {
    id?: boolean
    name?: boolean
    company_documents?: boolean | company_documentsFindManyArgs
    required_documents?: boolean | required_documentsFindManyArgs
  }

  export type document_typesInclude = {
    company_documents?: boolean | company_documentsFindManyArgs
    required_documents?: boolean | required_documentsFindManyArgs
  }

  export type document_typesGetPayload<
    S extends boolean | null | undefined | document_typesArgs,
    U = keyof S
      > = S extends true
        ? document_types
    : S extends undefined
    ? never
    : S extends document_typesArgs | document_typesFindManyArgs
    ?'include' extends U
    ? document_types  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'company_documents'
        ? Array < company_documentsGetPayload<S['include'][P]>>  :
        P extends 'required_documents'
        ? Array < required_documentsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof document_types ?document_types [P]
  : 
          P extends 'company_documents'
        ? Array < company_documentsGetPayload<S['select'][P]>>  :
        P extends 'required_documents'
        ? Array < required_documentsGetPayload<S['select'][P]>>  : never
  } 
    : document_types
  : document_types


  type document_typesCountArgs = Merge<
    Omit<document_typesFindManyArgs, 'select' | 'include'> & {
      select?: Document_typesCountAggregateInputType | true
    }
  >

  export interface document_typesDelegate {
    /**
     * Find zero or one Document_types that matches the filter.
     * @param {document_typesFindUniqueArgs} args - Arguments to find a Document_types
     * @example
     * // Get one Document_types
     * const document_types = await prisma.document_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends document_typesFindUniqueArgs>(
      args: SelectSubset<T, document_typesFindUniqueArgs>
    ): CheckSelect<T, Prisma__document_typesClient<document_types | null>, Prisma__document_typesClient<document_typesGetPayload<T> | null>>

    /**
     * Find the first Document_types that matches the filter.
     * @param {document_typesFindFirstArgs} args - Arguments to find a Document_types
     * @example
     * // Get one Document_types
     * const document_types = await prisma.document_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends document_typesFindFirstArgs>(
      args?: SelectSubset<T, document_typesFindFirstArgs>
    ): CheckSelect<T, Prisma__document_typesClient<document_types | null>, Prisma__document_typesClient<document_typesGetPayload<T> | null>>

    /**
     * Find zero or more Document_types that matches the filter.
     * @param {document_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Document_types
     * const document_types = await prisma.document_types.findMany()
     * 
     * // Get first 10 Document_types
     * const document_types = await prisma.document_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const document_typesWithIdOnly = await prisma.document_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends document_typesFindManyArgs>(
      args?: SelectSubset<T, document_typesFindManyArgs>
    ): CheckSelect<T, Promise<Array<document_types>>, Promise<Array<document_typesGetPayload<T>>>>

    /**
     * Create a Document_types.
     * @param {document_typesCreateArgs} args - Arguments to create a Document_types.
     * @example
     * // Create one Document_types
     * const Document_types = await prisma.document_types.create({
     *   data: {
     *     // ... data to create a Document_types
     *   }
     * })
     * 
    **/
    create<T extends document_typesCreateArgs>(
      args: SelectSubset<T, document_typesCreateArgs>
    ): CheckSelect<T, Prisma__document_typesClient<document_types>, Prisma__document_typesClient<document_typesGetPayload<T>>>

    /**
     * Delete a Document_types.
     * @param {document_typesDeleteArgs} args - Arguments to delete one Document_types.
     * @example
     * // Delete one Document_types
     * const Document_types = await prisma.document_types.delete({
     *   where: {
     *     // ... filter to delete one Document_types
     *   }
     * })
     * 
    **/
    delete<T extends document_typesDeleteArgs>(
      args: SelectSubset<T, document_typesDeleteArgs>
    ): CheckSelect<T, Prisma__document_typesClient<document_types>, Prisma__document_typesClient<document_typesGetPayload<T>>>

    /**
     * Update one Document_types.
     * @param {document_typesUpdateArgs} args - Arguments to update one Document_types.
     * @example
     * // Update one Document_types
     * const document_types = await prisma.document_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends document_typesUpdateArgs>(
      args: SelectSubset<T, document_typesUpdateArgs>
    ): CheckSelect<T, Prisma__document_typesClient<document_types>, Prisma__document_typesClient<document_typesGetPayload<T>>>

    /**
     * Delete zero or more Document_types.
     * @param {document_typesDeleteManyArgs} args - Arguments to filter Document_types to delete.
     * @example
     * // Delete a few Document_types
     * const { count } = await prisma.document_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends document_typesDeleteManyArgs>(
      args?: SelectSubset<T, document_typesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Document_types.
     * @param {document_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Document_types
     * const document_types = await prisma.document_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends document_typesUpdateManyArgs>(
      args: SelectSubset<T, document_typesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Document_types.
     * @param {document_typesUpsertArgs} args - Arguments to update or create a Document_types.
     * @example
     * // Update or create a Document_types
     * const document_types = await prisma.document_types.upsert({
     *   create: {
     *     // ... data to create a Document_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document_types we want to update
     *   }
     * })
    **/
    upsert<T extends document_typesUpsertArgs>(
      args: SelectSubset<T, document_typesUpsertArgs>
    ): CheckSelect<T, Prisma__document_typesClient<document_types>, Prisma__document_typesClient<document_typesGetPayload<T>>>

    /**
     * Count the number of Document_types.
     * @param {document_typesCountArgs} args - Arguments to filter Document_types to count.
     * @example
     * // Count the number of Document_types
     * const count = await prisma.document_types.count({
     *   where: {
     *     // ... the filter for the Document_types we want to count
     *   }
     * })
    **/
    count<T extends document_typesCountArgs>(
      args?: Subset<T, document_typesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Document_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document_types.
     * @param {Document_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Document_typesAggregateArgs>(args: Subset<T, Document_typesAggregateArgs>): Promise<GetDocument_typesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for document_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__document_typesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    company_documents<T extends company_documentsFindManyArgs = {}>(args?: Subset<T, company_documentsFindManyArgs>): CheckSelect<T, Promise<Array<company_documents>>, Promise<Array<company_documentsGetPayload<T>>>>;

    required_documents<T extends required_documentsFindManyArgs = {}>(args?: Subset<T, required_documentsFindManyArgs>): CheckSelect<T, Promise<Array<required_documents>>, Promise<Array<required_documentsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * document_types findUnique
   */
  export type document_typesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the document_types
    **/
    select?: document_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: document_typesInclude | null
    /**
     * Throw an Error if a document_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which document_types to fetch.
    **/
    where: document_typesWhereUniqueInput
  }


  /**
   * document_types findFirst
   */
  export type document_typesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the document_types
    **/
    select?: document_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: document_typesInclude | null
    /**
     * Throw an Error if a document_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which document_types to fetch.
    **/
    where?: document_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of document_types to fetch.
    **/
    orderBy?: Enumerable<document_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for document_types.
    **/
    cursor?: document_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_types.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of document_types.
    **/
    distinct?: Enumerable<Document_typesScalarFieldEnum>
  }


  /**
   * document_types findMany
   */
  export type document_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the document_types
    **/
    select?: document_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: document_typesInclude | null
    /**
     * Filter, which document_types to fetch.
    **/
    where?: document_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of document_types to fetch.
    **/
    orderBy?: Enumerable<document_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing document_types.
    **/
    cursor?: document_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` document_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` document_types.
    **/
    skip?: number
    distinct?: Enumerable<Document_typesScalarFieldEnum>
  }


  /**
   * document_types create
   */
  export type document_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the document_types
    **/
    select?: document_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: document_typesInclude | null
    /**
     * The data needed to create a document_types.
    **/
    data: XOR<document_typesUncheckedCreateInput, document_typesCreateInput>
  }


  /**
   * document_types update
   */
  export type document_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the document_types
    **/
    select?: document_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: document_typesInclude | null
    /**
     * The data needed to update a document_types.
    **/
    data: XOR<document_typesUncheckedUpdateInput, document_typesUpdateInput>
    /**
     * Choose, which document_types to update.
    **/
    where: document_typesWhereUniqueInput
  }


  /**
   * document_types updateMany
   */
  export type document_typesUpdateManyArgs = {
    data: XOR<document_typesUncheckedUpdateManyInput, document_typesUpdateManyMutationInput>
    where?: document_typesWhereInput
  }


  /**
   * document_types upsert
   */
  export type document_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the document_types
    **/
    select?: document_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: document_typesInclude | null
    /**
     * The filter to search for the document_types to update in case it exists.
    **/
    where: document_typesWhereUniqueInput
    /**
     * In case the document_types found by the `where` argument doesn't exist, create a new document_types with this data.
    **/
    create: XOR<document_typesUncheckedCreateInput, document_typesCreateInput>
    /**
     * In case the document_types was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<document_typesUncheckedUpdateInput, document_typesUpdateInput>
  }


  /**
   * document_types delete
   */
  export type document_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the document_types
    **/
    select?: document_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: document_typesInclude | null
    /**
     * Filter which document_types to delete.
    **/
    where: document_typesWhereUniqueInput
  }


  /**
   * document_types deleteMany
   */
  export type document_typesDeleteManyArgs = {
    where?: document_typesWhereInput
  }


  /**
   * document_types without action
   */
  export type document_typesArgs = {
    /**
     * Select specific fields to fetch from the document_types
    **/
    select?: document_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: document_typesInclude | null
  }



  /**
   * Model eligibilities
   */


  export type AggregateEligibilities = {
    count: EligibilitiesCountAggregateOutputType | null
    avg: EligibilitiesAvgAggregateOutputType | null
    sum: EligibilitiesSumAggregateOutputType | null
    min: EligibilitiesMinAggregateOutputType | null
    max: EligibilitiesMaxAggregateOutputType | null
  }

  export type EligibilitiesAvgAggregateOutputType = {
    id: number
  }

  export type EligibilitiesSumAggregateOutputType = {
    id: number
  }

  export type EligibilitiesMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type EligibilitiesMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type EligibilitiesCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type EligibilitiesAvgAggregateInputType = {
    id?: true
  }

  export type EligibilitiesSumAggregateInputType = {
    id?: true
  }

  export type EligibilitiesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type EligibilitiesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type EligibilitiesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type EligibilitiesAggregateArgs = {
    /**
     * Filter which eligibilities to aggregate.
    **/
    where?: eligibilitiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of eligibilities to fetch.
    **/
    orderBy?: Enumerable<eligibilitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: eligibilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eligibilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eligibilities.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eligibilities
    **/
    count?: true | EligibilitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: EligibilitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: EligibilitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: EligibilitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: EligibilitiesMaxAggregateInputType
  }

  export type GetEligibilitiesAggregateType<T extends EligibilitiesAggregateArgs> = {
    [P in keyof T & keyof AggregateEligibilities]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEligibilities[P]>
      : GetScalarType<T[P], AggregateEligibilities[P]>
  }



  export type eligibilitiesSelect = {
    id?: boolean
    name?: boolean
    projects?: boolean | projectsFindManyArgs
  }

  export type eligibilitiesInclude = {
    projects?: boolean | projectsFindManyArgs
  }

  export type eligibilitiesGetPayload<
    S extends boolean | null | undefined | eligibilitiesArgs,
    U = keyof S
      > = S extends true
        ? eligibilities
    : S extends undefined
    ? never
    : S extends eligibilitiesArgs | eligibilitiesFindManyArgs
    ?'include' extends U
    ? eligibilities  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'projects'
        ? Array < projectsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof eligibilities ?eligibilities [P]
  : 
          P extends 'projects'
        ? Array < projectsGetPayload<S['select'][P]>>  : never
  } 
    : eligibilities
  : eligibilities


  type eligibilitiesCountArgs = Merge<
    Omit<eligibilitiesFindManyArgs, 'select' | 'include'> & {
      select?: EligibilitiesCountAggregateInputType | true
    }
  >

  export interface eligibilitiesDelegate {
    /**
     * Find zero or one Eligibilities that matches the filter.
     * @param {eligibilitiesFindUniqueArgs} args - Arguments to find a Eligibilities
     * @example
     * // Get one Eligibilities
     * const eligibilities = await prisma.eligibilities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eligibilitiesFindUniqueArgs>(
      args: SelectSubset<T, eligibilitiesFindUniqueArgs>
    ): CheckSelect<T, Prisma__eligibilitiesClient<eligibilities | null>, Prisma__eligibilitiesClient<eligibilitiesGetPayload<T> | null>>

    /**
     * Find the first Eligibilities that matches the filter.
     * @param {eligibilitiesFindFirstArgs} args - Arguments to find a Eligibilities
     * @example
     * // Get one Eligibilities
     * const eligibilities = await prisma.eligibilities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eligibilitiesFindFirstArgs>(
      args?: SelectSubset<T, eligibilitiesFindFirstArgs>
    ): CheckSelect<T, Prisma__eligibilitiesClient<eligibilities | null>, Prisma__eligibilitiesClient<eligibilitiesGetPayload<T> | null>>

    /**
     * Find zero or more Eligibilities that matches the filter.
     * @param {eligibilitiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eligibilities
     * const eligibilities = await prisma.eligibilities.findMany()
     * 
     * // Get first 10 Eligibilities
     * const eligibilities = await prisma.eligibilities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eligibilitiesWithIdOnly = await prisma.eligibilities.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends eligibilitiesFindManyArgs>(
      args?: SelectSubset<T, eligibilitiesFindManyArgs>
    ): CheckSelect<T, Promise<Array<eligibilities>>, Promise<Array<eligibilitiesGetPayload<T>>>>

    /**
     * Create a Eligibilities.
     * @param {eligibilitiesCreateArgs} args - Arguments to create a Eligibilities.
     * @example
     * // Create one Eligibilities
     * const Eligibilities = await prisma.eligibilities.create({
     *   data: {
     *     // ... data to create a Eligibilities
     *   }
     * })
     * 
    **/
    create<T extends eligibilitiesCreateArgs>(
      args: SelectSubset<T, eligibilitiesCreateArgs>
    ): CheckSelect<T, Prisma__eligibilitiesClient<eligibilities>, Prisma__eligibilitiesClient<eligibilitiesGetPayload<T>>>

    /**
     * Delete a Eligibilities.
     * @param {eligibilitiesDeleteArgs} args - Arguments to delete one Eligibilities.
     * @example
     * // Delete one Eligibilities
     * const Eligibilities = await prisma.eligibilities.delete({
     *   where: {
     *     // ... filter to delete one Eligibilities
     *   }
     * })
     * 
    **/
    delete<T extends eligibilitiesDeleteArgs>(
      args: SelectSubset<T, eligibilitiesDeleteArgs>
    ): CheckSelect<T, Prisma__eligibilitiesClient<eligibilities>, Prisma__eligibilitiesClient<eligibilitiesGetPayload<T>>>

    /**
     * Update one Eligibilities.
     * @param {eligibilitiesUpdateArgs} args - Arguments to update one Eligibilities.
     * @example
     * // Update one Eligibilities
     * const eligibilities = await prisma.eligibilities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eligibilitiesUpdateArgs>(
      args: SelectSubset<T, eligibilitiesUpdateArgs>
    ): CheckSelect<T, Prisma__eligibilitiesClient<eligibilities>, Prisma__eligibilitiesClient<eligibilitiesGetPayload<T>>>

    /**
     * Delete zero or more Eligibilities.
     * @param {eligibilitiesDeleteManyArgs} args - Arguments to filter Eligibilities to delete.
     * @example
     * // Delete a few Eligibilities
     * const { count } = await prisma.eligibilities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eligibilitiesDeleteManyArgs>(
      args?: SelectSubset<T, eligibilitiesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Eligibilities.
     * @param {eligibilitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eligibilities
     * const eligibilities = await prisma.eligibilities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eligibilitiesUpdateManyArgs>(
      args: SelectSubset<T, eligibilitiesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Eligibilities.
     * @param {eligibilitiesUpsertArgs} args - Arguments to update or create a Eligibilities.
     * @example
     * // Update or create a Eligibilities
     * const eligibilities = await prisma.eligibilities.upsert({
     *   create: {
     *     // ... data to create a Eligibilities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eligibilities we want to update
     *   }
     * })
    **/
    upsert<T extends eligibilitiesUpsertArgs>(
      args: SelectSubset<T, eligibilitiesUpsertArgs>
    ): CheckSelect<T, Prisma__eligibilitiesClient<eligibilities>, Prisma__eligibilitiesClient<eligibilitiesGetPayload<T>>>

    /**
     * Count the number of Eligibilities.
     * @param {eligibilitiesCountArgs} args - Arguments to filter Eligibilities to count.
     * @example
     * // Count the number of Eligibilities
     * const count = await prisma.eligibilities.count({
     *   where: {
     *     // ... the filter for the Eligibilities we want to count
     *   }
     * })
    **/
    count<T extends eligibilitiesCountArgs>(
      args?: Subset<T, eligibilitiesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EligibilitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eligibilities.
     * @param {EligibilitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EligibilitiesAggregateArgs>(args: Subset<T, EligibilitiesAggregateArgs>): Promise<GetEligibilitiesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for eligibilities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eligibilitiesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    projects<T extends projectsFindManyArgs = {}>(args?: Subset<T, projectsFindManyArgs>): CheckSelect<T, Promise<Array<projects>>, Promise<Array<projectsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * eligibilities findUnique
   */
  export type eligibilitiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the eligibilities
    **/
    select?: eligibilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligibilitiesInclude | null
    /**
     * Throw an Error if a eligibilities can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which eligibilities to fetch.
    **/
    where: eligibilitiesWhereUniqueInput
  }


  /**
   * eligibilities findFirst
   */
  export type eligibilitiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the eligibilities
    **/
    select?: eligibilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligibilitiesInclude | null
    /**
     * Throw an Error if a eligibilities can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which eligibilities to fetch.
    **/
    where?: eligibilitiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of eligibilities to fetch.
    **/
    orderBy?: Enumerable<eligibilitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eligibilities.
    **/
    cursor?: eligibilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eligibilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eligibilities.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of eligibilities.
    **/
    distinct?: Enumerable<EligibilitiesScalarFieldEnum>
  }


  /**
   * eligibilities findMany
   */
  export type eligibilitiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the eligibilities
    **/
    select?: eligibilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligibilitiesInclude | null
    /**
     * Filter, which eligibilities to fetch.
    **/
    where?: eligibilitiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of eligibilities to fetch.
    **/
    orderBy?: Enumerable<eligibilitiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eligibilities.
    **/
    cursor?: eligibilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eligibilities from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eligibilities.
    **/
    skip?: number
    distinct?: Enumerable<EligibilitiesScalarFieldEnum>
  }


  /**
   * eligibilities create
   */
  export type eligibilitiesCreateArgs = {
    /**
     * Select specific fields to fetch from the eligibilities
    **/
    select?: eligibilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligibilitiesInclude | null
    /**
     * The data needed to create a eligibilities.
    **/
    data: XOR<eligibilitiesUncheckedCreateInput, eligibilitiesCreateInput>
  }


  /**
   * eligibilities update
   */
  export type eligibilitiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the eligibilities
    **/
    select?: eligibilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligibilitiesInclude | null
    /**
     * The data needed to update a eligibilities.
    **/
    data: XOR<eligibilitiesUncheckedUpdateInput, eligibilitiesUpdateInput>
    /**
     * Choose, which eligibilities to update.
    **/
    where: eligibilitiesWhereUniqueInput
  }


  /**
   * eligibilities updateMany
   */
  export type eligibilitiesUpdateManyArgs = {
    data: XOR<eligibilitiesUncheckedUpdateManyInput, eligibilitiesUpdateManyMutationInput>
    where?: eligibilitiesWhereInput
  }


  /**
   * eligibilities upsert
   */
  export type eligibilitiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the eligibilities
    **/
    select?: eligibilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligibilitiesInclude | null
    /**
     * The filter to search for the eligibilities to update in case it exists.
    **/
    where: eligibilitiesWhereUniqueInput
    /**
     * In case the eligibilities found by the `where` argument doesn't exist, create a new eligibilities with this data.
    **/
    create: XOR<eligibilitiesUncheckedCreateInput, eligibilitiesCreateInput>
    /**
     * In case the eligibilities was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<eligibilitiesUncheckedUpdateInput, eligibilitiesUpdateInput>
  }


  /**
   * eligibilities delete
   */
  export type eligibilitiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the eligibilities
    **/
    select?: eligibilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligibilitiesInclude | null
    /**
     * Filter which eligibilities to delete.
    **/
    where: eligibilitiesWhereUniqueInput
  }


  /**
   * eligibilities deleteMany
   */
  export type eligibilitiesDeleteManyArgs = {
    where?: eligibilitiesWhereInput
  }


  /**
   * eligibilities without action
   */
  export type eligibilitiesArgs = {
    /**
     * Select specific fields to fetch from the eligibilities
    **/
    select?: eligibilitiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligibilitiesInclude | null
  }



  /**
   * Model eligible_sectors
   */


  export type AggregateEligible_sectors = {
    count: Eligible_sectorsCountAggregateOutputType | null
    avg: Eligible_sectorsAvgAggregateOutputType | null
    sum: Eligible_sectorsSumAggregateOutputType | null
    min: Eligible_sectorsMinAggregateOutputType | null
    max: Eligible_sectorsMaxAggregateOutputType | null
  }

  export type Eligible_sectorsAvgAggregateOutputType = {
    id: number
  }

  export type Eligible_sectorsSumAggregateOutputType = {
    id: number
  }

  export type Eligible_sectorsMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Eligible_sectorsMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Eligible_sectorsCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type Eligible_sectorsAvgAggregateInputType = {
    id?: true
  }

  export type Eligible_sectorsSumAggregateInputType = {
    id?: true
  }

  export type Eligible_sectorsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Eligible_sectorsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Eligible_sectorsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Eligible_sectorsAggregateArgs = {
    /**
     * Filter which eligible_sectors to aggregate.
    **/
    where?: eligible_sectorsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of eligible_sectors to fetch.
    **/
    orderBy?: Enumerable<eligible_sectorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: eligible_sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eligible_sectors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eligible_sectors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned eligible_sectors
    **/
    count?: true | Eligible_sectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Eligible_sectorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Eligible_sectorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Eligible_sectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Eligible_sectorsMaxAggregateInputType
  }

  export type GetEligible_sectorsAggregateType<T extends Eligible_sectorsAggregateArgs> = {
    [P in keyof T & keyof AggregateEligible_sectors]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEligible_sectors[P]>
      : GetScalarType<T[P], AggregateEligible_sectors[P]>
  }



  export type eligible_sectorsSelect = {
    id?: boolean
    name?: boolean
    projects?: boolean | projectsFindManyArgs
  }

  export type eligible_sectorsInclude = {
    projects?: boolean | projectsFindManyArgs
  }

  export type eligible_sectorsGetPayload<
    S extends boolean | null | undefined | eligible_sectorsArgs,
    U = keyof S
      > = S extends true
        ? eligible_sectors
    : S extends undefined
    ? never
    : S extends eligible_sectorsArgs | eligible_sectorsFindManyArgs
    ?'include' extends U
    ? eligible_sectors  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'projects'
        ? Array < projectsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof eligible_sectors ?eligible_sectors [P]
  : 
          P extends 'projects'
        ? Array < projectsGetPayload<S['select'][P]>>  : never
  } 
    : eligible_sectors
  : eligible_sectors


  type eligible_sectorsCountArgs = Merge<
    Omit<eligible_sectorsFindManyArgs, 'select' | 'include'> & {
      select?: Eligible_sectorsCountAggregateInputType | true
    }
  >

  export interface eligible_sectorsDelegate {
    /**
     * Find zero or one Eligible_sectors that matches the filter.
     * @param {eligible_sectorsFindUniqueArgs} args - Arguments to find a Eligible_sectors
     * @example
     * // Get one Eligible_sectors
     * const eligible_sectors = await prisma.eligible_sectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends eligible_sectorsFindUniqueArgs>(
      args: SelectSubset<T, eligible_sectorsFindUniqueArgs>
    ): CheckSelect<T, Prisma__eligible_sectorsClient<eligible_sectors | null>, Prisma__eligible_sectorsClient<eligible_sectorsGetPayload<T> | null>>

    /**
     * Find the first Eligible_sectors that matches the filter.
     * @param {eligible_sectorsFindFirstArgs} args - Arguments to find a Eligible_sectors
     * @example
     * // Get one Eligible_sectors
     * const eligible_sectors = await prisma.eligible_sectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends eligible_sectorsFindFirstArgs>(
      args?: SelectSubset<T, eligible_sectorsFindFirstArgs>
    ): CheckSelect<T, Prisma__eligible_sectorsClient<eligible_sectors | null>, Prisma__eligible_sectorsClient<eligible_sectorsGetPayload<T> | null>>

    /**
     * Find zero or more Eligible_sectors that matches the filter.
     * @param {eligible_sectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eligible_sectors
     * const eligible_sectors = await prisma.eligible_sectors.findMany()
     * 
     * // Get first 10 Eligible_sectors
     * const eligible_sectors = await prisma.eligible_sectors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eligible_sectorsWithIdOnly = await prisma.eligible_sectors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends eligible_sectorsFindManyArgs>(
      args?: SelectSubset<T, eligible_sectorsFindManyArgs>
    ): CheckSelect<T, Promise<Array<eligible_sectors>>, Promise<Array<eligible_sectorsGetPayload<T>>>>

    /**
     * Create a Eligible_sectors.
     * @param {eligible_sectorsCreateArgs} args - Arguments to create a Eligible_sectors.
     * @example
     * // Create one Eligible_sectors
     * const Eligible_sectors = await prisma.eligible_sectors.create({
     *   data: {
     *     // ... data to create a Eligible_sectors
     *   }
     * })
     * 
    **/
    create<T extends eligible_sectorsCreateArgs>(
      args: SelectSubset<T, eligible_sectorsCreateArgs>
    ): CheckSelect<T, Prisma__eligible_sectorsClient<eligible_sectors>, Prisma__eligible_sectorsClient<eligible_sectorsGetPayload<T>>>

    /**
     * Delete a Eligible_sectors.
     * @param {eligible_sectorsDeleteArgs} args - Arguments to delete one Eligible_sectors.
     * @example
     * // Delete one Eligible_sectors
     * const Eligible_sectors = await prisma.eligible_sectors.delete({
     *   where: {
     *     // ... filter to delete one Eligible_sectors
     *   }
     * })
     * 
    **/
    delete<T extends eligible_sectorsDeleteArgs>(
      args: SelectSubset<T, eligible_sectorsDeleteArgs>
    ): CheckSelect<T, Prisma__eligible_sectorsClient<eligible_sectors>, Prisma__eligible_sectorsClient<eligible_sectorsGetPayload<T>>>

    /**
     * Update one Eligible_sectors.
     * @param {eligible_sectorsUpdateArgs} args - Arguments to update one Eligible_sectors.
     * @example
     * // Update one Eligible_sectors
     * const eligible_sectors = await prisma.eligible_sectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends eligible_sectorsUpdateArgs>(
      args: SelectSubset<T, eligible_sectorsUpdateArgs>
    ): CheckSelect<T, Prisma__eligible_sectorsClient<eligible_sectors>, Prisma__eligible_sectorsClient<eligible_sectorsGetPayload<T>>>

    /**
     * Delete zero or more Eligible_sectors.
     * @param {eligible_sectorsDeleteManyArgs} args - Arguments to filter Eligible_sectors to delete.
     * @example
     * // Delete a few Eligible_sectors
     * const { count } = await prisma.eligible_sectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends eligible_sectorsDeleteManyArgs>(
      args?: SelectSubset<T, eligible_sectorsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Eligible_sectors.
     * @param {eligible_sectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eligible_sectors
     * const eligible_sectors = await prisma.eligible_sectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends eligible_sectorsUpdateManyArgs>(
      args: SelectSubset<T, eligible_sectorsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Eligible_sectors.
     * @param {eligible_sectorsUpsertArgs} args - Arguments to update or create a Eligible_sectors.
     * @example
     * // Update or create a Eligible_sectors
     * const eligible_sectors = await prisma.eligible_sectors.upsert({
     *   create: {
     *     // ... data to create a Eligible_sectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Eligible_sectors we want to update
     *   }
     * })
    **/
    upsert<T extends eligible_sectorsUpsertArgs>(
      args: SelectSubset<T, eligible_sectorsUpsertArgs>
    ): CheckSelect<T, Prisma__eligible_sectorsClient<eligible_sectors>, Prisma__eligible_sectorsClient<eligible_sectorsGetPayload<T>>>

    /**
     * Count the number of Eligible_sectors.
     * @param {eligible_sectorsCountArgs} args - Arguments to filter Eligible_sectors to count.
     * @example
     * // Count the number of Eligible_sectors
     * const count = await prisma.eligible_sectors.count({
     *   where: {
     *     // ... the filter for the Eligible_sectors we want to count
     *   }
     * })
    **/
    count<T extends eligible_sectorsCountArgs>(
      args?: Subset<T, eligible_sectorsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Eligible_sectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Eligible_sectors.
     * @param {Eligible_sectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Eligible_sectorsAggregateArgs>(args: Subset<T, Eligible_sectorsAggregateArgs>): Promise<GetEligible_sectorsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for eligible_sectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__eligible_sectorsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    projects<T extends projectsFindManyArgs = {}>(args?: Subset<T, projectsFindManyArgs>): CheckSelect<T, Promise<Array<projects>>, Promise<Array<projectsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * eligible_sectors findUnique
   */
  export type eligible_sectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the eligible_sectors
    **/
    select?: eligible_sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligible_sectorsInclude | null
    /**
     * Throw an Error if a eligible_sectors can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which eligible_sectors to fetch.
    **/
    where: eligible_sectorsWhereUniqueInput
  }


  /**
   * eligible_sectors findFirst
   */
  export type eligible_sectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the eligible_sectors
    **/
    select?: eligible_sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligible_sectorsInclude | null
    /**
     * Throw an Error if a eligible_sectors can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which eligible_sectors to fetch.
    **/
    where?: eligible_sectorsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of eligible_sectors to fetch.
    **/
    orderBy?: Enumerable<eligible_sectorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for eligible_sectors.
    **/
    cursor?: eligible_sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eligible_sectors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eligible_sectors.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of eligible_sectors.
    **/
    distinct?: Enumerable<Eligible_sectorsScalarFieldEnum>
  }


  /**
   * eligible_sectors findMany
   */
  export type eligible_sectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the eligible_sectors
    **/
    select?: eligible_sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligible_sectorsInclude | null
    /**
     * Filter, which eligible_sectors to fetch.
    **/
    where?: eligible_sectorsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of eligible_sectors to fetch.
    **/
    orderBy?: Enumerable<eligible_sectorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing eligible_sectors.
    **/
    cursor?: eligible_sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` eligible_sectors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` eligible_sectors.
    **/
    skip?: number
    distinct?: Enumerable<Eligible_sectorsScalarFieldEnum>
  }


  /**
   * eligible_sectors create
   */
  export type eligible_sectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the eligible_sectors
    **/
    select?: eligible_sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligible_sectorsInclude | null
    /**
     * The data needed to create a eligible_sectors.
    **/
    data: XOR<eligible_sectorsUncheckedCreateInput, eligible_sectorsCreateInput>
  }


  /**
   * eligible_sectors update
   */
  export type eligible_sectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the eligible_sectors
    **/
    select?: eligible_sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligible_sectorsInclude | null
    /**
     * The data needed to update a eligible_sectors.
    **/
    data: XOR<eligible_sectorsUncheckedUpdateInput, eligible_sectorsUpdateInput>
    /**
     * Choose, which eligible_sectors to update.
    **/
    where: eligible_sectorsWhereUniqueInput
  }


  /**
   * eligible_sectors updateMany
   */
  export type eligible_sectorsUpdateManyArgs = {
    data: XOR<eligible_sectorsUncheckedUpdateManyInput, eligible_sectorsUpdateManyMutationInput>
    where?: eligible_sectorsWhereInput
  }


  /**
   * eligible_sectors upsert
   */
  export type eligible_sectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the eligible_sectors
    **/
    select?: eligible_sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligible_sectorsInclude | null
    /**
     * The filter to search for the eligible_sectors to update in case it exists.
    **/
    where: eligible_sectorsWhereUniqueInput
    /**
     * In case the eligible_sectors found by the `where` argument doesn't exist, create a new eligible_sectors with this data.
    **/
    create: XOR<eligible_sectorsUncheckedCreateInput, eligible_sectorsCreateInput>
    /**
     * In case the eligible_sectors was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<eligible_sectorsUncheckedUpdateInput, eligible_sectorsUpdateInput>
  }


  /**
   * eligible_sectors delete
   */
  export type eligible_sectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the eligible_sectors
    **/
    select?: eligible_sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligible_sectorsInclude | null
    /**
     * Filter which eligible_sectors to delete.
    **/
    where: eligible_sectorsWhereUniqueInput
  }


  /**
   * eligible_sectors deleteMany
   */
  export type eligible_sectorsDeleteManyArgs = {
    where?: eligible_sectorsWhereInput
  }


  /**
   * eligible_sectors without action
   */
  export type eligible_sectorsArgs = {
    /**
     * Select specific fields to fetch from the eligible_sectors
    **/
    select?: eligible_sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: eligible_sectorsInclude | null
  }



  /**
   * Model email_auth
   */


  export type AggregateEmail_auth = {
    count: Email_authCountAggregateOutputType | null
    min: Email_authMinAggregateOutputType | null
    max: Email_authMaxAggregateOutputType | null
  }

  export type Email_authMinAggregateOutputType = {
    email: string | null
    auth_number: string | null
  }

  export type Email_authMaxAggregateOutputType = {
    email: string | null
    auth_number: string | null
  }

  export type Email_authCountAggregateOutputType = {
    email: number | null
    auth_number: number | null
    _all: number
  }


  export type Email_authMinAggregateInputType = {
    email?: true
    auth_number?: true
  }

  export type Email_authMaxAggregateInputType = {
    email?: true
    auth_number?: true
  }

  export type Email_authCountAggregateInputType = {
    email?: true
    auth_number?: true
    _all?: true
  }

  export type Email_authAggregateArgs = {
    /**
     * Filter which email_auth to aggregate.
    **/
    where?: email_authWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of email_auths to fetch.
    **/
    orderBy?: Enumerable<email_authOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: email_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_auths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_auths.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_auths
    **/
    count?: true | Email_authCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Email_authMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Email_authMaxAggregateInputType
  }

  export type GetEmail_authAggregateType<T extends Email_authAggregateArgs> = {
    [P in keyof T & keyof AggregateEmail_auth]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_auth[P]>
      : GetScalarType<T[P], AggregateEmail_auth[P]>
  }



  export type email_authSelect = {
    email?: boolean
    auth_number?: boolean
  }

  export type email_authGetPayload<
    S extends boolean | null | undefined | email_authArgs,
    U = keyof S
      > = S extends true
        ? email_auth
    : S extends undefined
    ? never
    : S extends email_authArgs | email_authFindManyArgs
    ?'include' extends U
    ? email_auth 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof email_auth ?email_auth [P]
  : 
     never
  } 
    : email_auth
  : email_auth


  type email_authCountArgs = Merge<
    Omit<email_authFindManyArgs, 'select' | 'include'> & {
      select?: Email_authCountAggregateInputType | true
    }
  >

  export interface email_authDelegate {
    /**
     * Find zero or one Email_auth that matches the filter.
     * @param {email_authFindUniqueArgs} args - Arguments to find a Email_auth
     * @example
     * // Get one Email_auth
     * const email_auth = await prisma.email_auth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends email_authFindUniqueArgs>(
      args: SelectSubset<T, email_authFindUniqueArgs>
    ): CheckSelect<T, Prisma__email_authClient<email_auth | null>, Prisma__email_authClient<email_authGetPayload<T> | null>>

    /**
     * Find the first Email_auth that matches the filter.
     * @param {email_authFindFirstArgs} args - Arguments to find a Email_auth
     * @example
     * // Get one Email_auth
     * const email_auth = await prisma.email_auth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends email_authFindFirstArgs>(
      args?: SelectSubset<T, email_authFindFirstArgs>
    ): CheckSelect<T, Prisma__email_authClient<email_auth | null>, Prisma__email_authClient<email_authGetPayload<T> | null>>

    /**
     * Find zero or more Email_auths that matches the filter.
     * @param {email_authFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_auths
     * const email_auths = await prisma.email_auth.findMany()
     * 
     * // Get first 10 Email_auths
     * const email_auths = await prisma.email_auth.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const email_authWithEmailOnly = await prisma.email_auth.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends email_authFindManyArgs>(
      args?: SelectSubset<T, email_authFindManyArgs>
    ): CheckSelect<T, Promise<Array<email_auth>>, Promise<Array<email_authGetPayload<T>>>>

    /**
     * Create a Email_auth.
     * @param {email_authCreateArgs} args - Arguments to create a Email_auth.
     * @example
     * // Create one Email_auth
     * const Email_auth = await prisma.email_auth.create({
     *   data: {
     *     // ... data to create a Email_auth
     *   }
     * })
     * 
    **/
    create<T extends email_authCreateArgs>(
      args: SelectSubset<T, email_authCreateArgs>
    ): CheckSelect<T, Prisma__email_authClient<email_auth>, Prisma__email_authClient<email_authGetPayload<T>>>

    /**
     * Delete a Email_auth.
     * @param {email_authDeleteArgs} args - Arguments to delete one Email_auth.
     * @example
     * // Delete one Email_auth
     * const Email_auth = await prisma.email_auth.delete({
     *   where: {
     *     // ... filter to delete one Email_auth
     *   }
     * })
     * 
    **/
    delete<T extends email_authDeleteArgs>(
      args: SelectSubset<T, email_authDeleteArgs>
    ): CheckSelect<T, Prisma__email_authClient<email_auth>, Prisma__email_authClient<email_authGetPayload<T>>>

    /**
     * Update one Email_auth.
     * @param {email_authUpdateArgs} args - Arguments to update one Email_auth.
     * @example
     * // Update one Email_auth
     * const email_auth = await prisma.email_auth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends email_authUpdateArgs>(
      args: SelectSubset<T, email_authUpdateArgs>
    ): CheckSelect<T, Prisma__email_authClient<email_auth>, Prisma__email_authClient<email_authGetPayload<T>>>

    /**
     * Delete zero or more Email_auths.
     * @param {email_authDeleteManyArgs} args - Arguments to filter Email_auths to delete.
     * @example
     * // Delete a few Email_auths
     * const { count } = await prisma.email_auth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends email_authDeleteManyArgs>(
      args?: SelectSubset<T, email_authDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Email_auths.
     * @param {email_authUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_auths
     * const email_auth = await prisma.email_auth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends email_authUpdateManyArgs>(
      args: SelectSubset<T, email_authUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Email_auth.
     * @param {email_authUpsertArgs} args - Arguments to update or create a Email_auth.
     * @example
     * // Update or create a Email_auth
     * const email_auth = await prisma.email_auth.upsert({
     *   create: {
     *     // ... data to create a Email_auth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_auth we want to update
     *   }
     * })
    **/
    upsert<T extends email_authUpsertArgs>(
      args: SelectSubset<T, email_authUpsertArgs>
    ): CheckSelect<T, Prisma__email_authClient<email_auth>, Prisma__email_authClient<email_authGetPayload<T>>>

    /**
     * Count the number of Email_auths.
     * @param {email_authCountArgs} args - Arguments to filter Email_auths to count.
     * @example
     * // Count the number of Email_auths
     * const count = await prisma.email_auth.count({
     *   where: {
     *     // ... the filter for the Email_auths we want to count
     *   }
     * })
    **/
    count<T extends email_authCountArgs>(
      args?: Subset<T, email_authCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_authCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_auth.
     * @param {Email_authAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_authAggregateArgs>(args: Subset<T, Email_authAggregateArgs>): Promise<GetEmail_authAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for email_auth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__email_authClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * email_auth findUnique
   */
  export type email_authFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the email_auth
    **/
    select?: email_authSelect | null
    /**
     * Throw an Error if a email_auth can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which email_auth to fetch.
    **/
    where: email_authWhereUniqueInput
  }


  /**
   * email_auth findFirst
   */
  export type email_authFindFirstArgs = {
    /**
     * Select specific fields to fetch from the email_auth
    **/
    select?: email_authSelect | null
    /**
     * Throw an Error if a email_auth can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which email_auth to fetch.
    **/
    where?: email_authWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of email_auths to fetch.
    **/
    orderBy?: Enumerable<email_authOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_auths.
    **/
    cursor?: email_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_auths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_auths.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of email_auths.
    **/
    distinct?: Enumerable<Email_authScalarFieldEnum>
  }


  /**
   * email_auth findMany
   */
  export type email_authFindManyArgs = {
    /**
     * Select specific fields to fetch from the email_auth
    **/
    select?: email_authSelect | null
    /**
     * Filter, which email_auths to fetch.
    **/
    where?: email_authWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of email_auths to fetch.
    **/
    orderBy?: Enumerable<email_authOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_auths.
    **/
    cursor?: email_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_auths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_auths.
    **/
    skip?: number
    distinct?: Enumerable<Email_authScalarFieldEnum>
  }


  /**
   * email_auth create
   */
  export type email_authCreateArgs = {
    /**
     * Select specific fields to fetch from the email_auth
    **/
    select?: email_authSelect | null
    /**
     * The data needed to create a email_auth.
    **/
    data: XOR<email_authUncheckedCreateInput, email_authCreateInput>
  }


  /**
   * email_auth update
   */
  export type email_authUpdateArgs = {
    /**
     * Select specific fields to fetch from the email_auth
    **/
    select?: email_authSelect | null
    /**
     * The data needed to update a email_auth.
    **/
    data: XOR<email_authUncheckedUpdateInput, email_authUpdateInput>
    /**
     * Choose, which email_auth to update.
    **/
    where: email_authWhereUniqueInput
  }


  /**
   * email_auth updateMany
   */
  export type email_authUpdateManyArgs = {
    data: XOR<email_authUncheckedUpdateManyInput, email_authUpdateManyMutationInput>
    where?: email_authWhereInput
  }


  /**
   * email_auth upsert
   */
  export type email_authUpsertArgs = {
    /**
     * Select specific fields to fetch from the email_auth
    **/
    select?: email_authSelect | null
    /**
     * The filter to search for the email_auth to update in case it exists.
    **/
    where: email_authWhereUniqueInput
    /**
     * In case the email_auth found by the `where` argument doesn't exist, create a new email_auth with this data.
    **/
    create: XOR<email_authUncheckedCreateInput, email_authCreateInput>
    /**
     * In case the email_auth was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<email_authUncheckedUpdateInput, email_authUpdateInput>
  }


  /**
   * email_auth delete
   */
  export type email_authDeleteArgs = {
    /**
     * Select specific fields to fetch from the email_auth
    **/
    select?: email_authSelect | null
    /**
     * Filter which email_auth to delete.
    **/
    where: email_authWhereUniqueInput
  }


  /**
   * email_auth deleteMany
   */
  export type email_authDeleteManyArgs = {
    where?: email_authWhereInput
  }


  /**
   * email_auth without action
   */
  export type email_authArgs = {
    /**
     * Select specific fields to fetch from the email_auth
    **/
    select?: email_authSelect | null
  }



  /**
   * Model invested_from
   */


  export type AggregateInvested_from = {
    count: Invested_fromCountAggregateOutputType | null
    avg: Invested_fromAvgAggregateOutputType | null
    sum: Invested_fromSumAggregateOutputType | null
    min: Invested_fromMinAggregateOutputType | null
    max: Invested_fromMaxAggregateOutputType | null
  }

  export type Invested_fromAvgAggregateOutputType = {
    id: number
    startup_id: number
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type Invested_fromSumAggregateOutputType = {
    id: number
    startup_id: number
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type Invested_fromMinAggregateOutputType = {
    id: number
    startup_id: number
    date: Date | null
    invested_institution: string | null
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type Invested_fromMaxAggregateOutputType = {
    id: number
    startup_id: number
    date: Date | null
    invested_institution: string | null
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type Invested_fromCountAggregateOutputType = {
    id: number
    startup_id: number
    date: number | null
    invested_institution: number | null
    invested_fund_id: number
    corporate_value: number
    series_id: number
    _all: number
  }


  export type Invested_fromAvgAggregateInputType = {
    id?: true
    startup_id?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
  }

  export type Invested_fromSumAggregateInputType = {
    id?: true
    startup_id?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
  }

  export type Invested_fromMinAggregateInputType = {
    id?: true
    startup_id?: true
    date?: true
    invested_institution?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
  }

  export type Invested_fromMaxAggregateInputType = {
    id?: true
    startup_id?: true
    date?: true
    invested_institution?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
  }

  export type Invested_fromCountAggregateInputType = {
    id?: true
    startup_id?: true
    date?: true
    invested_institution?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
    _all?: true
  }

  export type Invested_fromAggregateArgs = {
    /**
     * Filter which invested_from to aggregate.
    **/
    where?: invested_fromWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of invested_froms to fetch.
    **/
    orderBy?: Enumerable<invested_fromOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: invested_fromWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invested_froms from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invested_froms.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invested_froms
    **/
    count?: true | Invested_fromCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Invested_fromAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Invested_fromSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Invested_fromMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Invested_fromMaxAggregateInputType
  }

  export type GetInvested_fromAggregateType<T extends Invested_fromAggregateArgs> = {
    [P in keyof T & keyof AggregateInvested_from]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvested_from[P]>
      : GetScalarType<T[P], AggregateInvested_from[P]>
  }



  export type invested_fromSelect = {
    id?: boolean
    startup_id?: boolean
    date?: boolean
    invested_institution?: boolean
    invested_fund_id?: boolean
    corporate_value?: boolean
    series_id?: boolean
    investment_series?: boolean | investment_seriesArgs
    investment_funds?: boolean | investment_fundsArgs
    startups?: boolean | startupsArgs
  }

  export type invested_fromInclude = {
    investment_series?: boolean | investment_seriesArgs
    investment_funds?: boolean | investment_fundsArgs
    startups?: boolean | startupsArgs
  }

  export type invested_fromGetPayload<
    S extends boolean | null | undefined | invested_fromArgs,
    U = keyof S
      > = S extends true
        ? invested_from
    : S extends undefined
    ? never
    : S extends invested_fromArgs | invested_fromFindManyArgs
    ?'include' extends U
    ? invested_from  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'investment_series'
        ? investment_seriesGetPayload<S['include'][P]> :
        P extends 'investment_funds'
        ? investment_fundsGetPayload<S['include'][P]> :
        P extends 'startups'
        ? startupsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof invested_from ?invested_from [P]
  : 
          P extends 'investment_series'
        ? investment_seriesGetPayload<S['select'][P]> :
        P extends 'investment_funds'
        ? investment_fundsGetPayload<S['select'][P]> :
        P extends 'startups'
        ? startupsGetPayload<S['select'][P]> : never
  } 
    : invested_from
  : invested_from


  type invested_fromCountArgs = Merge<
    Omit<invested_fromFindManyArgs, 'select' | 'include'> & {
      select?: Invested_fromCountAggregateInputType | true
    }
  >

  export interface invested_fromDelegate {
    /**
     * Find zero or one Invested_from that matches the filter.
     * @param {invested_fromFindUniqueArgs} args - Arguments to find a Invested_from
     * @example
     * // Get one Invested_from
     * const invested_from = await prisma.invested_from.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invested_fromFindUniqueArgs>(
      args: SelectSubset<T, invested_fromFindUniqueArgs>
    ): CheckSelect<T, Prisma__invested_fromClient<invested_from | null>, Prisma__invested_fromClient<invested_fromGetPayload<T> | null>>

    /**
     * Find the first Invested_from that matches the filter.
     * @param {invested_fromFindFirstArgs} args - Arguments to find a Invested_from
     * @example
     * // Get one Invested_from
     * const invested_from = await prisma.invested_from.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invested_fromFindFirstArgs>(
      args?: SelectSubset<T, invested_fromFindFirstArgs>
    ): CheckSelect<T, Prisma__invested_fromClient<invested_from | null>, Prisma__invested_fromClient<invested_fromGetPayload<T> | null>>

    /**
     * Find zero or more Invested_froms that matches the filter.
     * @param {invested_fromFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invested_froms
     * const invested_froms = await prisma.invested_from.findMany()
     * 
     * // Get first 10 Invested_froms
     * const invested_froms = await prisma.invested_from.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invested_fromWithIdOnly = await prisma.invested_from.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends invested_fromFindManyArgs>(
      args?: SelectSubset<T, invested_fromFindManyArgs>
    ): CheckSelect<T, Promise<Array<invested_from>>, Promise<Array<invested_fromGetPayload<T>>>>

    /**
     * Create a Invested_from.
     * @param {invested_fromCreateArgs} args - Arguments to create a Invested_from.
     * @example
     * // Create one Invested_from
     * const Invested_from = await prisma.invested_from.create({
     *   data: {
     *     // ... data to create a Invested_from
     *   }
     * })
     * 
    **/
    create<T extends invested_fromCreateArgs>(
      args: SelectSubset<T, invested_fromCreateArgs>
    ): CheckSelect<T, Prisma__invested_fromClient<invested_from>, Prisma__invested_fromClient<invested_fromGetPayload<T>>>

    /**
     * Delete a Invested_from.
     * @param {invested_fromDeleteArgs} args - Arguments to delete one Invested_from.
     * @example
     * // Delete one Invested_from
     * const Invested_from = await prisma.invested_from.delete({
     *   where: {
     *     // ... filter to delete one Invested_from
     *   }
     * })
     * 
    **/
    delete<T extends invested_fromDeleteArgs>(
      args: SelectSubset<T, invested_fromDeleteArgs>
    ): CheckSelect<T, Prisma__invested_fromClient<invested_from>, Prisma__invested_fromClient<invested_fromGetPayload<T>>>

    /**
     * Update one Invested_from.
     * @param {invested_fromUpdateArgs} args - Arguments to update one Invested_from.
     * @example
     * // Update one Invested_from
     * const invested_from = await prisma.invested_from.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invested_fromUpdateArgs>(
      args: SelectSubset<T, invested_fromUpdateArgs>
    ): CheckSelect<T, Prisma__invested_fromClient<invested_from>, Prisma__invested_fromClient<invested_fromGetPayload<T>>>

    /**
     * Delete zero or more Invested_froms.
     * @param {invested_fromDeleteManyArgs} args - Arguments to filter Invested_froms to delete.
     * @example
     * // Delete a few Invested_froms
     * const { count } = await prisma.invested_from.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invested_fromDeleteManyArgs>(
      args?: SelectSubset<T, invested_fromDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Invested_froms.
     * @param {invested_fromUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invested_froms
     * const invested_from = await prisma.invested_from.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invested_fromUpdateManyArgs>(
      args: SelectSubset<T, invested_fromUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Invested_from.
     * @param {invested_fromUpsertArgs} args - Arguments to update or create a Invested_from.
     * @example
     * // Update or create a Invested_from
     * const invested_from = await prisma.invested_from.upsert({
     *   create: {
     *     // ... data to create a Invested_from
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invested_from we want to update
     *   }
     * })
    **/
    upsert<T extends invested_fromUpsertArgs>(
      args: SelectSubset<T, invested_fromUpsertArgs>
    ): CheckSelect<T, Prisma__invested_fromClient<invested_from>, Prisma__invested_fromClient<invested_fromGetPayload<T>>>

    /**
     * Count the number of Invested_froms.
     * @param {invested_fromCountArgs} args - Arguments to filter Invested_froms to count.
     * @example
     * // Count the number of Invested_froms
     * const count = await prisma.invested_from.count({
     *   where: {
     *     // ... the filter for the Invested_froms we want to count
     *   }
     * })
    **/
    count<T extends invested_fromCountArgs>(
      args?: Subset<T, invested_fromCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invested_fromCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invested_from.
     * @param {Invested_fromAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invested_fromAggregateArgs>(args: Subset<T, Invested_fromAggregateArgs>): Promise<GetInvested_fromAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for invested_from.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invested_fromClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    investment_series<T extends investment_seriesArgs = {}>(args?: Subset<T, investment_seriesArgs>): CheckSelect<T, Prisma__investment_seriesClient<investment_series | null>, Prisma__investment_seriesClient<investment_seriesGetPayload<T> | null>>;

    investment_funds<T extends investment_fundsArgs = {}>(args?: Subset<T, investment_fundsArgs>): CheckSelect<T, Prisma__investment_fundsClient<investment_funds | null>, Prisma__investment_fundsClient<investment_fundsGetPayload<T> | null>>;

    startups<T extends startupsArgs = {}>(args?: Subset<T, startupsArgs>): CheckSelect<T, Prisma__startupsClient<startups | null>, Prisma__startupsClient<startupsGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * invested_from findUnique
   */
  export type invested_fromFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the invested_from
    **/
    select?: invested_fromSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_fromInclude | null
    /**
     * Throw an Error if a invested_from can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which invested_from to fetch.
    **/
    where: invested_fromWhereUniqueInput
  }


  /**
   * invested_from findFirst
   */
  export type invested_fromFindFirstArgs = {
    /**
     * Select specific fields to fetch from the invested_from
    **/
    select?: invested_fromSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_fromInclude | null
    /**
     * Throw an Error if a invested_from can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which invested_from to fetch.
    **/
    where?: invested_fromWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of invested_froms to fetch.
    **/
    orderBy?: Enumerable<invested_fromOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invested_froms.
    **/
    cursor?: invested_fromWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invested_froms from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invested_froms.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of invested_froms.
    **/
    distinct?: Enumerable<Invested_fromScalarFieldEnum>
  }


  /**
   * invested_from findMany
   */
  export type invested_fromFindManyArgs = {
    /**
     * Select specific fields to fetch from the invested_from
    **/
    select?: invested_fromSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_fromInclude | null
    /**
     * Filter, which invested_froms to fetch.
    **/
    where?: invested_fromWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of invested_froms to fetch.
    **/
    orderBy?: Enumerable<invested_fromOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invested_froms.
    **/
    cursor?: invested_fromWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invested_froms from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invested_froms.
    **/
    skip?: number
    distinct?: Enumerable<Invested_fromScalarFieldEnum>
  }


  /**
   * invested_from create
   */
  export type invested_fromCreateArgs = {
    /**
     * Select specific fields to fetch from the invested_from
    **/
    select?: invested_fromSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_fromInclude | null
    /**
     * The data needed to create a invested_from.
    **/
    data: XOR<invested_fromUncheckedCreateInput, invested_fromCreateInput>
  }


  /**
   * invested_from update
   */
  export type invested_fromUpdateArgs = {
    /**
     * Select specific fields to fetch from the invested_from
    **/
    select?: invested_fromSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_fromInclude | null
    /**
     * The data needed to update a invested_from.
    **/
    data: XOR<invested_fromUncheckedUpdateInput, invested_fromUpdateInput>
    /**
     * Choose, which invested_from to update.
    **/
    where: invested_fromWhereUniqueInput
  }


  /**
   * invested_from updateMany
   */
  export type invested_fromUpdateManyArgs = {
    data: XOR<invested_fromUncheckedUpdateManyInput, invested_fromUpdateManyMutationInput>
    where?: invested_fromWhereInput
  }


  /**
   * invested_from upsert
   */
  export type invested_fromUpsertArgs = {
    /**
     * Select specific fields to fetch from the invested_from
    **/
    select?: invested_fromSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_fromInclude | null
    /**
     * The filter to search for the invested_from to update in case it exists.
    **/
    where: invested_fromWhereUniqueInput
    /**
     * In case the invested_from found by the `where` argument doesn't exist, create a new invested_from with this data.
    **/
    create: XOR<invested_fromUncheckedCreateInput, invested_fromCreateInput>
    /**
     * In case the invested_from was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<invested_fromUncheckedUpdateInput, invested_fromUpdateInput>
  }


  /**
   * invested_from delete
   */
  export type invested_fromDeleteArgs = {
    /**
     * Select specific fields to fetch from the invested_from
    **/
    select?: invested_fromSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_fromInclude | null
    /**
     * Filter which invested_from to delete.
    **/
    where: invested_fromWhereUniqueInput
  }


  /**
   * invested_from deleteMany
   */
  export type invested_fromDeleteManyArgs = {
    where?: invested_fromWhereInput
  }


  /**
   * invested_from without action
   */
  export type invested_fromArgs = {
    /**
     * Select specific fields to fetch from the invested_from
    **/
    select?: invested_fromSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_fromInclude | null
  }



  /**
   * Model invested_to
   */


  export type AggregateInvested_to = {
    count: Invested_toCountAggregateOutputType | null
    avg: Invested_toAvgAggregateOutputType | null
    sum: Invested_toSumAggregateOutputType | null
    min: Invested_toMinAggregateOutputType | null
    max: Invested_toMaxAggregateOutputType | null
  }

  export type Invested_toAvgAggregateOutputType = {
    id: number
    partner_id: number
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type Invested_toSumAggregateOutputType = {
    id: number
    partner_id: number
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type Invested_toMinAggregateOutputType = {
    id: number
    partner_id: number
    date: Date | null
    invested_startup: string | null
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type Invested_toMaxAggregateOutputType = {
    id: number
    partner_id: number
    date: Date | null
    invested_startup: string | null
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type Invested_toCountAggregateOutputType = {
    id: number
    partner_id: number
    date: number | null
    invested_startup: number | null
    invested_fund_id: number
    corporate_value: number
    series_id: number
    _all: number
  }


  export type Invested_toAvgAggregateInputType = {
    id?: true
    partner_id?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
  }

  export type Invested_toSumAggregateInputType = {
    id?: true
    partner_id?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
  }

  export type Invested_toMinAggregateInputType = {
    id?: true
    partner_id?: true
    date?: true
    invested_startup?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
  }

  export type Invested_toMaxAggregateInputType = {
    id?: true
    partner_id?: true
    date?: true
    invested_startup?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
  }

  export type Invested_toCountAggregateInputType = {
    id?: true
    partner_id?: true
    date?: true
    invested_startup?: true
    invested_fund_id?: true
    corporate_value?: true
    series_id?: true
    _all?: true
  }

  export type Invested_toAggregateArgs = {
    /**
     * Filter which invested_to to aggregate.
    **/
    where?: invested_toWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of invested_tos to fetch.
    **/
    orderBy?: Enumerable<invested_toOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: invested_toWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invested_tos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invested_tos.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invested_tos
    **/
    count?: true | Invested_toCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Invested_toAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Invested_toSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Invested_toMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Invested_toMaxAggregateInputType
  }

  export type GetInvested_toAggregateType<T extends Invested_toAggregateArgs> = {
    [P in keyof T & keyof AggregateInvested_to]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvested_to[P]>
      : GetScalarType<T[P], AggregateInvested_to[P]>
  }



  export type invested_toSelect = {
    id?: boolean
    partner_id?: boolean
    date?: boolean
    invested_startup?: boolean
    invested_fund_id?: boolean
    corporate_value?: boolean
    series_id?: boolean
    investment_series?: boolean | investment_seriesArgs
    investment_funds?: boolean | investment_fundsArgs
    partners?: boolean | partnersArgs
  }

  export type invested_toInclude = {
    investment_series?: boolean | investment_seriesArgs
    investment_funds?: boolean | investment_fundsArgs
    partners?: boolean | partnersArgs
  }

  export type invested_toGetPayload<
    S extends boolean | null | undefined | invested_toArgs,
    U = keyof S
      > = S extends true
        ? invested_to
    : S extends undefined
    ? never
    : S extends invested_toArgs | invested_toFindManyArgs
    ?'include' extends U
    ? invested_to  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'investment_series'
        ? investment_seriesGetPayload<S['include'][P]> :
        P extends 'investment_funds'
        ? investment_fundsGetPayload<S['include'][P]> :
        P extends 'partners'
        ? partnersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof invested_to ?invested_to [P]
  : 
          P extends 'investment_series'
        ? investment_seriesGetPayload<S['select'][P]> :
        P extends 'investment_funds'
        ? investment_fundsGetPayload<S['select'][P]> :
        P extends 'partners'
        ? partnersGetPayload<S['select'][P]> : never
  } 
    : invested_to
  : invested_to


  type invested_toCountArgs = Merge<
    Omit<invested_toFindManyArgs, 'select' | 'include'> & {
      select?: Invested_toCountAggregateInputType | true
    }
  >

  export interface invested_toDelegate {
    /**
     * Find zero or one Invested_to that matches the filter.
     * @param {invested_toFindUniqueArgs} args - Arguments to find a Invested_to
     * @example
     * // Get one Invested_to
     * const invested_to = await prisma.invested_to.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends invested_toFindUniqueArgs>(
      args: SelectSubset<T, invested_toFindUniqueArgs>
    ): CheckSelect<T, Prisma__invested_toClient<invested_to | null>, Prisma__invested_toClient<invested_toGetPayload<T> | null>>

    /**
     * Find the first Invested_to that matches the filter.
     * @param {invested_toFindFirstArgs} args - Arguments to find a Invested_to
     * @example
     * // Get one Invested_to
     * const invested_to = await prisma.invested_to.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends invested_toFindFirstArgs>(
      args?: SelectSubset<T, invested_toFindFirstArgs>
    ): CheckSelect<T, Prisma__invested_toClient<invested_to | null>, Prisma__invested_toClient<invested_toGetPayload<T> | null>>

    /**
     * Find zero or more Invested_tos that matches the filter.
     * @param {invested_toFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invested_tos
     * const invested_tos = await prisma.invested_to.findMany()
     * 
     * // Get first 10 Invested_tos
     * const invested_tos = await prisma.invested_to.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invested_toWithIdOnly = await prisma.invested_to.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends invested_toFindManyArgs>(
      args?: SelectSubset<T, invested_toFindManyArgs>
    ): CheckSelect<T, Promise<Array<invested_to>>, Promise<Array<invested_toGetPayload<T>>>>

    /**
     * Create a Invested_to.
     * @param {invested_toCreateArgs} args - Arguments to create a Invested_to.
     * @example
     * // Create one Invested_to
     * const Invested_to = await prisma.invested_to.create({
     *   data: {
     *     // ... data to create a Invested_to
     *   }
     * })
     * 
    **/
    create<T extends invested_toCreateArgs>(
      args: SelectSubset<T, invested_toCreateArgs>
    ): CheckSelect<T, Prisma__invested_toClient<invested_to>, Prisma__invested_toClient<invested_toGetPayload<T>>>

    /**
     * Delete a Invested_to.
     * @param {invested_toDeleteArgs} args - Arguments to delete one Invested_to.
     * @example
     * // Delete one Invested_to
     * const Invested_to = await prisma.invested_to.delete({
     *   where: {
     *     // ... filter to delete one Invested_to
     *   }
     * })
     * 
    **/
    delete<T extends invested_toDeleteArgs>(
      args: SelectSubset<T, invested_toDeleteArgs>
    ): CheckSelect<T, Prisma__invested_toClient<invested_to>, Prisma__invested_toClient<invested_toGetPayload<T>>>

    /**
     * Update one Invested_to.
     * @param {invested_toUpdateArgs} args - Arguments to update one Invested_to.
     * @example
     * // Update one Invested_to
     * const invested_to = await prisma.invested_to.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends invested_toUpdateArgs>(
      args: SelectSubset<T, invested_toUpdateArgs>
    ): CheckSelect<T, Prisma__invested_toClient<invested_to>, Prisma__invested_toClient<invested_toGetPayload<T>>>

    /**
     * Delete zero or more Invested_tos.
     * @param {invested_toDeleteManyArgs} args - Arguments to filter Invested_tos to delete.
     * @example
     * // Delete a few Invested_tos
     * const { count } = await prisma.invested_to.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends invested_toDeleteManyArgs>(
      args?: SelectSubset<T, invested_toDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Invested_tos.
     * @param {invested_toUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invested_tos
     * const invested_to = await prisma.invested_to.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends invested_toUpdateManyArgs>(
      args: SelectSubset<T, invested_toUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Invested_to.
     * @param {invested_toUpsertArgs} args - Arguments to update or create a Invested_to.
     * @example
     * // Update or create a Invested_to
     * const invested_to = await prisma.invested_to.upsert({
     *   create: {
     *     // ... data to create a Invested_to
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invested_to we want to update
     *   }
     * })
    **/
    upsert<T extends invested_toUpsertArgs>(
      args: SelectSubset<T, invested_toUpsertArgs>
    ): CheckSelect<T, Prisma__invested_toClient<invested_to>, Prisma__invested_toClient<invested_toGetPayload<T>>>

    /**
     * Count the number of Invested_tos.
     * @param {invested_toCountArgs} args - Arguments to filter Invested_tos to count.
     * @example
     * // Count the number of Invested_tos
     * const count = await prisma.invested_to.count({
     *   where: {
     *     // ... the filter for the Invested_tos we want to count
     *   }
     * })
    **/
    count<T extends invested_toCountArgs>(
      args?: Subset<T, invested_toCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invested_toCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invested_to.
     * @param {Invested_toAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invested_toAggregateArgs>(args: Subset<T, Invested_toAggregateArgs>): Promise<GetInvested_toAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for invested_to.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__invested_toClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    investment_series<T extends investment_seriesArgs = {}>(args?: Subset<T, investment_seriesArgs>): CheckSelect<T, Prisma__investment_seriesClient<investment_series | null>, Prisma__investment_seriesClient<investment_seriesGetPayload<T> | null>>;

    investment_funds<T extends investment_fundsArgs = {}>(args?: Subset<T, investment_fundsArgs>): CheckSelect<T, Prisma__investment_fundsClient<investment_funds | null>, Prisma__investment_fundsClient<investment_fundsGetPayload<T> | null>>;

    partners<T extends partnersArgs = {}>(args?: Subset<T, partnersArgs>): CheckSelect<T, Prisma__partnersClient<partners | null>, Prisma__partnersClient<partnersGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * invested_to findUnique
   */
  export type invested_toFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the invested_to
    **/
    select?: invested_toSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_toInclude | null
    /**
     * Throw an Error if a invested_to can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which invested_to to fetch.
    **/
    where: invested_toWhereUniqueInput
  }


  /**
   * invested_to findFirst
   */
  export type invested_toFindFirstArgs = {
    /**
     * Select specific fields to fetch from the invested_to
    **/
    select?: invested_toSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_toInclude | null
    /**
     * Throw an Error if a invested_to can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which invested_to to fetch.
    **/
    where?: invested_toWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of invested_tos to fetch.
    **/
    orderBy?: Enumerable<invested_toOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invested_tos.
    **/
    cursor?: invested_toWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invested_tos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invested_tos.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of invested_tos.
    **/
    distinct?: Enumerable<Invested_toScalarFieldEnum>
  }


  /**
   * invested_to findMany
   */
  export type invested_toFindManyArgs = {
    /**
     * Select specific fields to fetch from the invested_to
    **/
    select?: invested_toSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_toInclude | null
    /**
     * Filter, which invested_tos to fetch.
    **/
    where?: invested_toWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of invested_tos to fetch.
    **/
    orderBy?: Enumerable<invested_toOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invested_tos.
    **/
    cursor?: invested_toWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invested_tos from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invested_tos.
    **/
    skip?: number
    distinct?: Enumerable<Invested_toScalarFieldEnum>
  }


  /**
   * invested_to create
   */
  export type invested_toCreateArgs = {
    /**
     * Select specific fields to fetch from the invested_to
    **/
    select?: invested_toSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_toInclude | null
    /**
     * The data needed to create a invested_to.
    **/
    data: XOR<invested_toUncheckedCreateInput, invested_toCreateInput>
  }


  /**
   * invested_to update
   */
  export type invested_toUpdateArgs = {
    /**
     * Select specific fields to fetch from the invested_to
    **/
    select?: invested_toSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_toInclude | null
    /**
     * The data needed to update a invested_to.
    **/
    data: XOR<invested_toUncheckedUpdateInput, invested_toUpdateInput>
    /**
     * Choose, which invested_to to update.
    **/
    where: invested_toWhereUniqueInput
  }


  /**
   * invested_to updateMany
   */
  export type invested_toUpdateManyArgs = {
    data: XOR<invested_toUncheckedUpdateManyInput, invested_toUpdateManyMutationInput>
    where?: invested_toWhereInput
  }


  /**
   * invested_to upsert
   */
  export type invested_toUpsertArgs = {
    /**
     * Select specific fields to fetch from the invested_to
    **/
    select?: invested_toSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_toInclude | null
    /**
     * The filter to search for the invested_to to update in case it exists.
    **/
    where: invested_toWhereUniqueInput
    /**
     * In case the invested_to found by the `where` argument doesn't exist, create a new invested_to with this data.
    **/
    create: XOR<invested_toUncheckedCreateInput, invested_toCreateInput>
    /**
     * In case the invested_to was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<invested_toUncheckedUpdateInput, invested_toUpdateInput>
  }


  /**
   * invested_to delete
   */
  export type invested_toDeleteArgs = {
    /**
     * Select specific fields to fetch from the invested_to
    **/
    select?: invested_toSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_toInclude | null
    /**
     * Filter which invested_to to delete.
    **/
    where: invested_toWhereUniqueInput
  }


  /**
   * invested_to deleteMany
   */
  export type invested_toDeleteManyArgs = {
    where?: invested_toWhereInput
  }


  /**
   * invested_to without action
   */
  export type invested_toArgs = {
    /**
     * Select specific fields to fetch from the invested_to
    **/
    select?: invested_toSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: invested_toInclude | null
  }



  /**
   * Model investment_funds
   */


  export type AggregateInvestment_funds = {
    count: Investment_fundsCountAggregateOutputType | null
    avg: Investment_fundsAvgAggregateOutputType | null
    sum: Investment_fundsSumAggregateOutputType | null
    min: Investment_fundsMinAggregateOutputType | null
    max: Investment_fundsMaxAggregateOutputType | null
  }

  export type Investment_fundsAvgAggregateOutputType = {
    id: number
  }

  export type Investment_fundsSumAggregateOutputType = {
    id: number
  }

  export type Investment_fundsMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Investment_fundsMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Investment_fundsCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type Investment_fundsAvgAggregateInputType = {
    id?: true
  }

  export type Investment_fundsSumAggregateInputType = {
    id?: true
  }

  export type Investment_fundsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Investment_fundsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Investment_fundsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Investment_fundsAggregateArgs = {
    /**
     * Filter which investment_funds to aggregate.
    **/
    where?: investment_fundsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_funds to fetch.
    **/
    orderBy?: Enumerable<investment_fundsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: investment_fundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_funds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_funds.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investment_funds
    **/
    count?: true | Investment_fundsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Investment_fundsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Investment_fundsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Investment_fundsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Investment_fundsMaxAggregateInputType
  }

  export type GetInvestment_fundsAggregateType<T extends Investment_fundsAggregateArgs> = {
    [P in keyof T & keyof AggregateInvestment_funds]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestment_funds[P]>
      : GetScalarType<T[P], AggregateInvestment_funds[P]>
  }



  export type investment_fundsSelect = {
    id?: boolean
    name?: boolean
    partners?: boolean | partnersFindManyArgs
    startups?: boolean | startupsFindManyArgs
    invested_from?: boolean | invested_fromFindManyArgs
    invested_to?: boolean | invested_toFindManyArgs
  }

  export type investment_fundsInclude = {
    partners?: boolean | partnersFindManyArgs
    startups?: boolean | startupsFindManyArgs
    invested_from?: boolean | invested_fromFindManyArgs
    invested_to?: boolean | invested_toFindManyArgs
  }

  export type investment_fundsGetPayload<
    S extends boolean | null | undefined | investment_fundsArgs,
    U = keyof S
      > = S extends true
        ? investment_funds
    : S extends undefined
    ? never
    : S extends investment_fundsArgs | investment_fundsFindManyArgs
    ?'include' extends U
    ? investment_funds  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'partners'
        ? Array < partnersGetPayload<S['include'][P]>>  :
        P extends 'startups'
        ? Array < startupsGetPayload<S['include'][P]>>  :
        P extends 'invested_from'
        ? Array < invested_fromGetPayload<S['include'][P]>>  :
        P extends 'invested_to'
        ? Array < invested_toGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof investment_funds ?investment_funds [P]
  : 
          P extends 'partners'
        ? Array < partnersGetPayload<S['select'][P]>>  :
        P extends 'startups'
        ? Array < startupsGetPayload<S['select'][P]>>  :
        P extends 'invested_from'
        ? Array < invested_fromGetPayload<S['select'][P]>>  :
        P extends 'invested_to'
        ? Array < invested_toGetPayload<S['select'][P]>>  : never
  } 
    : investment_funds
  : investment_funds


  type investment_fundsCountArgs = Merge<
    Omit<investment_fundsFindManyArgs, 'select' | 'include'> & {
      select?: Investment_fundsCountAggregateInputType | true
    }
  >

  export interface investment_fundsDelegate {
    /**
     * Find zero or one Investment_funds that matches the filter.
     * @param {investment_fundsFindUniqueArgs} args - Arguments to find a Investment_funds
     * @example
     * // Get one Investment_funds
     * const investment_funds = await prisma.investment_funds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends investment_fundsFindUniqueArgs>(
      args: SelectSubset<T, investment_fundsFindUniqueArgs>
    ): CheckSelect<T, Prisma__investment_fundsClient<investment_funds | null>, Prisma__investment_fundsClient<investment_fundsGetPayload<T> | null>>

    /**
     * Find the first Investment_funds that matches the filter.
     * @param {investment_fundsFindFirstArgs} args - Arguments to find a Investment_funds
     * @example
     * // Get one Investment_funds
     * const investment_funds = await prisma.investment_funds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends investment_fundsFindFirstArgs>(
      args?: SelectSubset<T, investment_fundsFindFirstArgs>
    ): CheckSelect<T, Prisma__investment_fundsClient<investment_funds | null>, Prisma__investment_fundsClient<investment_fundsGetPayload<T> | null>>

    /**
     * Find zero or more Investment_funds that matches the filter.
     * @param {investment_fundsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investment_funds
     * const investment_funds = await prisma.investment_funds.findMany()
     * 
     * // Get first 10 Investment_funds
     * const investment_funds = await prisma.investment_funds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investment_fundsWithIdOnly = await prisma.investment_funds.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends investment_fundsFindManyArgs>(
      args?: SelectSubset<T, investment_fundsFindManyArgs>
    ): CheckSelect<T, Promise<Array<investment_funds>>, Promise<Array<investment_fundsGetPayload<T>>>>

    /**
     * Create a Investment_funds.
     * @param {investment_fundsCreateArgs} args - Arguments to create a Investment_funds.
     * @example
     * // Create one Investment_funds
     * const Investment_funds = await prisma.investment_funds.create({
     *   data: {
     *     // ... data to create a Investment_funds
     *   }
     * })
     * 
    **/
    create<T extends investment_fundsCreateArgs>(
      args: SelectSubset<T, investment_fundsCreateArgs>
    ): CheckSelect<T, Prisma__investment_fundsClient<investment_funds>, Prisma__investment_fundsClient<investment_fundsGetPayload<T>>>

    /**
     * Delete a Investment_funds.
     * @param {investment_fundsDeleteArgs} args - Arguments to delete one Investment_funds.
     * @example
     * // Delete one Investment_funds
     * const Investment_funds = await prisma.investment_funds.delete({
     *   where: {
     *     // ... filter to delete one Investment_funds
     *   }
     * })
     * 
    **/
    delete<T extends investment_fundsDeleteArgs>(
      args: SelectSubset<T, investment_fundsDeleteArgs>
    ): CheckSelect<T, Prisma__investment_fundsClient<investment_funds>, Prisma__investment_fundsClient<investment_fundsGetPayload<T>>>

    /**
     * Update one Investment_funds.
     * @param {investment_fundsUpdateArgs} args - Arguments to update one Investment_funds.
     * @example
     * // Update one Investment_funds
     * const investment_funds = await prisma.investment_funds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends investment_fundsUpdateArgs>(
      args: SelectSubset<T, investment_fundsUpdateArgs>
    ): CheckSelect<T, Prisma__investment_fundsClient<investment_funds>, Prisma__investment_fundsClient<investment_fundsGetPayload<T>>>

    /**
     * Delete zero or more Investment_funds.
     * @param {investment_fundsDeleteManyArgs} args - Arguments to filter Investment_funds to delete.
     * @example
     * // Delete a few Investment_funds
     * const { count } = await prisma.investment_funds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends investment_fundsDeleteManyArgs>(
      args?: SelectSubset<T, investment_fundsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Investment_funds.
     * @param {investment_fundsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investment_funds
     * const investment_funds = await prisma.investment_funds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends investment_fundsUpdateManyArgs>(
      args: SelectSubset<T, investment_fundsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Investment_funds.
     * @param {investment_fundsUpsertArgs} args - Arguments to update or create a Investment_funds.
     * @example
     * // Update or create a Investment_funds
     * const investment_funds = await prisma.investment_funds.upsert({
     *   create: {
     *     // ... data to create a Investment_funds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investment_funds we want to update
     *   }
     * })
    **/
    upsert<T extends investment_fundsUpsertArgs>(
      args: SelectSubset<T, investment_fundsUpsertArgs>
    ): CheckSelect<T, Prisma__investment_fundsClient<investment_funds>, Prisma__investment_fundsClient<investment_fundsGetPayload<T>>>

    /**
     * Count the number of Investment_funds.
     * @param {investment_fundsCountArgs} args - Arguments to filter Investment_funds to count.
     * @example
     * // Count the number of Investment_funds
     * const count = await prisma.investment_funds.count({
     *   where: {
     *     // ... the filter for the Investment_funds we want to count
     *   }
     * })
    **/
    count<T extends investment_fundsCountArgs>(
      args?: Subset<T, investment_fundsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Investment_fundsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investment_funds.
     * @param {Investment_fundsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Investment_fundsAggregateArgs>(args: Subset<T, Investment_fundsAggregateArgs>): Promise<GetInvestment_fundsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for investment_funds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__investment_fundsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    partners<T extends partnersFindManyArgs = {}>(args?: Subset<T, partnersFindManyArgs>): CheckSelect<T, Promise<Array<partners>>, Promise<Array<partnersGetPayload<T>>>>;

    startups<T extends startupsFindManyArgs = {}>(args?: Subset<T, startupsFindManyArgs>): CheckSelect<T, Promise<Array<startups>>, Promise<Array<startupsGetPayload<T>>>>;

    invested_from<T extends invested_fromFindManyArgs = {}>(args?: Subset<T, invested_fromFindManyArgs>): CheckSelect<T, Promise<Array<invested_from>>, Promise<Array<invested_fromGetPayload<T>>>>;

    invested_to<T extends invested_toFindManyArgs = {}>(args?: Subset<T, invested_toFindManyArgs>): CheckSelect<T, Promise<Array<invested_to>>, Promise<Array<invested_toGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * investment_funds findUnique
   */
  export type investment_fundsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the investment_funds
    **/
    select?: investment_fundsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_fundsInclude | null
    /**
     * Throw an Error if a investment_funds can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which investment_funds to fetch.
    **/
    where: investment_fundsWhereUniqueInput
  }


  /**
   * investment_funds findFirst
   */
  export type investment_fundsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the investment_funds
    **/
    select?: investment_fundsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_fundsInclude | null
    /**
     * Throw an Error if a investment_funds can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which investment_funds to fetch.
    **/
    where?: investment_fundsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_funds to fetch.
    **/
    orderBy?: Enumerable<investment_fundsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investment_funds.
    **/
    cursor?: investment_fundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_funds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_funds.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of investment_funds.
    **/
    distinct?: Enumerable<Investment_fundsScalarFieldEnum>
  }


  /**
   * investment_funds findMany
   */
  export type investment_fundsFindManyArgs = {
    /**
     * Select specific fields to fetch from the investment_funds
    **/
    select?: investment_fundsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_fundsInclude | null
    /**
     * Filter, which investment_funds to fetch.
    **/
    where?: investment_fundsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_funds to fetch.
    **/
    orderBy?: Enumerable<investment_fundsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investment_funds.
    **/
    cursor?: investment_fundsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_funds from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_funds.
    **/
    skip?: number
    distinct?: Enumerable<Investment_fundsScalarFieldEnum>
  }


  /**
   * investment_funds create
   */
  export type investment_fundsCreateArgs = {
    /**
     * Select specific fields to fetch from the investment_funds
    **/
    select?: investment_fundsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_fundsInclude | null
    /**
     * The data needed to create a investment_funds.
    **/
    data: XOR<investment_fundsUncheckedCreateInput, investment_fundsCreateInput>
  }


  /**
   * investment_funds update
   */
  export type investment_fundsUpdateArgs = {
    /**
     * Select specific fields to fetch from the investment_funds
    **/
    select?: investment_fundsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_fundsInclude | null
    /**
     * The data needed to update a investment_funds.
    **/
    data: XOR<investment_fundsUncheckedUpdateInput, investment_fundsUpdateInput>
    /**
     * Choose, which investment_funds to update.
    **/
    where: investment_fundsWhereUniqueInput
  }


  /**
   * investment_funds updateMany
   */
  export type investment_fundsUpdateManyArgs = {
    data: XOR<investment_fundsUncheckedUpdateManyInput, investment_fundsUpdateManyMutationInput>
    where?: investment_fundsWhereInput
  }


  /**
   * investment_funds upsert
   */
  export type investment_fundsUpsertArgs = {
    /**
     * Select specific fields to fetch from the investment_funds
    **/
    select?: investment_fundsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_fundsInclude | null
    /**
     * The filter to search for the investment_funds to update in case it exists.
    **/
    where: investment_fundsWhereUniqueInput
    /**
     * In case the investment_funds found by the `where` argument doesn't exist, create a new investment_funds with this data.
    **/
    create: XOR<investment_fundsUncheckedCreateInput, investment_fundsCreateInput>
    /**
     * In case the investment_funds was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<investment_fundsUncheckedUpdateInput, investment_fundsUpdateInput>
  }


  /**
   * investment_funds delete
   */
  export type investment_fundsDeleteArgs = {
    /**
     * Select specific fields to fetch from the investment_funds
    **/
    select?: investment_fundsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_fundsInclude | null
    /**
     * Filter which investment_funds to delete.
    **/
    where: investment_fundsWhereUniqueInput
  }


  /**
   * investment_funds deleteMany
   */
  export type investment_fundsDeleteManyArgs = {
    where?: investment_fundsWhereInput
  }


  /**
   * investment_funds without action
   */
  export type investment_fundsArgs = {
    /**
     * Select specific fields to fetch from the investment_funds
    **/
    select?: investment_fundsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_fundsInclude | null
  }



  /**
   * Model investment_portfolio
   */


  export type AggregateInvestment_portfolio = {
    count: Investment_portfolioCountAggregateOutputType | null
    avg: Investment_portfolioAvgAggregateOutputType | null
    sum: Investment_portfolioSumAggregateOutputType | null
    min: Investment_portfolioMinAggregateOutputType | null
    max: Investment_portfolioMaxAggregateOutputType | null
  }

  export type Investment_portfolioAvgAggregateOutputType = {
    id: number
    partner_id: number
  }

  export type Investment_portfolioSumAggregateOutputType = {
    id: number
    partner_id: number
  }

  export type Investment_portfolioMinAggregateOutputType = {
    id: number
    partner_id: number
    img_url: string | null
  }

  export type Investment_portfolioMaxAggregateOutputType = {
    id: number
    partner_id: number
    img_url: string | null
  }

  export type Investment_portfolioCountAggregateOutputType = {
    id: number
    partner_id: number
    img_url: number | null
    _all: number
  }


  export type Investment_portfolioAvgAggregateInputType = {
    id?: true
    partner_id?: true
  }

  export type Investment_portfolioSumAggregateInputType = {
    id?: true
    partner_id?: true
  }

  export type Investment_portfolioMinAggregateInputType = {
    id?: true
    partner_id?: true
    img_url?: true
  }

  export type Investment_portfolioMaxAggregateInputType = {
    id?: true
    partner_id?: true
    img_url?: true
  }

  export type Investment_portfolioCountAggregateInputType = {
    id?: true
    partner_id?: true
    img_url?: true
    _all?: true
  }

  export type Investment_portfolioAggregateArgs = {
    /**
     * Filter which investment_portfolio to aggregate.
    **/
    where?: investment_portfolioWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_portfolios to fetch.
    **/
    orderBy?: Enumerable<investment_portfolioOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: investment_portfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_portfolios from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_portfolios.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investment_portfolios
    **/
    count?: true | Investment_portfolioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Investment_portfolioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Investment_portfolioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Investment_portfolioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Investment_portfolioMaxAggregateInputType
  }

  export type GetInvestment_portfolioAggregateType<T extends Investment_portfolioAggregateArgs> = {
    [P in keyof T & keyof AggregateInvestment_portfolio]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestment_portfolio[P]>
      : GetScalarType<T[P], AggregateInvestment_portfolio[P]>
  }



  export type investment_portfolioSelect = {
    id?: boolean
    partner_id?: boolean
    img_url?: boolean
    partners?: boolean | partnersArgs
  }

  export type investment_portfolioInclude = {
    partners?: boolean | partnersArgs
  }

  export type investment_portfolioGetPayload<
    S extends boolean | null | undefined | investment_portfolioArgs,
    U = keyof S
      > = S extends true
        ? investment_portfolio
    : S extends undefined
    ? never
    : S extends investment_portfolioArgs | investment_portfolioFindManyArgs
    ?'include' extends U
    ? investment_portfolio  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'partners'
        ? partnersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof investment_portfolio ?investment_portfolio [P]
  : 
          P extends 'partners'
        ? partnersGetPayload<S['select'][P]> : never
  } 
    : investment_portfolio
  : investment_portfolio


  type investment_portfolioCountArgs = Merge<
    Omit<investment_portfolioFindManyArgs, 'select' | 'include'> & {
      select?: Investment_portfolioCountAggregateInputType | true
    }
  >

  export interface investment_portfolioDelegate {
    /**
     * Find zero or one Investment_portfolio that matches the filter.
     * @param {investment_portfolioFindUniqueArgs} args - Arguments to find a Investment_portfolio
     * @example
     * // Get one Investment_portfolio
     * const investment_portfolio = await prisma.investment_portfolio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends investment_portfolioFindUniqueArgs>(
      args: SelectSubset<T, investment_portfolioFindUniqueArgs>
    ): CheckSelect<T, Prisma__investment_portfolioClient<investment_portfolio | null>, Prisma__investment_portfolioClient<investment_portfolioGetPayload<T> | null>>

    /**
     * Find the first Investment_portfolio that matches the filter.
     * @param {investment_portfolioFindFirstArgs} args - Arguments to find a Investment_portfolio
     * @example
     * // Get one Investment_portfolio
     * const investment_portfolio = await prisma.investment_portfolio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends investment_portfolioFindFirstArgs>(
      args?: SelectSubset<T, investment_portfolioFindFirstArgs>
    ): CheckSelect<T, Prisma__investment_portfolioClient<investment_portfolio | null>, Prisma__investment_portfolioClient<investment_portfolioGetPayload<T> | null>>

    /**
     * Find zero or more Investment_portfolios that matches the filter.
     * @param {investment_portfolioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investment_portfolios
     * const investment_portfolios = await prisma.investment_portfolio.findMany()
     * 
     * // Get first 10 Investment_portfolios
     * const investment_portfolios = await prisma.investment_portfolio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investment_portfolioWithIdOnly = await prisma.investment_portfolio.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends investment_portfolioFindManyArgs>(
      args?: SelectSubset<T, investment_portfolioFindManyArgs>
    ): CheckSelect<T, Promise<Array<investment_portfolio>>, Promise<Array<investment_portfolioGetPayload<T>>>>

    /**
     * Create a Investment_portfolio.
     * @param {investment_portfolioCreateArgs} args - Arguments to create a Investment_portfolio.
     * @example
     * // Create one Investment_portfolio
     * const Investment_portfolio = await prisma.investment_portfolio.create({
     *   data: {
     *     // ... data to create a Investment_portfolio
     *   }
     * })
     * 
    **/
    create<T extends investment_portfolioCreateArgs>(
      args: SelectSubset<T, investment_portfolioCreateArgs>
    ): CheckSelect<T, Prisma__investment_portfolioClient<investment_portfolio>, Prisma__investment_portfolioClient<investment_portfolioGetPayload<T>>>

    /**
     * Delete a Investment_portfolio.
     * @param {investment_portfolioDeleteArgs} args - Arguments to delete one Investment_portfolio.
     * @example
     * // Delete one Investment_portfolio
     * const Investment_portfolio = await prisma.investment_portfolio.delete({
     *   where: {
     *     // ... filter to delete one Investment_portfolio
     *   }
     * })
     * 
    **/
    delete<T extends investment_portfolioDeleteArgs>(
      args: SelectSubset<T, investment_portfolioDeleteArgs>
    ): CheckSelect<T, Prisma__investment_portfolioClient<investment_portfolio>, Prisma__investment_portfolioClient<investment_portfolioGetPayload<T>>>

    /**
     * Update one Investment_portfolio.
     * @param {investment_portfolioUpdateArgs} args - Arguments to update one Investment_portfolio.
     * @example
     * // Update one Investment_portfolio
     * const investment_portfolio = await prisma.investment_portfolio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends investment_portfolioUpdateArgs>(
      args: SelectSubset<T, investment_portfolioUpdateArgs>
    ): CheckSelect<T, Prisma__investment_portfolioClient<investment_portfolio>, Prisma__investment_portfolioClient<investment_portfolioGetPayload<T>>>

    /**
     * Delete zero or more Investment_portfolios.
     * @param {investment_portfolioDeleteManyArgs} args - Arguments to filter Investment_portfolios to delete.
     * @example
     * // Delete a few Investment_portfolios
     * const { count } = await prisma.investment_portfolio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends investment_portfolioDeleteManyArgs>(
      args?: SelectSubset<T, investment_portfolioDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Investment_portfolios.
     * @param {investment_portfolioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investment_portfolios
     * const investment_portfolio = await prisma.investment_portfolio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends investment_portfolioUpdateManyArgs>(
      args: SelectSubset<T, investment_portfolioUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Investment_portfolio.
     * @param {investment_portfolioUpsertArgs} args - Arguments to update or create a Investment_portfolio.
     * @example
     * // Update or create a Investment_portfolio
     * const investment_portfolio = await prisma.investment_portfolio.upsert({
     *   create: {
     *     // ... data to create a Investment_portfolio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investment_portfolio we want to update
     *   }
     * })
    **/
    upsert<T extends investment_portfolioUpsertArgs>(
      args: SelectSubset<T, investment_portfolioUpsertArgs>
    ): CheckSelect<T, Prisma__investment_portfolioClient<investment_portfolio>, Prisma__investment_portfolioClient<investment_portfolioGetPayload<T>>>

    /**
     * Count the number of Investment_portfolios.
     * @param {investment_portfolioCountArgs} args - Arguments to filter Investment_portfolios to count.
     * @example
     * // Count the number of Investment_portfolios
     * const count = await prisma.investment_portfolio.count({
     *   where: {
     *     // ... the filter for the Investment_portfolios we want to count
     *   }
     * })
    **/
    count<T extends investment_portfolioCountArgs>(
      args?: Subset<T, investment_portfolioCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Investment_portfolioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investment_portfolio.
     * @param {Investment_portfolioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Investment_portfolioAggregateArgs>(args: Subset<T, Investment_portfolioAggregateArgs>): Promise<GetInvestment_portfolioAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for investment_portfolio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__investment_portfolioClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    partners<T extends partnersArgs = {}>(args?: Subset<T, partnersArgs>): CheckSelect<T, Prisma__partnersClient<partners | null>, Prisma__partnersClient<partnersGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * investment_portfolio findUnique
   */
  export type investment_portfolioFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the investment_portfolio
    **/
    select?: investment_portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_portfolioInclude | null
    /**
     * Throw an Error if a investment_portfolio can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which investment_portfolio to fetch.
    **/
    where: investment_portfolioWhereUniqueInput
  }


  /**
   * investment_portfolio findFirst
   */
  export type investment_portfolioFindFirstArgs = {
    /**
     * Select specific fields to fetch from the investment_portfolio
    **/
    select?: investment_portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_portfolioInclude | null
    /**
     * Throw an Error if a investment_portfolio can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which investment_portfolio to fetch.
    **/
    where?: investment_portfolioWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_portfolios to fetch.
    **/
    orderBy?: Enumerable<investment_portfolioOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investment_portfolios.
    **/
    cursor?: investment_portfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_portfolios from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_portfolios.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of investment_portfolios.
    **/
    distinct?: Enumerable<Investment_portfolioScalarFieldEnum>
  }


  /**
   * investment_portfolio findMany
   */
  export type investment_portfolioFindManyArgs = {
    /**
     * Select specific fields to fetch from the investment_portfolio
    **/
    select?: investment_portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_portfolioInclude | null
    /**
     * Filter, which investment_portfolios to fetch.
    **/
    where?: investment_portfolioWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_portfolios to fetch.
    **/
    orderBy?: Enumerable<investment_portfolioOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investment_portfolios.
    **/
    cursor?: investment_portfolioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_portfolios from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_portfolios.
    **/
    skip?: number
    distinct?: Enumerable<Investment_portfolioScalarFieldEnum>
  }


  /**
   * investment_portfolio create
   */
  export type investment_portfolioCreateArgs = {
    /**
     * Select specific fields to fetch from the investment_portfolio
    **/
    select?: investment_portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_portfolioInclude | null
    /**
     * The data needed to create a investment_portfolio.
    **/
    data: XOR<investment_portfolioUncheckedCreateInput, investment_portfolioCreateInput>
  }


  /**
   * investment_portfolio update
   */
  export type investment_portfolioUpdateArgs = {
    /**
     * Select specific fields to fetch from the investment_portfolio
    **/
    select?: investment_portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_portfolioInclude | null
    /**
     * The data needed to update a investment_portfolio.
    **/
    data: XOR<investment_portfolioUncheckedUpdateInput, investment_portfolioUpdateInput>
    /**
     * Choose, which investment_portfolio to update.
    **/
    where: investment_portfolioWhereUniqueInput
  }


  /**
   * investment_portfolio updateMany
   */
  export type investment_portfolioUpdateManyArgs = {
    data: XOR<investment_portfolioUncheckedUpdateManyInput, investment_portfolioUpdateManyMutationInput>
    where?: investment_portfolioWhereInput
  }


  /**
   * investment_portfolio upsert
   */
  export type investment_portfolioUpsertArgs = {
    /**
     * Select specific fields to fetch from the investment_portfolio
    **/
    select?: investment_portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_portfolioInclude | null
    /**
     * The filter to search for the investment_portfolio to update in case it exists.
    **/
    where: investment_portfolioWhereUniqueInput
    /**
     * In case the investment_portfolio found by the `where` argument doesn't exist, create a new investment_portfolio with this data.
    **/
    create: XOR<investment_portfolioUncheckedCreateInput, investment_portfolioCreateInput>
    /**
     * In case the investment_portfolio was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<investment_portfolioUncheckedUpdateInput, investment_portfolioUpdateInput>
  }


  /**
   * investment_portfolio delete
   */
  export type investment_portfolioDeleteArgs = {
    /**
     * Select specific fields to fetch from the investment_portfolio
    **/
    select?: investment_portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_portfolioInclude | null
    /**
     * Filter which investment_portfolio to delete.
    **/
    where: investment_portfolioWhereUniqueInput
  }


  /**
   * investment_portfolio deleteMany
   */
  export type investment_portfolioDeleteManyArgs = {
    where?: investment_portfolioWhereInput
  }


  /**
   * investment_portfolio without action
   */
  export type investment_portfolioArgs = {
    /**
     * Select specific fields to fetch from the investment_portfolio
    **/
    select?: investment_portfolioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_portfolioInclude | null
  }



  /**
   * Model investment_series
   */


  export type AggregateInvestment_series = {
    count: Investment_seriesCountAggregateOutputType | null
    avg: Investment_seriesAvgAggregateOutputType | null
    sum: Investment_seriesSumAggregateOutputType | null
    min: Investment_seriesMinAggregateOutputType | null
    max: Investment_seriesMaxAggregateOutputType | null
  }

  export type Investment_seriesAvgAggregateOutputType = {
    id: number
  }

  export type Investment_seriesSumAggregateOutputType = {
    id: number
  }

  export type Investment_seriesMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Investment_seriesMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Investment_seriesCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type Investment_seriesAvgAggregateInputType = {
    id?: true
  }

  export type Investment_seriesSumAggregateInputType = {
    id?: true
  }

  export type Investment_seriesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Investment_seriesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Investment_seriesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Investment_seriesAggregateArgs = {
    /**
     * Filter which investment_series to aggregate.
    **/
    where?: investment_seriesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_series to fetch.
    **/
    orderBy?: Enumerable<investment_seriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: investment_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_series from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_series.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investment_series
    **/
    count?: true | Investment_seriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Investment_seriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Investment_seriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Investment_seriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Investment_seriesMaxAggregateInputType
  }

  export type GetInvestment_seriesAggregateType<T extends Investment_seriesAggregateArgs> = {
    [P in keyof T & keyof AggregateInvestment_series]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestment_series[P]>
      : GetScalarType<T[P], AggregateInvestment_series[P]>
  }



  export type investment_seriesSelect = {
    id?: boolean
    name?: boolean
    invested_from?: boolean | invested_fromFindManyArgs
    invested_to?: boolean | invested_toFindManyArgs
    startups?: boolean | startupsFindManyArgs
    wish_investment_series?: boolean | wish_investment_seriesFindManyArgs
  }

  export type investment_seriesInclude = {
    invested_from?: boolean | invested_fromFindManyArgs
    invested_to?: boolean | invested_toFindManyArgs
    startups?: boolean | startupsFindManyArgs
    wish_investment_series?: boolean | wish_investment_seriesFindManyArgs
  }

  export type investment_seriesGetPayload<
    S extends boolean | null | undefined | investment_seriesArgs,
    U = keyof S
      > = S extends true
        ? investment_series
    : S extends undefined
    ? never
    : S extends investment_seriesArgs | investment_seriesFindManyArgs
    ?'include' extends U
    ? investment_series  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'invested_from'
        ? Array < invested_fromGetPayload<S['include'][P]>>  :
        P extends 'invested_to'
        ? Array < invested_toGetPayload<S['include'][P]>>  :
        P extends 'startups'
        ? Array < startupsGetPayload<S['include'][P]>>  :
        P extends 'wish_investment_series'
        ? Array < wish_investment_seriesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof investment_series ?investment_series [P]
  : 
          P extends 'invested_from'
        ? Array < invested_fromGetPayload<S['select'][P]>>  :
        P extends 'invested_to'
        ? Array < invested_toGetPayload<S['select'][P]>>  :
        P extends 'startups'
        ? Array < startupsGetPayload<S['select'][P]>>  :
        P extends 'wish_investment_series'
        ? Array < wish_investment_seriesGetPayload<S['select'][P]>>  : never
  } 
    : investment_series
  : investment_series


  type investment_seriesCountArgs = Merge<
    Omit<investment_seriesFindManyArgs, 'select' | 'include'> & {
      select?: Investment_seriesCountAggregateInputType | true
    }
  >

  export interface investment_seriesDelegate {
    /**
     * Find zero or one Investment_series that matches the filter.
     * @param {investment_seriesFindUniqueArgs} args - Arguments to find a Investment_series
     * @example
     * // Get one Investment_series
     * const investment_series = await prisma.investment_series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends investment_seriesFindUniqueArgs>(
      args: SelectSubset<T, investment_seriesFindUniqueArgs>
    ): CheckSelect<T, Prisma__investment_seriesClient<investment_series | null>, Prisma__investment_seriesClient<investment_seriesGetPayload<T> | null>>

    /**
     * Find the first Investment_series that matches the filter.
     * @param {investment_seriesFindFirstArgs} args - Arguments to find a Investment_series
     * @example
     * // Get one Investment_series
     * const investment_series = await prisma.investment_series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends investment_seriesFindFirstArgs>(
      args?: SelectSubset<T, investment_seriesFindFirstArgs>
    ): CheckSelect<T, Prisma__investment_seriesClient<investment_series | null>, Prisma__investment_seriesClient<investment_seriesGetPayload<T> | null>>

    /**
     * Find zero or more Investment_series that matches the filter.
     * @param {investment_seriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investment_series
     * const investment_series = await prisma.investment_series.findMany()
     * 
     * // Get first 10 Investment_series
     * const investment_series = await prisma.investment_series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investment_seriesWithIdOnly = await prisma.investment_series.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends investment_seriesFindManyArgs>(
      args?: SelectSubset<T, investment_seriesFindManyArgs>
    ): CheckSelect<T, Promise<Array<investment_series>>, Promise<Array<investment_seriesGetPayload<T>>>>

    /**
     * Create a Investment_series.
     * @param {investment_seriesCreateArgs} args - Arguments to create a Investment_series.
     * @example
     * // Create one Investment_series
     * const Investment_series = await prisma.investment_series.create({
     *   data: {
     *     // ... data to create a Investment_series
     *   }
     * })
     * 
    **/
    create<T extends investment_seriesCreateArgs>(
      args: SelectSubset<T, investment_seriesCreateArgs>
    ): CheckSelect<T, Prisma__investment_seriesClient<investment_series>, Prisma__investment_seriesClient<investment_seriesGetPayload<T>>>

    /**
     * Delete a Investment_series.
     * @param {investment_seriesDeleteArgs} args - Arguments to delete one Investment_series.
     * @example
     * // Delete one Investment_series
     * const Investment_series = await prisma.investment_series.delete({
     *   where: {
     *     // ... filter to delete one Investment_series
     *   }
     * })
     * 
    **/
    delete<T extends investment_seriesDeleteArgs>(
      args: SelectSubset<T, investment_seriesDeleteArgs>
    ): CheckSelect<T, Prisma__investment_seriesClient<investment_series>, Prisma__investment_seriesClient<investment_seriesGetPayload<T>>>

    /**
     * Update one Investment_series.
     * @param {investment_seriesUpdateArgs} args - Arguments to update one Investment_series.
     * @example
     * // Update one Investment_series
     * const investment_series = await prisma.investment_series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends investment_seriesUpdateArgs>(
      args: SelectSubset<T, investment_seriesUpdateArgs>
    ): CheckSelect<T, Prisma__investment_seriesClient<investment_series>, Prisma__investment_seriesClient<investment_seriesGetPayload<T>>>

    /**
     * Delete zero or more Investment_series.
     * @param {investment_seriesDeleteManyArgs} args - Arguments to filter Investment_series to delete.
     * @example
     * // Delete a few Investment_series
     * const { count } = await prisma.investment_series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends investment_seriesDeleteManyArgs>(
      args?: SelectSubset<T, investment_seriesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Investment_series.
     * @param {investment_seriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investment_series
     * const investment_series = await prisma.investment_series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends investment_seriesUpdateManyArgs>(
      args: SelectSubset<T, investment_seriesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Investment_series.
     * @param {investment_seriesUpsertArgs} args - Arguments to update or create a Investment_series.
     * @example
     * // Update or create a Investment_series
     * const investment_series = await prisma.investment_series.upsert({
     *   create: {
     *     // ... data to create a Investment_series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investment_series we want to update
     *   }
     * })
    **/
    upsert<T extends investment_seriesUpsertArgs>(
      args: SelectSubset<T, investment_seriesUpsertArgs>
    ): CheckSelect<T, Prisma__investment_seriesClient<investment_series>, Prisma__investment_seriesClient<investment_seriesGetPayload<T>>>

    /**
     * Count the number of Investment_series.
     * @param {investment_seriesCountArgs} args - Arguments to filter Investment_series to count.
     * @example
     * // Count the number of Investment_series
     * const count = await prisma.investment_series.count({
     *   where: {
     *     // ... the filter for the Investment_series we want to count
     *   }
     * })
    **/
    count<T extends investment_seriesCountArgs>(
      args?: Subset<T, investment_seriesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Investment_seriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investment_series.
     * @param {Investment_seriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Investment_seriesAggregateArgs>(args: Subset<T, Investment_seriesAggregateArgs>): Promise<GetInvestment_seriesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for investment_series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__investment_seriesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    invested_from<T extends invested_fromFindManyArgs = {}>(args?: Subset<T, invested_fromFindManyArgs>): CheckSelect<T, Promise<Array<invested_from>>, Promise<Array<invested_fromGetPayload<T>>>>;

    invested_to<T extends invested_toFindManyArgs = {}>(args?: Subset<T, invested_toFindManyArgs>): CheckSelect<T, Promise<Array<invested_to>>, Promise<Array<invested_toGetPayload<T>>>>;

    startups<T extends startupsFindManyArgs = {}>(args?: Subset<T, startupsFindManyArgs>): CheckSelect<T, Promise<Array<startups>>, Promise<Array<startupsGetPayload<T>>>>;

    wish_investment_series<T extends wish_investment_seriesFindManyArgs = {}>(args?: Subset<T, wish_investment_seriesFindManyArgs>): CheckSelect<T, Promise<Array<wish_investment_series>>, Promise<Array<wish_investment_seriesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * investment_series findUnique
   */
  export type investment_seriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the investment_series
    **/
    select?: investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_seriesInclude | null
    /**
     * Throw an Error if a investment_series can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which investment_series to fetch.
    **/
    where: investment_seriesWhereUniqueInput
  }


  /**
   * investment_series findFirst
   */
  export type investment_seriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the investment_series
    **/
    select?: investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_seriesInclude | null
    /**
     * Throw an Error if a investment_series can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which investment_series to fetch.
    **/
    where?: investment_seriesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_series to fetch.
    **/
    orderBy?: Enumerable<investment_seriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investment_series.
    **/
    cursor?: investment_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_series from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_series.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of investment_series.
    **/
    distinct?: Enumerable<Investment_seriesScalarFieldEnum>
  }


  /**
   * investment_series findMany
   */
  export type investment_seriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the investment_series
    **/
    select?: investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_seriesInclude | null
    /**
     * Filter, which investment_series to fetch.
    **/
    where?: investment_seriesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of investment_series to fetch.
    **/
    orderBy?: Enumerable<investment_seriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investment_series.
    **/
    cursor?: investment_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investment_series from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investment_series.
    **/
    skip?: number
    distinct?: Enumerable<Investment_seriesScalarFieldEnum>
  }


  /**
   * investment_series create
   */
  export type investment_seriesCreateArgs = {
    /**
     * Select specific fields to fetch from the investment_series
    **/
    select?: investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_seriesInclude | null
    /**
     * The data needed to create a investment_series.
    **/
    data: XOR<investment_seriesUncheckedCreateInput, investment_seriesCreateInput>
  }


  /**
   * investment_series update
   */
  export type investment_seriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the investment_series
    **/
    select?: investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_seriesInclude | null
    /**
     * The data needed to update a investment_series.
    **/
    data: XOR<investment_seriesUncheckedUpdateInput, investment_seriesUpdateInput>
    /**
     * Choose, which investment_series to update.
    **/
    where: investment_seriesWhereUniqueInput
  }


  /**
   * investment_series updateMany
   */
  export type investment_seriesUpdateManyArgs = {
    data: XOR<investment_seriesUncheckedUpdateManyInput, investment_seriesUpdateManyMutationInput>
    where?: investment_seriesWhereInput
  }


  /**
   * investment_series upsert
   */
  export type investment_seriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the investment_series
    **/
    select?: investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_seriesInclude | null
    /**
     * The filter to search for the investment_series to update in case it exists.
    **/
    where: investment_seriesWhereUniqueInput
    /**
     * In case the investment_series found by the `where` argument doesn't exist, create a new investment_series with this data.
    **/
    create: XOR<investment_seriesUncheckedCreateInput, investment_seriesCreateInput>
    /**
     * In case the investment_series was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<investment_seriesUncheckedUpdateInput, investment_seriesUpdateInput>
  }


  /**
   * investment_series delete
   */
  export type investment_seriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the investment_series
    **/
    select?: investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_seriesInclude | null
    /**
     * Filter which investment_series to delete.
    **/
    where: investment_seriesWhereUniqueInput
  }


  /**
   * investment_series deleteMany
   */
  export type investment_seriesDeleteManyArgs = {
    where?: investment_seriesWhereInput
  }


  /**
   * investment_series without action
   */
  export type investment_seriesArgs = {
    /**
     * Select specific fields to fetch from the investment_series
    **/
    select?: investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: investment_seriesInclude | null
  }



  /**
   * Model IR_requests
   */


  export type AggregateIR_requests = {
    count: IR_requestsCountAggregateOutputType | null
    avg: IR_requestsAvgAggregateOutputType | null
    sum: IR_requestsSumAggregateOutputType | null
    min: IR_requestsMinAggregateOutputType | null
    max: IR_requestsMaxAggregateOutputType | null
  }

  export type IR_requestsAvgAggregateOutputType = {
    id: number
    startup_id: number
    partner_id: number
    document_id: number | null
    is_checked: number
    from_partner: number
    companiesId: number | null
  }

  export type IR_requestsSumAggregateOutputType = {
    id: number
    startup_id: number
    partner_id: number
    document_id: number | null
    is_checked: number
    from_partner: number
    companiesId: number | null
  }

  export type IR_requestsMinAggregateOutputType = {
    id: number
    startup_id: number
    partner_id: number
    document_id: number | null
    is_checked: number
    from_partner: number
    created_at: Date | null
    updated_at: Date | null
    companiesId: number | null
  }

  export type IR_requestsMaxAggregateOutputType = {
    id: number
    startup_id: number
    partner_id: number
    document_id: number | null
    is_checked: number
    from_partner: number
    created_at: Date | null
    updated_at: Date | null
    companiesId: number | null
  }

  export type IR_requestsCountAggregateOutputType = {
    id: number
    startup_id: number
    partner_id: number
    document_id: number | null
    is_checked: number
    from_partner: number
    created_at: number | null
    updated_at: number | null
    companiesId: number | null
    _all: number
  }


  export type IR_requestsAvgAggregateInputType = {
    id?: true
    startup_id?: true
    partner_id?: true
    document_id?: true
    is_checked?: true
    from_partner?: true
    companiesId?: true
  }

  export type IR_requestsSumAggregateInputType = {
    id?: true
    startup_id?: true
    partner_id?: true
    document_id?: true
    is_checked?: true
    from_partner?: true
    companiesId?: true
  }

  export type IR_requestsMinAggregateInputType = {
    id?: true
    startup_id?: true
    partner_id?: true
    document_id?: true
    is_checked?: true
    from_partner?: true
    created_at?: true
    updated_at?: true
    companiesId?: true
  }

  export type IR_requestsMaxAggregateInputType = {
    id?: true
    startup_id?: true
    partner_id?: true
    document_id?: true
    is_checked?: true
    from_partner?: true
    created_at?: true
    updated_at?: true
    companiesId?: true
  }

  export type IR_requestsCountAggregateInputType = {
    id?: true
    startup_id?: true
    partner_id?: true
    document_id?: true
    is_checked?: true
    from_partner?: true
    created_at?: true
    updated_at?: true
    companiesId?: true
    _all?: true
  }

  export type IR_requestsAggregateArgs = {
    /**
     * Filter which IR_requests to aggregate.
    **/
    where?: IR_requestsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of IR_requests to fetch.
    **/
    orderBy?: Enumerable<IR_requestsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: IR_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IR_requests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IR_requests.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IR_requests
    **/
    count?: true | IR_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: IR_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: IR_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: IR_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: IR_requestsMaxAggregateInputType
  }

  export type GetIR_requestsAggregateType<T extends IR_requestsAggregateArgs> = {
    [P in keyof T & keyof AggregateIR_requests]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIR_requests[P]>
      : GetScalarType<T[P], AggregateIR_requests[P]>
  }



  export type IR_requestsSelect = {
    id?: boolean
    startup_id?: boolean
    partner_id?: boolean
    document_id?: boolean
    is_checked?: boolean
    from_partner?: boolean
    created_at?: boolean
    updated_at?: boolean
    company_documents?: boolean | company_documentsArgs
    partners?: boolean | partnersArgs
    startups?: boolean | startupsArgs
    companies?: boolean | companiesArgs
    companiesId?: boolean
  }

  export type IR_requestsInclude = {
    company_documents?: boolean | company_documentsArgs
    partners?: boolean | partnersArgs
    startups?: boolean | startupsArgs
    companies?: boolean | companiesArgs
  }

  export type IR_requestsGetPayload<
    S extends boolean | null | undefined | IR_requestsArgs,
    U = keyof S
      > = S extends true
        ? IR_requests
    : S extends undefined
    ? never
    : S extends IR_requestsArgs | IR_requestsFindManyArgs
    ?'include' extends U
    ? IR_requests  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'company_documents'
        ? company_documentsGetPayload<S['include'][P]> | null :
        P extends 'partners'
        ? partnersGetPayload<S['include'][P]> :
        P extends 'startups'
        ? startupsGetPayload<S['include'][P]> :
        P extends 'companies'
        ? companiesGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof IR_requests ?IR_requests [P]
  : 
          P extends 'company_documents'
        ? company_documentsGetPayload<S['select'][P]> | null :
        P extends 'partners'
        ? partnersGetPayload<S['select'][P]> :
        P extends 'startups'
        ? startupsGetPayload<S['select'][P]> :
        P extends 'companies'
        ? companiesGetPayload<S['select'][P]> | null : never
  } 
    : IR_requests
  : IR_requests


  type IR_requestsCountArgs = Merge<
    Omit<IR_requestsFindManyArgs, 'select' | 'include'> & {
      select?: IR_requestsCountAggregateInputType | true
    }
  >

  export interface IR_requestsDelegate {
    /**
     * Find zero or one IR_requests that matches the filter.
     * @param {IR_requestsFindUniqueArgs} args - Arguments to find a IR_requests
     * @example
     * // Get one IR_requests
     * const iR_requests = await prisma.iR_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IR_requestsFindUniqueArgs>(
      args: SelectSubset<T, IR_requestsFindUniqueArgs>
    ): CheckSelect<T, Prisma__IR_requestsClient<IR_requests | null>, Prisma__IR_requestsClient<IR_requestsGetPayload<T> | null>>

    /**
     * Find the first IR_requests that matches the filter.
     * @param {IR_requestsFindFirstArgs} args - Arguments to find a IR_requests
     * @example
     * // Get one IR_requests
     * const iR_requests = await prisma.iR_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IR_requestsFindFirstArgs>(
      args?: SelectSubset<T, IR_requestsFindFirstArgs>
    ): CheckSelect<T, Prisma__IR_requestsClient<IR_requests | null>, Prisma__IR_requestsClient<IR_requestsGetPayload<T> | null>>

    /**
     * Find zero or more IR_requests that matches the filter.
     * @param {IR_requestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IR_requests
     * const iR_requests = await prisma.iR_requests.findMany()
     * 
     * // Get first 10 IR_requests
     * const iR_requests = await prisma.iR_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iR_requestsWithIdOnly = await prisma.iR_requests.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IR_requestsFindManyArgs>(
      args?: SelectSubset<T, IR_requestsFindManyArgs>
    ): CheckSelect<T, Promise<Array<IR_requests>>, Promise<Array<IR_requestsGetPayload<T>>>>

    /**
     * Create a IR_requests.
     * @param {IR_requestsCreateArgs} args - Arguments to create a IR_requests.
     * @example
     * // Create one IR_requests
     * const IR_requests = await prisma.iR_requests.create({
     *   data: {
     *     // ... data to create a IR_requests
     *   }
     * })
     * 
    **/
    create<T extends IR_requestsCreateArgs>(
      args: SelectSubset<T, IR_requestsCreateArgs>
    ): CheckSelect<T, Prisma__IR_requestsClient<IR_requests>, Prisma__IR_requestsClient<IR_requestsGetPayload<T>>>

    /**
     * Delete a IR_requests.
     * @param {IR_requestsDeleteArgs} args - Arguments to delete one IR_requests.
     * @example
     * // Delete one IR_requests
     * const IR_requests = await prisma.iR_requests.delete({
     *   where: {
     *     // ... filter to delete one IR_requests
     *   }
     * })
     * 
    **/
    delete<T extends IR_requestsDeleteArgs>(
      args: SelectSubset<T, IR_requestsDeleteArgs>
    ): CheckSelect<T, Prisma__IR_requestsClient<IR_requests>, Prisma__IR_requestsClient<IR_requestsGetPayload<T>>>

    /**
     * Update one IR_requests.
     * @param {IR_requestsUpdateArgs} args - Arguments to update one IR_requests.
     * @example
     * // Update one IR_requests
     * const iR_requests = await prisma.iR_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IR_requestsUpdateArgs>(
      args: SelectSubset<T, IR_requestsUpdateArgs>
    ): CheckSelect<T, Prisma__IR_requestsClient<IR_requests>, Prisma__IR_requestsClient<IR_requestsGetPayload<T>>>

    /**
     * Delete zero or more IR_requests.
     * @param {IR_requestsDeleteManyArgs} args - Arguments to filter IR_requests to delete.
     * @example
     * // Delete a few IR_requests
     * const { count } = await prisma.iR_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IR_requestsDeleteManyArgs>(
      args?: SelectSubset<T, IR_requestsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more IR_requests.
     * @param {IR_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IR_requests
     * const iR_requests = await prisma.iR_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IR_requestsUpdateManyArgs>(
      args: SelectSubset<T, IR_requestsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one IR_requests.
     * @param {IR_requestsUpsertArgs} args - Arguments to update or create a IR_requests.
     * @example
     * // Update or create a IR_requests
     * const iR_requests = await prisma.iR_requests.upsert({
     *   create: {
     *     // ... data to create a IR_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IR_requests we want to update
     *   }
     * })
    **/
    upsert<T extends IR_requestsUpsertArgs>(
      args: SelectSubset<T, IR_requestsUpsertArgs>
    ): CheckSelect<T, Prisma__IR_requestsClient<IR_requests>, Prisma__IR_requestsClient<IR_requestsGetPayload<T>>>

    /**
     * Count the number of IR_requests.
     * @param {IR_requestsCountArgs} args - Arguments to filter IR_requests to count.
     * @example
     * // Count the number of IR_requests
     * const count = await prisma.iR_requests.count({
     *   where: {
     *     // ... the filter for the IR_requests we want to count
     *   }
     * })
    **/
    count<T extends IR_requestsCountArgs>(
      args?: Subset<T, IR_requestsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IR_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IR_requests.
     * @param {IR_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IR_requestsAggregateArgs>(args: Subset<T, IR_requestsAggregateArgs>): Promise<GetIR_requestsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for IR_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IR_requestsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    company_documents<T extends company_documentsArgs = {}>(args?: Subset<T, company_documentsArgs>): CheckSelect<T, Prisma__company_documentsClient<company_documents | null>, Prisma__company_documentsClient<company_documentsGetPayload<T> | null>>;

    partners<T extends partnersArgs = {}>(args?: Subset<T, partnersArgs>): CheckSelect<T, Prisma__partnersClient<partners | null>, Prisma__partnersClient<partnersGetPayload<T> | null>>;

    startups<T extends startupsArgs = {}>(args?: Subset<T, startupsArgs>): CheckSelect<T, Prisma__startupsClient<startups | null>, Prisma__startupsClient<startupsGetPayload<T> | null>>;

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * IR_requests findUnique
   */
  export type IR_requestsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the IR_requests
    **/
    select?: IR_requestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IR_requestsInclude | null
    /**
     * Throw an Error if a IR_requests can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IR_requests to fetch.
    **/
    where: IR_requestsWhereUniqueInput
  }


  /**
   * IR_requests findFirst
   */
  export type IR_requestsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the IR_requests
    **/
    select?: IR_requestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IR_requestsInclude | null
    /**
     * Throw an Error if a IR_requests can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which IR_requests to fetch.
    **/
    where?: IR_requestsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of IR_requests to fetch.
    **/
    orderBy?: Enumerable<IR_requestsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IR_requests.
    **/
    cursor?: IR_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IR_requests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IR_requests.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of IR_requests.
    **/
    distinct?: Enumerable<IR_requestsScalarFieldEnum>
  }


  /**
   * IR_requests findMany
   */
  export type IR_requestsFindManyArgs = {
    /**
     * Select specific fields to fetch from the IR_requests
    **/
    select?: IR_requestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IR_requestsInclude | null
    /**
     * Filter, which IR_requests to fetch.
    **/
    where?: IR_requestsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of IR_requests to fetch.
    **/
    orderBy?: Enumerable<IR_requestsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IR_requests.
    **/
    cursor?: IR_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IR_requests from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IR_requests.
    **/
    skip?: number
    distinct?: Enumerable<IR_requestsScalarFieldEnum>
  }


  /**
   * IR_requests create
   */
  export type IR_requestsCreateArgs = {
    /**
     * Select specific fields to fetch from the IR_requests
    **/
    select?: IR_requestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IR_requestsInclude | null
    /**
     * The data needed to create a IR_requests.
    **/
    data: XOR<IR_requestsUncheckedCreateInput, IR_requestsCreateInput>
  }


  /**
   * IR_requests update
   */
  export type IR_requestsUpdateArgs = {
    /**
     * Select specific fields to fetch from the IR_requests
    **/
    select?: IR_requestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IR_requestsInclude | null
    /**
     * The data needed to update a IR_requests.
    **/
    data: XOR<IR_requestsUncheckedUpdateInput, IR_requestsUpdateInput>
    /**
     * Choose, which IR_requests to update.
    **/
    where: IR_requestsWhereUniqueInput
  }


  /**
   * IR_requests updateMany
   */
  export type IR_requestsUpdateManyArgs = {
    data: XOR<IR_requestsUncheckedUpdateManyInput, IR_requestsUpdateManyMutationInput>
    where?: IR_requestsWhereInput
  }


  /**
   * IR_requests upsert
   */
  export type IR_requestsUpsertArgs = {
    /**
     * Select specific fields to fetch from the IR_requests
    **/
    select?: IR_requestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IR_requestsInclude | null
    /**
     * The filter to search for the IR_requests to update in case it exists.
    **/
    where: IR_requestsWhereUniqueInput
    /**
     * In case the IR_requests found by the `where` argument doesn't exist, create a new IR_requests with this data.
    **/
    create: XOR<IR_requestsUncheckedCreateInput, IR_requestsCreateInput>
    /**
     * In case the IR_requests was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<IR_requestsUncheckedUpdateInput, IR_requestsUpdateInput>
  }


  /**
   * IR_requests delete
   */
  export type IR_requestsDeleteArgs = {
    /**
     * Select specific fields to fetch from the IR_requests
    **/
    select?: IR_requestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IR_requestsInclude | null
    /**
     * Filter which IR_requests to delete.
    **/
    where: IR_requestsWhereUniqueInput
  }


  /**
   * IR_requests deleteMany
   */
  export type IR_requestsDeleteManyArgs = {
    where?: IR_requestsWhereInput
  }


  /**
   * IR_requests without action
   */
  export type IR_requestsArgs = {
    /**
     * Select specific fields to fetch from the IR_requests
    **/
    select?: IR_requestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: IR_requestsInclude | null
  }



  /**
   * Model participants
   */


  export type AggregateParticipants = {
    count: ParticipantsCountAggregateOutputType | null
    avg: ParticipantsAvgAggregateOutputType | null
    sum: ParticipantsSumAggregateOutputType | null
    min: ParticipantsMinAggregateOutputType | null
    max: ParticipantsMaxAggregateOutputType | null
  }

  export type ParticipantsAvgAggregateOutputType = {
    id: number
    demoday_id: number
    order: number
    company_id: number
  }

  export type ParticipantsSumAggregateOutputType = {
    id: number
    demoday_id: number
    order: number
    company_id: number
  }

  export type ParticipantsMinAggregateOutputType = {
    id: number
    demoday_id: number
    order: number
    company_id: number
  }

  export type ParticipantsMaxAggregateOutputType = {
    id: number
    demoday_id: number
    order: number
    company_id: number
  }

  export type ParticipantsCountAggregateOutputType = {
    id: number
    demoday_id: number
    order: number
    company_id: number
    _all: number
  }


  export type ParticipantsAvgAggregateInputType = {
    id?: true
    demoday_id?: true
    order?: true
    company_id?: true
  }

  export type ParticipantsSumAggregateInputType = {
    id?: true
    demoday_id?: true
    order?: true
    company_id?: true
  }

  export type ParticipantsMinAggregateInputType = {
    id?: true
    demoday_id?: true
    order?: true
    company_id?: true
  }

  export type ParticipantsMaxAggregateInputType = {
    id?: true
    demoday_id?: true
    order?: true
    company_id?: true
  }

  export type ParticipantsCountAggregateInputType = {
    id?: true
    demoday_id?: true
    order?: true
    company_id?: true
    _all?: true
  }

  export type ParticipantsAggregateArgs = {
    /**
     * Filter which participants to aggregate.
    **/
    where?: participantsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of participants to fetch.
    **/
    orderBy?: Enumerable<participantsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` participants from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` participants.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned participants
    **/
    count?: true | ParticipantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ParticipantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ParticipantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ParticipantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ParticipantsMaxAggregateInputType
  }

  export type GetParticipantsAggregateType<T extends ParticipantsAggregateArgs> = {
    [P in keyof T & keyof AggregateParticipants]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipants[P]>
      : GetScalarType<T[P], AggregateParticipants[P]>
  }



  export type participantsSelect = {
    id?: boolean
    demoday_id?: boolean
    order?: boolean
    company_id?: boolean
    companies?: boolean | companiesArgs
    demodays?: boolean | demodaysArgs
    votes?: boolean | votesFindManyArgs
  }

  export type participantsInclude = {
    companies?: boolean | companiesArgs
    demodays?: boolean | demodaysArgs
    votes?: boolean | votesFindManyArgs
  }

  export type participantsGetPayload<
    S extends boolean | null | undefined | participantsArgs,
    U = keyof S
      > = S extends true
        ? participants
    : S extends undefined
    ? never
    : S extends participantsArgs | participantsFindManyArgs
    ?'include' extends U
    ? participants  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'demodays'
        ? demodaysGetPayload<S['include'][P]> :
        P extends 'votes'
        ? Array < votesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof participants ?participants [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'demodays'
        ? demodaysGetPayload<S['select'][P]> :
        P extends 'votes'
        ? Array < votesGetPayload<S['select'][P]>>  : never
  } 
    : participants
  : participants


  type participantsCountArgs = Merge<
    Omit<participantsFindManyArgs, 'select' | 'include'> & {
      select?: ParticipantsCountAggregateInputType | true
    }
  >

  export interface participantsDelegate {
    /**
     * Find zero or one Participants that matches the filter.
     * @param {participantsFindUniqueArgs} args - Arguments to find a Participants
     * @example
     * // Get one Participants
     * const participants = await prisma.participants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends participantsFindUniqueArgs>(
      args: SelectSubset<T, participantsFindUniqueArgs>
    ): CheckSelect<T, Prisma__participantsClient<participants | null>, Prisma__participantsClient<participantsGetPayload<T> | null>>

    /**
     * Find the first Participants that matches the filter.
     * @param {participantsFindFirstArgs} args - Arguments to find a Participants
     * @example
     * // Get one Participants
     * const participants = await prisma.participants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends participantsFindFirstArgs>(
      args?: SelectSubset<T, participantsFindFirstArgs>
    ): CheckSelect<T, Prisma__participantsClient<participants | null>, Prisma__participantsClient<participantsGetPayload<T> | null>>

    /**
     * Find zero or more Participants that matches the filter.
     * @param {participantsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Participants
     * const participants = await prisma.participants.findMany()
     * 
     * // Get first 10 Participants
     * const participants = await prisma.participants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const participantsWithIdOnly = await prisma.participants.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends participantsFindManyArgs>(
      args?: SelectSubset<T, participantsFindManyArgs>
    ): CheckSelect<T, Promise<Array<participants>>, Promise<Array<participantsGetPayload<T>>>>

    /**
     * Create a Participants.
     * @param {participantsCreateArgs} args - Arguments to create a Participants.
     * @example
     * // Create one Participants
     * const Participants = await prisma.participants.create({
     *   data: {
     *     // ... data to create a Participants
     *   }
     * })
     * 
    **/
    create<T extends participantsCreateArgs>(
      args: SelectSubset<T, participantsCreateArgs>
    ): CheckSelect<T, Prisma__participantsClient<participants>, Prisma__participantsClient<participantsGetPayload<T>>>

    /**
     * Delete a Participants.
     * @param {participantsDeleteArgs} args - Arguments to delete one Participants.
     * @example
     * // Delete one Participants
     * const Participants = await prisma.participants.delete({
     *   where: {
     *     // ... filter to delete one Participants
     *   }
     * })
     * 
    **/
    delete<T extends participantsDeleteArgs>(
      args: SelectSubset<T, participantsDeleteArgs>
    ): CheckSelect<T, Prisma__participantsClient<participants>, Prisma__participantsClient<participantsGetPayload<T>>>

    /**
     * Update one Participants.
     * @param {participantsUpdateArgs} args - Arguments to update one Participants.
     * @example
     * // Update one Participants
     * const participants = await prisma.participants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends participantsUpdateArgs>(
      args: SelectSubset<T, participantsUpdateArgs>
    ): CheckSelect<T, Prisma__participantsClient<participants>, Prisma__participantsClient<participantsGetPayload<T>>>

    /**
     * Delete zero or more Participants.
     * @param {participantsDeleteManyArgs} args - Arguments to filter Participants to delete.
     * @example
     * // Delete a few Participants
     * const { count } = await prisma.participants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends participantsDeleteManyArgs>(
      args?: SelectSubset<T, participantsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Participants.
     * @param {participantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Participants
     * const participants = await prisma.participants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends participantsUpdateManyArgs>(
      args: SelectSubset<T, participantsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Participants.
     * @param {participantsUpsertArgs} args - Arguments to update or create a Participants.
     * @example
     * // Update or create a Participants
     * const participants = await prisma.participants.upsert({
     *   create: {
     *     // ... data to create a Participants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Participants we want to update
     *   }
     * })
    **/
    upsert<T extends participantsUpsertArgs>(
      args: SelectSubset<T, participantsUpsertArgs>
    ): CheckSelect<T, Prisma__participantsClient<participants>, Prisma__participantsClient<participantsGetPayload<T>>>

    /**
     * Count the number of Participants.
     * @param {participantsCountArgs} args - Arguments to filter Participants to count.
     * @example
     * // Count the number of Participants
     * const count = await prisma.participants.count({
     *   where: {
     *     // ... the filter for the Participants we want to count
     *   }
     * })
    **/
    count<T extends participantsCountArgs>(
      args?: Subset<T, participantsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Participants.
     * @param {ParticipantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipantsAggregateArgs>(args: Subset<T, ParticipantsAggregateArgs>): Promise<GetParticipantsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for participants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__participantsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    demodays<T extends demodaysArgs = {}>(args?: Subset<T, demodaysArgs>): CheckSelect<T, Prisma__demodaysClient<demodays | null>, Prisma__demodaysClient<demodaysGetPayload<T> | null>>;

    votes<T extends votesFindManyArgs = {}>(args?: Subset<T, votesFindManyArgs>): CheckSelect<T, Promise<Array<votes>>, Promise<Array<votesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * participants findUnique
   */
  export type participantsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the participants
    **/
    select?: participantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: participantsInclude | null
    /**
     * Throw an Error if a participants can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which participants to fetch.
    **/
    where: participantsWhereUniqueInput
  }


  /**
   * participants findFirst
   */
  export type participantsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the participants
    **/
    select?: participantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: participantsInclude | null
    /**
     * Throw an Error if a participants can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which participants to fetch.
    **/
    where?: participantsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of participants to fetch.
    **/
    orderBy?: Enumerable<participantsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for participants.
    **/
    cursor?: participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` participants from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` participants.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of participants.
    **/
    distinct?: Enumerable<ParticipantsScalarFieldEnum>
  }


  /**
   * participants findMany
   */
  export type participantsFindManyArgs = {
    /**
     * Select specific fields to fetch from the participants
    **/
    select?: participantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: participantsInclude | null
    /**
     * Filter, which participants to fetch.
    **/
    where?: participantsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of participants to fetch.
    **/
    orderBy?: Enumerable<participantsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing participants.
    **/
    cursor?: participantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` participants from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` participants.
    **/
    skip?: number
    distinct?: Enumerable<ParticipantsScalarFieldEnum>
  }


  /**
   * participants create
   */
  export type participantsCreateArgs = {
    /**
     * Select specific fields to fetch from the participants
    **/
    select?: participantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: participantsInclude | null
    /**
     * The data needed to create a participants.
    **/
    data: XOR<participantsUncheckedCreateInput, participantsCreateInput>
  }


  /**
   * participants update
   */
  export type participantsUpdateArgs = {
    /**
     * Select specific fields to fetch from the participants
    **/
    select?: participantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: participantsInclude | null
    /**
     * The data needed to update a participants.
    **/
    data: XOR<participantsUncheckedUpdateInput, participantsUpdateInput>
    /**
     * Choose, which participants to update.
    **/
    where: participantsWhereUniqueInput
  }


  /**
   * participants updateMany
   */
  export type participantsUpdateManyArgs = {
    data: XOR<participantsUncheckedUpdateManyInput, participantsUpdateManyMutationInput>
    where?: participantsWhereInput
  }


  /**
   * participants upsert
   */
  export type participantsUpsertArgs = {
    /**
     * Select specific fields to fetch from the participants
    **/
    select?: participantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: participantsInclude | null
    /**
     * The filter to search for the participants to update in case it exists.
    **/
    where: participantsWhereUniqueInput
    /**
     * In case the participants found by the `where` argument doesn't exist, create a new participants with this data.
    **/
    create: XOR<participantsUncheckedCreateInput, participantsCreateInput>
    /**
     * In case the participants was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<participantsUncheckedUpdateInput, participantsUpdateInput>
  }


  /**
   * participants delete
   */
  export type participantsDeleteArgs = {
    /**
     * Select specific fields to fetch from the participants
    **/
    select?: participantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: participantsInclude | null
    /**
     * Filter which participants to delete.
    **/
    where: participantsWhereUniqueInput
  }


  /**
   * participants deleteMany
   */
  export type participantsDeleteManyArgs = {
    where?: participantsWhereInput
  }


  /**
   * participants without action
   */
  export type participantsArgs = {
    /**
     * Select specific fields to fetch from the participants
    **/
    select?: participantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: participantsInclude | null
  }



  /**
   * Model partners
   */


  export type AggregatePartners = {
    count: PartnersCountAggregateOutputType | null
    avg: PartnersAvgAggregateOutputType | null
    sum: PartnersSumAggregateOutputType | null
    min: PartnersMinAggregateOutputType | null
    max: PartnersMaxAggregateOutputType | null
  }

  export type PartnersAvgAggregateOutputType = {
    id: number
    company_id: number
    interst_technology_id: number | null
    invested_total_id: number | null
    invested_counts: number | null
  }

  export type PartnersSumAggregateOutputType = {
    id: number
    company_id: number
    interst_technology_id: number | null
    invested_total_id: number | null
    invested_counts: number | null
  }

  export type PartnersMinAggregateOutputType = {
    id: number
    company_id: number
    interst_technology_id: number | null
    invested_total_id: number | null
    invested_counts: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type PartnersMaxAggregateOutputType = {
    id: number
    company_id: number
    interst_technology_id: number | null
    invested_total_id: number | null
    invested_counts: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type PartnersCountAggregateOutputType = {
    id: number
    company_id: number
    interst_technology_id: number | null
    invested_total_id: number | null
    invested_counts: number | null
    created_at: number | null
    updated_at: number | null
    deleted_at: number | null
    _all: number
  }


  export type PartnersAvgAggregateInputType = {
    id?: true
    company_id?: true
    interst_technology_id?: true
    invested_total_id?: true
    invested_counts?: true
  }

  export type PartnersSumAggregateInputType = {
    id?: true
    company_id?: true
    interst_technology_id?: true
    invested_total_id?: true
    invested_counts?: true
  }

  export type PartnersMinAggregateInputType = {
    id?: true
    company_id?: true
    interst_technology_id?: true
    invested_total_id?: true
    invested_counts?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type PartnersMaxAggregateInputType = {
    id?: true
    company_id?: true
    interst_technology_id?: true
    invested_total_id?: true
    invested_counts?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type PartnersCountAggregateInputType = {
    id?: true
    company_id?: true
    interst_technology_id?: true
    invested_total_id?: true
    invested_counts?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type PartnersAggregateArgs = {
    /**
     * Filter which partners to aggregate.
    **/
    where?: partnersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of partners to fetch.
    **/
    orderBy?: Enumerable<partnersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partners from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partners.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned partners
    **/
    count?: true | PartnersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PartnersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PartnersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PartnersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PartnersMaxAggregateInputType
  }

  export type GetPartnersAggregateType<T extends PartnersAggregateArgs> = {
    [P in keyof T & keyof AggregatePartners]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartners[P]>
      : GetScalarType<T[P], AggregatePartners[P]>
  }



  export type partnersSelect = {
    id?: boolean
    company_id?: boolean
    interst_technology_id?: boolean
    invested_total_id?: boolean
    invested_counts?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    companies?: boolean | companiesArgs
    technologies?: boolean | technologiesArgs
    investment_funds?: boolean | investment_fundsArgs
    investment_portfolio?: boolean | investment_portfolioFindManyArgs
    IR_requests?: boolean | IR_requestsFindManyArgs
    invested_to?: boolean | invested_toFindManyArgs
  }

  export type partnersInclude = {
    companies?: boolean | companiesArgs
    technologies?: boolean | technologiesArgs
    investment_funds?: boolean | investment_fundsArgs
    investment_portfolio?: boolean | investment_portfolioFindManyArgs
    IR_requests?: boolean | IR_requestsFindManyArgs
    invested_to?: boolean | invested_toFindManyArgs
  }

  export type partnersGetPayload<
    S extends boolean | null | undefined | partnersArgs,
    U = keyof S
      > = S extends true
        ? partners
    : S extends undefined
    ? never
    : S extends partnersArgs | partnersFindManyArgs
    ?'include' extends U
    ? partners  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'technologies'
        ? technologiesGetPayload<S['include'][P]> | null :
        P extends 'investment_funds'
        ? investment_fundsGetPayload<S['include'][P]> | null :
        P extends 'investment_portfolio'
        ? Array < investment_portfolioGetPayload<S['include'][P]>>  :
        P extends 'IR_requests'
        ? Array < IR_requestsGetPayload<S['include'][P]>>  :
        P extends 'invested_to'
        ? Array < invested_toGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof partners ?partners [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'technologies'
        ? technologiesGetPayload<S['select'][P]> | null :
        P extends 'investment_funds'
        ? investment_fundsGetPayload<S['select'][P]> | null :
        P extends 'investment_portfolio'
        ? Array < investment_portfolioGetPayload<S['select'][P]>>  :
        P extends 'IR_requests'
        ? Array < IR_requestsGetPayload<S['select'][P]>>  :
        P extends 'invested_to'
        ? Array < invested_toGetPayload<S['select'][P]>>  : never
  } 
    : partners
  : partners


  type partnersCountArgs = Merge<
    Omit<partnersFindManyArgs, 'select' | 'include'> & {
      select?: PartnersCountAggregateInputType | true
    }
  >

  export interface partnersDelegate {
    /**
     * Find zero or one Partners that matches the filter.
     * @param {partnersFindUniqueArgs} args - Arguments to find a Partners
     * @example
     * // Get one Partners
     * const partners = await prisma.partners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends partnersFindUniqueArgs>(
      args: SelectSubset<T, partnersFindUniqueArgs>
    ): CheckSelect<T, Prisma__partnersClient<partners | null>, Prisma__partnersClient<partnersGetPayload<T> | null>>

    /**
     * Find the first Partners that matches the filter.
     * @param {partnersFindFirstArgs} args - Arguments to find a Partners
     * @example
     * // Get one Partners
     * const partners = await prisma.partners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends partnersFindFirstArgs>(
      args?: SelectSubset<T, partnersFindFirstArgs>
    ): CheckSelect<T, Prisma__partnersClient<partners | null>, Prisma__partnersClient<partnersGetPayload<T> | null>>

    /**
     * Find zero or more Partners that matches the filter.
     * @param {partnersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partners.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partners.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnersWithIdOnly = await prisma.partners.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends partnersFindManyArgs>(
      args?: SelectSubset<T, partnersFindManyArgs>
    ): CheckSelect<T, Promise<Array<partners>>, Promise<Array<partnersGetPayload<T>>>>

    /**
     * Create a Partners.
     * @param {partnersCreateArgs} args - Arguments to create a Partners.
     * @example
     * // Create one Partners
     * const Partners = await prisma.partners.create({
     *   data: {
     *     // ... data to create a Partners
     *   }
     * })
     * 
    **/
    create<T extends partnersCreateArgs>(
      args: SelectSubset<T, partnersCreateArgs>
    ): CheckSelect<T, Prisma__partnersClient<partners>, Prisma__partnersClient<partnersGetPayload<T>>>

    /**
     * Delete a Partners.
     * @param {partnersDeleteArgs} args - Arguments to delete one Partners.
     * @example
     * // Delete one Partners
     * const Partners = await prisma.partners.delete({
     *   where: {
     *     // ... filter to delete one Partners
     *   }
     * })
     * 
    **/
    delete<T extends partnersDeleteArgs>(
      args: SelectSubset<T, partnersDeleteArgs>
    ): CheckSelect<T, Prisma__partnersClient<partners>, Prisma__partnersClient<partnersGetPayload<T>>>

    /**
     * Update one Partners.
     * @param {partnersUpdateArgs} args - Arguments to update one Partners.
     * @example
     * // Update one Partners
     * const partners = await prisma.partners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends partnersUpdateArgs>(
      args: SelectSubset<T, partnersUpdateArgs>
    ): CheckSelect<T, Prisma__partnersClient<partners>, Prisma__partnersClient<partnersGetPayload<T>>>

    /**
     * Delete zero or more Partners.
     * @param {partnersDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends partnersDeleteManyArgs>(
      args?: SelectSubset<T, partnersDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Partners.
     * @param {partnersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partners = await prisma.partners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends partnersUpdateManyArgs>(
      args: SelectSubset<T, partnersUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Partners.
     * @param {partnersUpsertArgs} args - Arguments to update or create a Partners.
     * @example
     * // Update or create a Partners
     * const partners = await prisma.partners.upsert({
     *   create: {
     *     // ... data to create a Partners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partners we want to update
     *   }
     * })
    **/
    upsert<T extends partnersUpsertArgs>(
      args: SelectSubset<T, partnersUpsertArgs>
    ): CheckSelect<T, Prisma__partnersClient<partners>, Prisma__partnersClient<partnersGetPayload<T>>>

    /**
     * Count the number of Partners.
     * @param {partnersCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partners.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends partnersCountArgs>(
      args?: Subset<T, partnersCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partners.
     * @param {PartnersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnersAggregateArgs>(args: Subset<T, PartnersAggregateArgs>): Promise<GetPartnersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for partners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__partnersClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    technologies<T extends technologiesArgs = {}>(args?: Subset<T, technologiesArgs>): CheckSelect<T, Prisma__technologiesClient<technologies | null>, Prisma__technologiesClient<technologiesGetPayload<T> | null>>;

    investment_funds<T extends investment_fundsArgs = {}>(args?: Subset<T, investment_fundsArgs>): CheckSelect<T, Prisma__investment_fundsClient<investment_funds | null>, Prisma__investment_fundsClient<investment_fundsGetPayload<T> | null>>;

    investment_portfolio<T extends investment_portfolioFindManyArgs = {}>(args?: Subset<T, investment_portfolioFindManyArgs>): CheckSelect<T, Promise<Array<investment_portfolio>>, Promise<Array<investment_portfolioGetPayload<T>>>>;

    IR_requests<T extends IR_requestsFindManyArgs = {}>(args?: Subset<T, IR_requestsFindManyArgs>): CheckSelect<T, Promise<Array<IR_requests>>, Promise<Array<IR_requestsGetPayload<T>>>>;

    invested_to<T extends invested_toFindManyArgs = {}>(args?: Subset<T, invested_toFindManyArgs>): CheckSelect<T, Promise<Array<invested_to>>, Promise<Array<invested_toGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * partners findUnique
   */
  export type partnersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the partners
    **/
    select?: partnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partnersInclude | null
    /**
     * Throw an Error if a partners can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which partners to fetch.
    **/
    where: partnersWhereUniqueInput
  }


  /**
   * partners findFirst
   */
  export type partnersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the partners
    **/
    select?: partnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partnersInclude | null
    /**
     * Throw an Error if a partners can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which partners to fetch.
    **/
    where?: partnersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of partners to fetch.
    **/
    orderBy?: Enumerable<partnersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for partners.
    **/
    cursor?: partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partners from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partners.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of partners.
    **/
    distinct?: Enumerable<PartnersScalarFieldEnum>
  }


  /**
   * partners findMany
   */
  export type partnersFindManyArgs = {
    /**
     * Select specific fields to fetch from the partners
    **/
    select?: partnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partnersInclude | null
    /**
     * Filter, which partners to fetch.
    **/
    where?: partnersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of partners to fetch.
    **/
    orderBy?: Enumerable<partnersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing partners.
    **/
    cursor?: partnersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partners from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partners.
    **/
    skip?: number
    distinct?: Enumerable<PartnersScalarFieldEnum>
  }


  /**
   * partners create
   */
  export type partnersCreateArgs = {
    /**
     * Select specific fields to fetch from the partners
    **/
    select?: partnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partnersInclude | null
    /**
     * The data needed to create a partners.
    **/
    data: XOR<partnersUncheckedCreateInput, partnersCreateInput>
  }


  /**
   * partners update
   */
  export type partnersUpdateArgs = {
    /**
     * Select specific fields to fetch from the partners
    **/
    select?: partnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partnersInclude | null
    /**
     * The data needed to update a partners.
    **/
    data: XOR<partnersUncheckedUpdateInput, partnersUpdateInput>
    /**
     * Choose, which partners to update.
    **/
    where: partnersWhereUniqueInput
  }


  /**
   * partners updateMany
   */
  export type partnersUpdateManyArgs = {
    data: XOR<partnersUncheckedUpdateManyInput, partnersUpdateManyMutationInput>
    where?: partnersWhereInput
  }


  /**
   * partners upsert
   */
  export type partnersUpsertArgs = {
    /**
     * Select specific fields to fetch from the partners
    **/
    select?: partnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partnersInclude | null
    /**
     * The filter to search for the partners to update in case it exists.
    **/
    where: partnersWhereUniqueInput
    /**
     * In case the partners found by the `where` argument doesn't exist, create a new partners with this data.
    **/
    create: XOR<partnersUncheckedCreateInput, partnersCreateInput>
    /**
     * In case the partners was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<partnersUncheckedUpdateInput, partnersUpdateInput>
  }


  /**
   * partners delete
   */
  export type partnersDeleteArgs = {
    /**
     * Select specific fields to fetch from the partners
    **/
    select?: partnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partnersInclude | null
    /**
     * Filter which partners to delete.
    **/
    where: partnersWhereUniqueInput
  }


  /**
   * partners deleteMany
   */
  export type partnersDeleteManyArgs = {
    where?: partnersWhereInput
  }


  /**
   * partners without action
   */
  export type partnersArgs = {
    /**
     * Select specific fields to fetch from the partners
    **/
    select?: partnersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partnersInclude | null
  }



  /**
   * Model partner_likes
   */


  export type AggregatePartner_likes = {
    count: Partner_likesCountAggregateOutputType | null
    avg: Partner_likesAvgAggregateOutputType | null
    sum: Partner_likesSumAggregateOutputType | null
    min: Partner_likesMinAggregateOutputType | null
    max: Partner_likesMaxAggregateOutputType | null
  }

  export type Partner_likesAvgAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
  }

  export type Partner_likesSumAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
  }

  export type Partner_likesMinAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
    is_liked: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Partner_likesMaxAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
    is_liked: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Partner_likesCountAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
    is_liked: number | null
    created_at: number | null
    updated_at: number | null
    _all: number
  }


  export type Partner_likesAvgAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
  }

  export type Partner_likesSumAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
  }

  export type Partner_likesMinAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
  }

  export type Partner_likesMaxAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
  }

  export type Partner_likesCountAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Partner_likesAggregateArgs = {
    /**
     * Filter which partner_likes to aggregate.
    **/
    where?: partner_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of partner_likes to fetch.
    **/
    orderBy?: Enumerable<partner_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: partner_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partner_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partner_likes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned partner_likes
    **/
    count?: true | Partner_likesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Partner_likesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Partner_likesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Partner_likesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Partner_likesMaxAggregateInputType
  }

  export type GetPartner_likesAggregateType<T extends Partner_likesAggregateArgs> = {
    [P in keyof T & keyof AggregatePartner_likes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner_likes[P]>
      : GetScalarType<T[P], AggregatePartner_likes[P]>
  }



  export type partner_likesSelect = {
    id?: boolean
    user_id?: boolean
    company_id?: boolean
    is_liked?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersArgs
    companies?: boolean | companiesArgs
  }

  export type partner_likesInclude = {
    users?: boolean | usersArgs
    companies?: boolean | companiesArgs
  }

  export type partner_likesGetPayload<
    S extends boolean | null | undefined | partner_likesArgs,
    U = keyof S
      > = S extends true
        ? partner_likes
    : S extends undefined
    ? never
    : S extends partner_likesArgs | partner_likesFindManyArgs
    ?'include' extends U
    ? partner_likes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'users'
        ? usersGetPayload<S['include'][P]> :
        P extends 'companies'
        ? companiesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof partner_likes ?partner_likes [P]
  : 
          P extends 'users'
        ? usersGetPayload<S['select'][P]> :
        P extends 'companies'
        ? companiesGetPayload<S['select'][P]> : never
  } 
    : partner_likes
  : partner_likes


  type partner_likesCountArgs = Merge<
    Omit<partner_likesFindManyArgs, 'select' | 'include'> & {
      select?: Partner_likesCountAggregateInputType | true
    }
  >

  export interface partner_likesDelegate {
    /**
     * Find zero or one Partner_likes that matches the filter.
     * @param {partner_likesFindUniqueArgs} args - Arguments to find a Partner_likes
     * @example
     * // Get one Partner_likes
     * const partner_likes = await prisma.partner_likes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends partner_likesFindUniqueArgs>(
      args: SelectSubset<T, partner_likesFindUniqueArgs>
    ): CheckSelect<T, Prisma__partner_likesClient<partner_likes | null>, Prisma__partner_likesClient<partner_likesGetPayload<T> | null>>

    /**
     * Find the first Partner_likes that matches the filter.
     * @param {partner_likesFindFirstArgs} args - Arguments to find a Partner_likes
     * @example
     * // Get one Partner_likes
     * const partner_likes = await prisma.partner_likes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends partner_likesFindFirstArgs>(
      args?: SelectSubset<T, partner_likesFindFirstArgs>
    ): CheckSelect<T, Prisma__partner_likesClient<partner_likes | null>, Prisma__partner_likesClient<partner_likesGetPayload<T> | null>>

    /**
     * Find zero or more Partner_likes that matches the filter.
     * @param {partner_likesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partner_likes
     * const partner_likes = await prisma.partner_likes.findMany()
     * 
     * // Get first 10 Partner_likes
     * const partner_likes = await prisma.partner_likes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partner_likesWithIdOnly = await prisma.partner_likes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends partner_likesFindManyArgs>(
      args?: SelectSubset<T, partner_likesFindManyArgs>
    ): CheckSelect<T, Promise<Array<partner_likes>>, Promise<Array<partner_likesGetPayload<T>>>>

    /**
     * Create a Partner_likes.
     * @param {partner_likesCreateArgs} args - Arguments to create a Partner_likes.
     * @example
     * // Create one Partner_likes
     * const Partner_likes = await prisma.partner_likes.create({
     *   data: {
     *     // ... data to create a Partner_likes
     *   }
     * })
     * 
    **/
    create<T extends partner_likesCreateArgs>(
      args: SelectSubset<T, partner_likesCreateArgs>
    ): CheckSelect<T, Prisma__partner_likesClient<partner_likes>, Prisma__partner_likesClient<partner_likesGetPayload<T>>>

    /**
     * Delete a Partner_likes.
     * @param {partner_likesDeleteArgs} args - Arguments to delete one Partner_likes.
     * @example
     * // Delete one Partner_likes
     * const Partner_likes = await prisma.partner_likes.delete({
     *   where: {
     *     // ... filter to delete one Partner_likes
     *   }
     * })
     * 
    **/
    delete<T extends partner_likesDeleteArgs>(
      args: SelectSubset<T, partner_likesDeleteArgs>
    ): CheckSelect<T, Prisma__partner_likesClient<partner_likes>, Prisma__partner_likesClient<partner_likesGetPayload<T>>>

    /**
     * Update one Partner_likes.
     * @param {partner_likesUpdateArgs} args - Arguments to update one Partner_likes.
     * @example
     * // Update one Partner_likes
     * const partner_likes = await prisma.partner_likes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends partner_likesUpdateArgs>(
      args: SelectSubset<T, partner_likesUpdateArgs>
    ): CheckSelect<T, Prisma__partner_likesClient<partner_likes>, Prisma__partner_likesClient<partner_likesGetPayload<T>>>

    /**
     * Delete zero or more Partner_likes.
     * @param {partner_likesDeleteManyArgs} args - Arguments to filter Partner_likes to delete.
     * @example
     * // Delete a few Partner_likes
     * const { count } = await prisma.partner_likes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends partner_likesDeleteManyArgs>(
      args?: SelectSubset<T, partner_likesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Partner_likes.
     * @param {partner_likesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partner_likes
     * const partner_likes = await prisma.partner_likes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends partner_likesUpdateManyArgs>(
      args: SelectSubset<T, partner_likesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Partner_likes.
     * @param {partner_likesUpsertArgs} args - Arguments to update or create a Partner_likes.
     * @example
     * // Update or create a Partner_likes
     * const partner_likes = await prisma.partner_likes.upsert({
     *   create: {
     *     // ... data to create a Partner_likes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner_likes we want to update
     *   }
     * })
    **/
    upsert<T extends partner_likesUpsertArgs>(
      args: SelectSubset<T, partner_likesUpsertArgs>
    ): CheckSelect<T, Prisma__partner_likesClient<partner_likes>, Prisma__partner_likesClient<partner_likesGetPayload<T>>>

    /**
     * Count the number of Partner_likes.
     * @param {partner_likesCountArgs} args - Arguments to filter Partner_likes to count.
     * @example
     * // Count the number of Partner_likes
     * const count = await prisma.partner_likes.count({
     *   where: {
     *     // ... the filter for the Partner_likes we want to count
     *   }
     * })
    **/
    count<T extends partner_likesCountArgs>(
      args?: Subset<T, partner_likesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Partner_likesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner_likes.
     * @param {Partner_likesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Partner_likesAggregateArgs>(args: Subset<T, Partner_likesAggregateArgs>): Promise<GetPartner_likesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for partner_likes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__partner_likesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>;

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * partner_likes findUnique
   */
  export type partner_likesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the partner_likes
    **/
    select?: partner_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partner_likesInclude | null
    /**
     * Throw an Error if a partner_likes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which partner_likes to fetch.
    **/
    where: partner_likesWhereUniqueInput
  }


  /**
   * partner_likes findFirst
   */
  export type partner_likesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the partner_likes
    **/
    select?: partner_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partner_likesInclude | null
    /**
     * Throw an Error if a partner_likes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which partner_likes to fetch.
    **/
    where?: partner_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of partner_likes to fetch.
    **/
    orderBy?: Enumerable<partner_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for partner_likes.
    **/
    cursor?: partner_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partner_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partner_likes.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of partner_likes.
    **/
    distinct?: Enumerable<Partner_likesScalarFieldEnum>
  }


  /**
   * partner_likes findMany
   */
  export type partner_likesFindManyArgs = {
    /**
     * Select specific fields to fetch from the partner_likes
    **/
    select?: partner_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partner_likesInclude | null
    /**
     * Filter, which partner_likes to fetch.
    **/
    where?: partner_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of partner_likes to fetch.
    **/
    orderBy?: Enumerable<partner_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing partner_likes.
    **/
    cursor?: partner_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` partner_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` partner_likes.
    **/
    skip?: number
    distinct?: Enumerable<Partner_likesScalarFieldEnum>
  }


  /**
   * partner_likes create
   */
  export type partner_likesCreateArgs = {
    /**
     * Select specific fields to fetch from the partner_likes
    **/
    select?: partner_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partner_likesInclude | null
    /**
     * The data needed to create a partner_likes.
    **/
    data: XOR<partner_likesUncheckedCreateInput, partner_likesCreateInput>
  }


  /**
   * partner_likes update
   */
  export type partner_likesUpdateArgs = {
    /**
     * Select specific fields to fetch from the partner_likes
    **/
    select?: partner_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partner_likesInclude | null
    /**
     * The data needed to update a partner_likes.
    **/
    data: XOR<partner_likesUncheckedUpdateInput, partner_likesUpdateInput>
    /**
     * Choose, which partner_likes to update.
    **/
    where: partner_likesWhereUniqueInput
  }


  /**
   * partner_likes updateMany
   */
  export type partner_likesUpdateManyArgs = {
    data: XOR<partner_likesUncheckedUpdateManyInput, partner_likesUpdateManyMutationInput>
    where?: partner_likesWhereInput
  }


  /**
   * partner_likes upsert
   */
  export type partner_likesUpsertArgs = {
    /**
     * Select specific fields to fetch from the partner_likes
    **/
    select?: partner_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partner_likesInclude | null
    /**
     * The filter to search for the partner_likes to update in case it exists.
    **/
    where: partner_likesWhereUniqueInput
    /**
     * In case the partner_likes found by the `where` argument doesn't exist, create a new partner_likes with this data.
    **/
    create: XOR<partner_likesUncheckedCreateInput, partner_likesCreateInput>
    /**
     * In case the partner_likes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<partner_likesUncheckedUpdateInput, partner_likesUpdateInput>
  }


  /**
   * partner_likes delete
   */
  export type partner_likesDeleteArgs = {
    /**
     * Select specific fields to fetch from the partner_likes
    **/
    select?: partner_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partner_likesInclude | null
    /**
     * Filter which partner_likes to delete.
    **/
    where: partner_likesWhereUniqueInput
  }


  /**
   * partner_likes deleteMany
   */
  export type partner_likesDeleteManyArgs = {
    where?: partner_likesWhereInput
  }


  /**
   * partner_likes without action
   */
  export type partner_likesArgs = {
    /**
     * Select specific fields to fetch from the partner_likes
    **/
    select?: partner_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: partner_likesInclude | null
  }



  /**
   * Model phone_auth
   */


  export type AggregatePhone_auth = {
    count: Phone_authCountAggregateOutputType | null
    avg: Phone_authAvgAggregateOutputType | null
    sum: Phone_authSumAggregateOutputType | null
    min: Phone_authMinAggregateOutputType | null
    max: Phone_authMaxAggregateOutputType | null
  }

  export type Phone_authAvgAggregateOutputType = {
    id: number
  }

  export type Phone_authSumAggregateOutputType = {
    id: number
  }

  export type Phone_authMinAggregateOutputType = {
    id: number
    phone_number: string | null
    auth_number: string | null
  }

  export type Phone_authMaxAggregateOutputType = {
    id: number
    phone_number: string | null
    auth_number: string | null
  }

  export type Phone_authCountAggregateOutputType = {
    id: number
    phone_number: number | null
    auth_number: number | null
    _all: number
  }


  export type Phone_authAvgAggregateInputType = {
    id?: true
  }

  export type Phone_authSumAggregateInputType = {
    id?: true
  }

  export type Phone_authMinAggregateInputType = {
    id?: true
    phone_number?: true
    auth_number?: true
  }

  export type Phone_authMaxAggregateInputType = {
    id?: true
    phone_number?: true
    auth_number?: true
  }

  export type Phone_authCountAggregateInputType = {
    id?: true
    phone_number?: true
    auth_number?: true
    _all?: true
  }

  export type Phone_authAggregateArgs = {
    /**
     * Filter which phone_auth to aggregate.
    **/
    where?: phone_authWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of phone_auths to fetch.
    **/
    orderBy?: Enumerable<phone_authOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: phone_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` phone_auths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` phone_auths.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned phone_auths
    **/
    count?: true | Phone_authCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Phone_authAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Phone_authSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Phone_authMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Phone_authMaxAggregateInputType
  }

  export type GetPhone_authAggregateType<T extends Phone_authAggregateArgs> = {
    [P in keyof T & keyof AggregatePhone_auth]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhone_auth[P]>
      : GetScalarType<T[P], AggregatePhone_auth[P]>
  }



  export type phone_authSelect = {
    id?: boolean
    phone_number?: boolean
    auth_number?: boolean
  }

  export type phone_authGetPayload<
    S extends boolean | null | undefined | phone_authArgs,
    U = keyof S
      > = S extends true
        ? phone_auth
    : S extends undefined
    ? never
    : S extends phone_authArgs | phone_authFindManyArgs
    ?'include' extends U
    ? phone_auth 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof phone_auth ?phone_auth [P]
  : 
     never
  } 
    : phone_auth
  : phone_auth


  type phone_authCountArgs = Merge<
    Omit<phone_authFindManyArgs, 'select' | 'include'> & {
      select?: Phone_authCountAggregateInputType | true
    }
  >

  export interface phone_authDelegate {
    /**
     * Find zero or one Phone_auth that matches the filter.
     * @param {phone_authFindUniqueArgs} args - Arguments to find a Phone_auth
     * @example
     * // Get one Phone_auth
     * const phone_auth = await prisma.phone_auth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends phone_authFindUniqueArgs>(
      args: SelectSubset<T, phone_authFindUniqueArgs>
    ): CheckSelect<T, Prisma__phone_authClient<phone_auth | null>, Prisma__phone_authClient<phone_authGetPayload<T> | null>>

    /**
     * Find the first Phone_auth that matches the filter.
     * @param {phone_authFindFirstArgs} args - Arguments to find a Phone_auth
     * @example
     * // Get one Phone_auth
     * const phone_auth = await prisma.phone_auth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends phone_authFindFirstArgs>(
      args?: SelectSubset<T, phone_authFindFirstArgs>
    ): CheckSelect<T, Prisma__phone_authClient<phone_auth | null>, Prisma__phone_authClient<phone_authGetPayload<T> | null>>

    /**
     * Find zero or more Phone_auths that matches the filter.
     * @param {phone_authFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phone_auths
     * const phone_auths = await prisma.phone_auth.findMany()
     * 
     * // Get first 10 Phone_auths
     * const phone_auths = await prisma.phone_auth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phone_authWithIdOnly = await prisma.phone_auth.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends phone_authFindManyArgs>(
      args?: SelectSubset<T, phone_authFindManyArgs>
    ): CheckSelect<T, Promise<Array<phone_auth>>, Promise<Array<phone_authGetPayload<T>>>>

    /**
     * Create a Phone_auth.
     * @param {phone_authCreateArgs} args - Arguments to create a Phone_auth.
     * @example
     * // Create one Phone_auth
     * const Phone_auth = await prisma.phone_auth.create({
     *   data: {
     *     // ... data to create a Phone_auth
     *   }
     * })
     * 
    **/
    create<T extends phone_authCreateArgs>(
      args: SelectSubset<T, phone_authCreateArgs>
    ): CheckSelect<T, Prisma__phone_authClient<phone_auth>, Prisma__phone_authClient<phone_authGetPayload<T>>>

    /**
     * Delete a Phone_auth.
     * @param {phone_authDeleteArgs} args - Arguments to delete one Phone_auth.
     * @example
     * // Delete one Phone_auth
     * const Phone_auth = await prisma.phone_auth.delete({
     *   where: {
     *     // ... filter to delete one Phone_auth
     *   }
     * })
     * 
    **/
    delete<T extends phone_authDeleteArgs>(
      args: SelectSubset<T, phone_authDeleteArgs>
    ): CheckSelect<T, Prisma__phone_authClient<phone_auth>, Prisma__phone_authClient<phone_authGetPayload<T>>>

    /**
     * Update one Phone_auth.
     * @param {phone_authUpdateArgs} args - Arguments to update one Phone_auth.
     * @example
     * // Update one Phone_auth
     * const phone_auth = await prisma.phone_auth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends phone_authUpdateArgs>(
      args: SelectSubset<T, phone_authUpdateArgs>
    ): CheckSelect<T, Prisma__phone_authClient<phone_auth>, Prisma__phone_authClient<phone_authGetPayload<T>>>

    /**
     * Delete zero or more Phone_auths.
     * @param {phone_authDeleteManyArgs} args - Arguments to filter Phone_auths to delete.
     * @example
     * // Delete a few Phone_auths
     * const { count } = await prisma.phone_auth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends phone_authDeleteManyArgs>(
      args?: SelectSubset<T, phone_authDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Phone_auths.
     * @param {phone_authUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phone_auths
     * const phone_auth = await prisma.phone_auth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends phone_authUpdateManyArgs>(
      args: SelectSubset<T, phone_authUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Phone_auth.
     * @param {phone_authUpsertArgs} args - Arguments to update or create a Phone_auth.
     * @example
     * // Update or create a Phone_auth
     * const phone_auth = await prisma.phone_auth.upsert({
     *   create: {
     *     // ... data to create a Phone_auth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phone_auth we want to update
     *   }
     * })
    **/
    upsert<T extends phone_authUpsertArgs>(
      args: SelectSubset<T, phone_authUpsertArgs>
    ): CheckSelect<T, Prisma__phone_authClient<phone_auth>, Prisma__phone_authClient<phone_authGetPayload<T>>>

    /**
     * Count the number of Phone_auths.
     * @param {phone_authCountArgs} args - Arguments to filter Phone_auths to count.
     * @example
     * // Count the number of Phone_auths
     * const count = await prisma.phone_auth.count({
     *   where: {
     *     // ... the filter for the Phone_auths we want to count
     *   }
     * })
    **/
    count<T extends phone_authCountArgs>(
      args?: Subset<T, phone_authCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Phone_authCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phone_auth.
     * @param {Phone_authAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Phone_authAggregateArgs>(args: Subset<T, Phone_authAggregateArgs>): Promise<GetPhone_authAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for phone_auth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__phone_authClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * phone_auth findUnique
   */
  export type phone_authFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the phone_auth
    **/
    select?: phone_authSelect | null
    /**
     * Throw an Error if a phone_auth can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which phone_auth to fetch.
    **/
    where: phone_authWhereUniqueInput
  }


  /**
   * phone_auth findFirst
   */
  export type phone_authFindFirstArgs = {
    /**
     * Select specific fields to fetch from the phone_auth
    **/
    select?: phone_authSelect | null
    /**
     * Throw an Error if a phone_auth can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which phone_auth to fetch.
    **/
    where?: phone_authWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of phone_auths to fetch.
    **/
    orderBy?: Enumerable<phone_authOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for phone_auths.
    **/
    cursor?: phone_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` phone_auths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` phone_auths.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of phone_auths.
    **/
    distinct?: Enumerable<Phone_authScalarFieldEnum>
  }


  /**
   * phone_auth findMany
   */
  export type phone_authFindManyArgs = {
    /**
     * Select specific fields to fetch from the phone_auth
    **/
    select?: phone_authSelect | null
    /**
     * Filter, which phone_auths to fetch.
    **/
    where?: phone_authWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of phone_auths to fetch.
    **/
    orderBy?: Enumerable<phone_authOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing phone_auths.
    **/
    cursor?: phone_authWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` phone_auths from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` phone_auths.
    **/
    skip?: number
    distinct?: Enumerable<Phone_authScalarFieldEnum>
  }


  /**
   * phone_auth create
   */
  export type phone_authCreateArgs = {
    /**
     * Select specific fields to fetch from the phone_auth
    **/
    select?: phone_authSelect | null
    /**
     * The data needed to create a phone_auth.
    **/
    data: XOR<phone_authUncheckedCreateInput, phone_authCreateInput>
  }


  /**
   * phone_auth update
   */
  export type phone_authUpdateArgs = {
    /**
     * Select specific fields to fetch from the phone_auth
    **/
    select?: phone_authSelect | null
    /**
     * The data needed to update a phone_auth.
    **/
    data: XOR<phone_authUncheckedUpdateInput, phone_authUpdateInput>
    /**
     * Choose, which phone_auth to update.
    **/
    where: phone_authWhereUniqueInput
  }


  /**
   * phone_auth updateMany
   */
  export type phone_authUpdateManyArgs = {
    data: XOR<phone_authUncheckedUpdateManyInput, phone_authUpdateManyMutationInput>
    where?: phone_authWhereInput
  }


  /**
   * phone_auth upsert
   */
  export type phone_authUpsertArgs = {
    /**
     * Select specific fields to fetch from the phone_auth
    **/
    select?: phone_authSelect | null
    /**
     * The filter to search for the phone_auth to update in case it exists.
    **/
    where: phone_authWhereUniqueInput
    /**
     * In case the phone_auth found by the `where` argument doesn't exist, create a new phone_auth with this data.
    **/
    create: XOR<phone_authUncheckedCreateInput, phone_authCreateInput>
    /**
     * In case the phone_auth was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<phone_authUncheckedUpdateInput, phone_authUpdateInput>
  }


  /**
   * phone_auth delete
   */
  export type phone_authDeleteArgs = {
    /**
     * Select specific fields to fetch from the phone_auth
    **/
    select?: phone_authSelect | null
    /**
     * Filter which phone_auth to delete.
    **/
    where: phone_authWhereUniqueInput
  }


  /**
   * phone_auth deleteMany
   */
  export type phone_authDeleteManyArgs = {
    where?: phone_authWhereInput
  }


  /**
   * phone_auth without action
   */
  export type phone_authArgs = {
    /**
     * Select specific fields to fetch from the phone_auth
    **/
    select?: phone_authSelect | null
  }



  /**
   * Model project_images
   */


  export type AggregateProject_images = {
    count: Project_imagesCountAggregateOutputType | null
    avg: Project_imagesAvgAggregateOutputType | null
    sum: Project_imagesSumAggregateOutputType | null
    min: Project_imagesMinAggregateOutputType | null
    max: Project_imagesMaxAggregateOutputType | null
  }

  export type Project_imagesAvgAggregateOutputType = {
    id: number
    project_id: number
  }

  export type Project_imagesSumAggregateOutputType = {
    id: number
    project_id: number
  }

  export type Project_imagesMinAggregateOutputType = {
    id: number
    project_id: number
    img_url: string | null
  }

  export type Project_imagesMaxAggregateOutputType = {
    id: number
    project_id: number
    img_url: string | null
  }

  export type Project_imagesCountAggregateOutputType = {
    id: number
    project_id: number
    img_url: number | null
    _all: number
  }


  export type Project_imagesAvgAggregateInputType = {
    id?: true
    project_id?: true
  }

  export type Project_imagesSumAggregateInputType = {
    id?: true
    project_id?: true
  }

  export type Project_imagesMinAggregateInputType = {
    id?: true
    project_id?: true
    img_url?: true
  }

  export type Project_imagesMaxAggregateInputType = {
    id?: true
    project_id?: true
    img_url?: true
  }

  export type Project_imagesCountAggregateInputType = {
    id?: true
    project_id?: true
    img_url?: true
    _all?: true
  }

  export type Project_imagesAggregateArgs = {
    /**
     * Filter which project_images to aggregate.
    **/
    where?: project_imagesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of project_images to fetch.
    **/
    orderBy?: Enumerable<project_imagesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: project_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_images.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned project_images
    **/
    count?: true | Project_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Project_imagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Project_imagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Project_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Project_imagesMaxAggregateInputType
  }

  export type GetProject_imagesAggregateType<T extends Project_imagesAggregateArgs> = {
    [P in keyof T & keyof AggregateProject_images]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject_images[P]>
      : GetScalarType<T[P], AggregateProject_images[P]>
  }



  export type project_imagesSelect = {
    id?: boolean
    project_id?: boolean
    img_url?: boolean
    projects?: boolean | projectsArgs
  }

  export type project_imagesInclude = {
    projects?: boolean | projectsArgs
  }

  export type project_imagesGetPayload<
    S extends boolean | null | undefined | project_imagesArgs,
    U = keyof S
      > = S extends true
        ? project_images
    : S extends undefined
    ? never
    : S extends project_imagesArgs | project_imagesFindManyArgs
    ?'include' extends U
    ? project_images  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'projects'
        ? projectsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof project_images ?project_images [P]
  : 
          P extends 'projects'
        ? projectsGetPayload<S['select'][P]> : never
  } 
    : project_images
  : project_images


  type project_imagesCountArgs = Merge<
    Omit<project_imagesFindManyArgs, 'select' | 'include'> & {
      select?: Project_imagesCountAggregateInputType | true
    }
  >

  export interface project_imagesDelegate {
    /**
     * Find zero or one Project_images that matches the filter.
     * @param {project_imagesFindUniqueArgs} args - Arguments to find a Project_images
     * @example
     * // Get one Project_images
     * const project_images = await prisma.project_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends project_imagesFindUniqueArgs>(
      args: SelectSubset<T, project_imagesFindUniqueArgs>
    ): CheckSelect<T, Prisma__project_imagesClient<project_images | null>, Prisma__project_imagesClient<project_imagesGetPayload<T> | null>>

    /**
     * Find the first Project_images that matches the filter.
     * @param {project_imagesFindFirstArgs} args - Arguments to find a Project_images
     * @example
     * // Get one Project_images
     * const project_images = await prisma.project_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends project_imagesFindFirstArgs>(
      args?: SelectSubset<T, project_imagesFindFirstArgs>
    ): CheckSelect<T, Prisma__project_imagesClient<project_images | null>, Prisma__project_imagesClient<project_imagesGetPayload<T> | null>>

    /**
     * Find zero or more Project_images that matches the filter.
     * @param {project_imagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Project_images
     * const project_images = await prisma.project_images.findMany()
     * 
     * // Get first 10 Project_images
     * const project_images = await prisma.project_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const project_imagesWithIdOnly = await prisma.project_images.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends project_imagesFindManyArgs>(
      args?: SelectSubset<T, project_imagesFindManyArgs>
    ): CheckSelect<T, Promise<Array<project_images>>, Promise<Array<project_imagesGetPayload<T>>>>

    /**
     * Create a Project_images.
     * @param {project_imagesCreateArgs} args - Arguments to create a Project_images.
     * @example
     * // Create one Project_images
     * const Project_images = await prisma.project_images.create({
     *   data: {
     *     // ... data to create a Project_images
     *   }
     * })
     * 
    **/
    create<T extends project_imagesCreateArgs>(
      args: SelectSubset<T, project_imagesCreateArgs>
    ): CheckSelect<T, Prisma__project_imagesClient<project_images>, Prisma__project_imagesClient<project_imagesGetPayload<T>>>

    /**
     * Delete a Project_images.
     * @param {project_imagesDeleteArgs} args - Arguments to delete one Project_images.
     * @example
     * // Delete one Project_images
     * const Project_images = await prisma.project_images.delete({
     *   where: {
     *     // ... filter to delete one Project_images
     *   }
     * })
     * 
    **/
    delete<T extends project_imagesDeleteArgs>(
      args: SelectSubset<T, project_imagesDeleteArgs>
    ): CheckSelect<T, Prisma__project_imagesClient<project_images>, Prisma__project_imagesClient<project_imagesGetPayload<T>>>

    /**
     * Update one Project_images.
     * @param {project_imagesUpdateArgs} args - Arguments to update one Project_images.
     * @example
     * // Update one Project_images
     * const project_images = await prisma.project_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends project_imagesUpdateArgs>(
      args: SelectSubset<T, project_imagesUpdateArgs>
    ): CheckSelect<T, Prisma__project_imagesClient<project_images>, Prisma__project_imagesClient<project_imagesGetPayload<T>>>

    /**
     * Delete zero or more Project_images.
     * @param {project_imagesDeleteManyArgs} args - Arguments to filter Project_images to delete.
     * @example
     * // Delete a few Project_images
     * const { count } = await prisma.project_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends project_imagesDeleteManyArgs>(
      args?: SelectSubset<T, project_imagesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Project_images.
     * @param {project_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Project_images
     * const project_images = await prisma.project_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends project_imagesUpdateManyArgs>(
      args: SelectSubset<T, project_imagesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Project_images.
     * @param {project_imagesUpsertArgs} args - Arguments to update or create a Project_images.
     * @example
     * // Update or create a Project_images
     * const project_images = await prisma.project_images.upsert({
     *   create: {
     *     // ... data to create a Project_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project_images we want to update
     *   }
     * })
    **/
    upsert<T extends project_imagesUpsertArgs>(
      args: SelectSubset<T, project_imagesUpsertArgs>
    ): CheckSelect<T, Prisma__project_imagesClient<project_images>, Prisma__project_imagesClient<project_imagesGetPayload<T>>>

    /**
     * Count the number of Project_images.
     * @param {project_imagesCountArgs} args - Arguments to filter Project_images to count.
     * @example
     * // Count the number of Project_images
     * const count = await prisma.project_images.count({
     *   where: {
     *     // ... the filter for the Project_images we want to count
     *   }
     * })
    **/
    count<T extends project_imagesCountArgs>(
      args?: Subset<T, project_imagesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Project_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project_images.
     * @param {Project_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Project_imagesAggregateArgs>(args: Subset<T, Project_imagesAggregateArgs>): Promise<GetProject_imagesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for project_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__project_imagesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    projects<T extends projectsArgs = {}>(args?: Subset<T, projectsArgs>): CheckSelect<T, Prisma__projectsClient<projects | null>, Prisma__projectsClient<projectsGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * project_images findUnique
   */
  export type project_imagesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the project_images
    **/
    select?: project_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_imagesInclude | null
    /**
     * Throw an Error if a project_images can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which project_images to fetch.
    **/
    where: project_imagesWhereUniqueInput
  }


  /**
   * project_images findFirst
   */
  export type project_imagesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the project_images
    **/
    select?: project_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_imagesInclude | null
    /**
     * Throw an Error if a project_images can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which project_images to fetch.
    **/
    where?: project_imagesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of project_images to fetch.
    **/
    orderBy?: Enumerable<project_imagesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_images.
    **/
    cursor?: project_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_images.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of project_images.
    **/
    distinct?: Enumerable<Project_imagesScalarFieldEnum>
  }


  /**
   * project_images findMany
   */
  export type project_imagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the project_images
    **/
    select?: project_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_imagesInclude | null
    /**
     * Filter, which project_images to fetch.
    **/
    where?: project_imagesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of project_images to fetch.
    **/
    orderBy?: Enumerable<project_imagesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing project_images.
    **/
    cursor?: project_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_images.
    **/
    skip?: number
    distinct?: Enumerable<Project_imagesScalarFieldEnum>
  }


  /**
   * project_images create
   */
  export type project_imagesCreateArgs = {
    /**
     * Select specific fields to fetch from the project_images
    **/
    select?: project_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_imagesInclude | null
    /**
     * The data needed to create a project_images.
    **/
    data: XOR<project_imagesUncheckedCreateInput, project_imagesCreateInput>
  }


  /**
   * project_images update
   */
  export type project_imagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the project_images
    **/
    select?: project_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_imagesInclude | null
    /**
     * The data needed to update a project_images.
    **/
    data: XOR<project_imagesUncheckedUpdateInput, project_imagesUpdateInput>
    /**
     * Choose, which project_images to update.
    **/
    where: project_imagesWhereUniqueInput
  }


  /**
   * project_images updateMany
   */
  export type project_imagesUpdateManyArgs = {
    data: XOR<project_imagesUncheckedUpdateManyInput, project_imagesUpdateManyMutationInput>
    where?: project_imagesWhereInput
  }


  /**
   * project_images upsert
   */
  export type project_imagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the project_images
    **/
    select?: project_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_imagesInclude | null
    /**
     * The filter to search for the project_images to update in case it exists.
    **/
    where: project_imagesWhereUniqueInput
    /**
     * In case the project_images found by the `where` argument doesn't exist, create a new project_images with this data.
    **/
    create: XOR<project_imagesUncheckedCreateInput, project_imagesCreateInput>
    /**
     * In case the project_images was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<project_imagesUncheckedUpdateInput, project_imagesUpdateInput>
  }


  /**
   * project_images delete
   */
  export type project_imagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the project_images
    **/
    select?: project_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_imagesInclude | null
    /**
     * Filter which project_images to delete.
    **/
    where: project_imagesWhereUniqueInput
  }


  /**
   * project_images deleteMany
   */
  export type project_imagesDeleteManyArgs = {
    where?: project_imagesWhereInput
  }


  /**
   * project_images without action
   */
  export type project_imagesArgs = {
    /**
     * Select specific fields to fetch from the project_images
    **/
    select?: project_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_imagesInclude | null
  }



  /**
   * Model project_likes
   */


  export type AggregateProject_likes = {
    count: Project_likesCountAggregateOutputType | null
    avg: Project_likesAvgAggregateOutputType | null
    sum: Project_likesSumAggregateOutputType | null
    min: Project_likesMinAggregateOutputType | null
    max: Project_likesMaxAggregateOutputType | null
  }

  export type Project_likesAvgAggregateOutputType = {
    id: number
    user_id: number
    project_id: number
    companiesId: number | null
  }

  export type Project_likesSumAggregateOutputType = {
    id: number
    user_id: number
    project_id: number
    companiesId: number | null
  }

  export type Project_likesMinAggregateOutputType = {
    id: number
    user_id: number
    project_id: number
    is_liked: boolean | null
    created_at: Date | null
    updated_at: Date | null
    companiesId: number | null
  }

  export type Project_likesMaxAggregateOutputType = {
    id: number
    user_id: number
    project_id: number
    is_liked: boolean | null
    created_at: Date | null
    updated_at: Date | null
    companiesId: number | null
  }

  export type Project_likesCountAggregateOutputType = {
    id: number
    user_id: number
    project_id: number
    is_liked: number | null
    created_at: number | null
    updated_at: number | null
    companiesId: number | null
    _all: number
  }


  export type Project_likesAvgAggregateInputType = {
    id?: true
    user_id?: true
    project_id?: true
    companiesId?: true
  }

  export type Project_likesSumAggregateInputType = {
    id?: true
    user_id?: true
    project_id?: true
    companiesId?: true
  }

  export type Project_likesMinAggregateInputType = {
    id?: true
    user_id?: true
    project_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
    companiesId?: true
  }

  export type Project_likesMaxAggregateInputType = {
    id?: true
    user_id?: true
    project_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
    companiesId?: true
  }

  export type Project_likesCountAggregateInputType = {
    id?: true
    user_id?: true
    project_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
    companiesId?: true
    _all?: true
  }

  export type Project_likesAggregateArgs = {
    /**
     * Filter which project_likes to aggregate.
    **/
    where?: project_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of project_likes to fetch.
    **/
    orderBy?: Enumerable<project_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: project_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_likes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned project_likes
    **/
    count?: true | Project_likesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Project_likesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Project_likesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Project_likesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Project_likesMaxAggregateInputType
  }

  export type GetProject_likesAggregateType<T extends Project_likesAggregateArgs> = {
    [P in keyof T & keyof AggregateProject_likes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject_likes[P]>
      : GetScalarType<T[P], AggregateProject_likes[P]>
  }



  export type project_likesSelect = {
    id?: boolean
    user_id?: boolean
    project_id?: boolean
    is_liked?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersArgs
    projects?: boolean | projectsArgs
    companies?: boolean | companiesArgs
    companiesId?: boolean
  }

  export type project_likesInclude = {
    users?: boolean | usersArgs
    projects?: boolean | projectsArgs
    companies?: boolean | companiesArgs
  }

  export type project_likesGetPayload<
    S extends boolean | null | undefined | project_likesArgs,
    U = keyof S
      > = S extends true
        ? project_likes
    : S extends undefined
    ? never
    : S extends project_likesArgs | project_likesFindManyArgs
    ?'include' extends U
    ? project_likes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'users'
        ? usersGetPayload<S['include'][P]> :
        P extends 'projects'
        ? projectsGetPayload<S['include'][P]> :
        P extends 'companies'
        ? companiesGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof project_likes ?project_likes [P]
  : 
          P extends 'users'
        ? usersGetPayload<S['select'][P]> :
        P extends 'projects'
        ? projectsGetPayload<S['select'][P]> :
        P extends 'companies'
        ? companiesGetPayload<S['select'][P]> | null : never
  } 
    : project_likes
  : project_likes


  type project_likesCountArgs = Merge<
    Omit<project_likesFindManyArgs, 'select' | 'include'> & {
      select?: Project_likesCountAggregateInputType | true
    }
  >

  export interface project_likesDelegate {
    /**
     * Find zero or one Project_likes that matches the filter.
     * @param {project_likesFindUniqueArgs} args - Arguments to find a Project_likes
     * @example
     * // Get one Project_likes
     * const project_likes = await prisma.project_likes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends project_likesFindUniqueArgs>(
      args: SelectSubset<T, project_likesFindUniqueArgs>
    ): CheckSelect<T, Prisma__project_likesClient<project_likes | null>, Prisma__project_likesClient<project_likesGetPayload<T> | null>>

    /**
     * Find the first Project_likes that matches the filter.
     * @param {project_likesFindFirstArgs} args - Arguments to find a Project_likes
     * @example
     * // Get one Project_likes
     * const project_likes = await prisma.project_likes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends project_likesFindFirstArgs>(
      args?: SelectSubset<T, project_likesFindFirstArgs>
    ): CheckSelect<T, Prisma__project_likesClient<project_likes | null>, Prisma__project_likesClient<project_likesGetPayload<T> | null>>

    /**
     * Find zero or more Project_likes that matches the filter.
     * @param {project_likesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Project_likes
     * const project_likes = await prisma.project_likes.findMany()
     * 
     * // Get first 10 Project_likes
     * const project_likes = await prisma.project_likes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const project_likesWithIdOnly = await prisma.project_likes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends project_likesFindManyArgs>(
      args?: SelectSubset<T, project_likesFindManyArgs>
    ): CheckSelect<T, Promise<Array<project_likes>>, Promise<Array<project_likesGetPayload<T>>>>

    /**
     * Create a Project_likes.
     * @param {project_likesCreateArgs} args - Arguments to create a Project_likes.
     * @example
     * // Create one Project_likes
     * const Project_likes = await prisma.project_likes.create({
     *   data: {
     *     // ... data to create a Project_likes
     *   }
     * })
     * 
    **/
    create<T extends project_likesCreateArgs>(
      args: SelectSubset<T, project_likesCreateArgs>
    ): CheckSelect<T, Prisma__project_likesClient<project_likes>, Prisma__project_likesClient<project_likesGetPayload<T>>>

    /**
     * Delete a Project_likes.
     * @param {project_likesDeleteArgs} args - Arguments to delete one Project_likes.
     * @example
     * // Delete one Project_likes
     * const Project_likes = await prisma.project_likes.delete({
     *   where: {
     *     // ... filter to delete one Project_likes
     *   }
     * })
     * 
    **/
    delete<T extends project_likesDeleteArgs>(
      args: SelectSubset<T, project_likesDeleteArgs>
    ): CheckSelect<T, Prisma__project_likesClient<project_likes>, Prisma__project_likesClient<project_likesGetPayload<T>>>

    /**
     * Update one Project_likes.
     * @param {project_likesUpdateArgs} args - Arguments to update one Project_likes.
     * @example
     * // Update one Project_likes
     * const project_likes = await prisma.project_likes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends project_likesUpdateArgs>(
      args: SelectSubset<T, project_likesUpdateArgs>
    ): CheckSelect<T, Prisma__project_likesClient<project_likes>, Prisma__project_likesClient<project_likesGetPayload<T>>>

    /**
     * Delete zero or more Project_likes.
     * @param {project_likesDeleteManyArgs} args - Arguments to filter Project_likes to delete.
     * @example
     * // Delete a few Project_likes
     * const { count } = await prisma.project_likes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends project_likesDeleteManyArgs>(
      args?: SelectSubset<T, project_likesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Project_likes.
     * @param {project_likesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Project_likes
     * const project_likes = await prisma.project_likes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends project_likesUpdateManyArgs>(
      args: SelectSubset<T, project_likesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Project_likes.
     * @param {project_likesUpsertArgs} args - Arguments to update or create a Project_likes.
     * @example
     * // Update or create a Project_likes
     * const project_likes = await prisma.project_likes.upsert({
     *   create: {
     *     // ... data to create a Project_likes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project_likes we want to update
     *   }
     * })
    **/
    upsert<T extends project_likesUpsertArgs>(
      args: SelectSubset<T, project_likesUpsertArgs>
    ): CheckSelect<T, Prisma__project_likesClient<project_likes>, Prisma__project_likesClient<project_likesGetPayload<T>>>

    /**
     * Count the number of Project_likes.
     * @param {project_likesCountArgs} args - Arguments to filter Project_likes to count.
     * @example
     * // Count the number of Project_likes
     * const count = await prisma.project_likes.count({
     *   where: {
     *     // ... the filter for the Project_likes we want to count
     *   }
     * })
    **/
    count<T extends project_likesCountArgs>(
      args?: Subset<T, project_likesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Project_likesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project_likes.
     * @param {Project_likesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Project_likesAggregateArgs>(args: Subset<T, Project_likesAggregateArgs>): Promise<GetProject_likesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for project_likes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__project_likesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>;

    projects<T extends projectsArgs = {}>(args?: Subset<T, projectsArgs>): CheckSelect<T, Prisma__projectsClient<projects | null>, Prisma__projectsClient<projectsGetPayload<T> | null>>;

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * project_likes findUnique
   */
  export type project_likesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the project_likes
    **/
    select?: project_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_likesInclude | null
    /**
     * Throw an Error if a project_likes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which project_likes to fetch.
    **/
    where: project_likesWhereUniqueInput
  }


  /**
   * project_likes findFirst
   */
  export type project_likesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the project_likes
    **/
    select?: project_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_likesInclude | null
    /**
     * Throw an Error if a project_likes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which project_likes to fetch.
    **/
    where?: project_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of project_likes to fetch.
    **/
    orderBy?: Enumerable<project_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for project_likes.
    **/
    cursor?: project_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_likes.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of project_likes.
    **/
    distinct?: Enumerable<Project_likesScalarFieldEnum>
  }


  /**
   * project_likes findMany
   */
  export type project_likesFindManyArgs = {
    /**
     * Select specific fields to fetch from the project_likes
    **/
    select?: project_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_likesInclude | null
    /**
     * Filter, which project_likes to fetch.
    **/
    where?: project_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of project_likes to fetch.
    **/
    orderBy?: Enumerable<project_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing project_likes.
    **/
    cursor?: project_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` project_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` project_likes.
    **/
    skip?: number
    distinct?: Enumerable<Project_likesScalarFieldEnum>
  }


  /**
   * project_likes create
   */
  export type project_likesCreateArgs = {
    /**
     * Select specific fields to fetch from the project_likes
    **/
    select?: project_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_likesInclude | null
    /**
     * The data needed to create a project_likes.
    **/
    data: XOR<project_likesUncheckedCreateInput, project_likesCreateInput>
  }


  /**
   * project_likes update
   */
  export type project_likesUpdateArgs = {
    /**
     * Select specific fields to fetch from the project_likes
    **/
    select?: project_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_likesInclude | null
    /**
     * The data needed to update a project_likes.
    **/
    data: XOR<project_likesUncheckedUpdateInput, project_likesUpdateInput>
    /**
     * Choose, which project_likes to update.
    **/
    where: project_likesWhereUniqueInput
  }


  /**
   * project_likes updateMany
   */
  export type project_likesUpdateManyArgs = {
    data: XOR<project_likesUncheckedUpdateManyInput, project_likesUpdateManyMutationInput>
    where?: project_likesWhereInput
  }


  /**
   * project_likes upsert
   */
  export type project_likesUpsertArgs = {
    /**
     * Select specific fields to fetch from the project_likes
    **/
    select?: project_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_likesInclude | null
    /**
     * The filter to search for the project_likes to update in case it exists.
    **/
    where: project_likesWhereUniqueInput
    /**
     * In case the project_likes found by the `where` argument doesn't exist, create a new project_likes with this data.
    **/
    create: XOR<project_likesUncheckedCreateInput, project_likesCreateInput>
    /**
     * In case the project_likes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<project_likesUncheckedUpdateInput, project_likesUpdateInput>
  }


  /**
   * project_likes delete
   */
  export type project_likesDeleteArgs = {
    /**
     * Select specific fields to fetch from the project_likes
    **/
    select?: project_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_likesInclude | null
    /**
     * Filter which project_likes to delete.
    **/
    where: project_likesWhereUniqueInput
  }


  /**
   * project_likes deleteMany
   */
  export type project_likesDeleteManyArgs = {
    where?: project_likesWhereInput
  }


  /**
   * project_likes without action
   */
  export type project_likesArgs = {
    /**
     * Select specific fields to fetch from the project_likes
    **/
    select?: project_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: project_likesInclude | null
  }



  /**
   * Model projects
   */


  export type AggregateProjects = {
    count: ProjectsCountAggregateOutputType | null
    avg: ProjectsAvgAggregateOutputType | null
    sum: ProjectsSumAggregateOutputType | null
    min: ProjectsMinAggregateOutputType | null
    max: ProjectsMaxAggregateOutputType | null
  }

  export type ProjectsAvgAggregateOutputType = {
    id: number
    company_id: number | null
    eligible_sector: number | null
    eligibility: number | null
    hit: number
  }

  export type ProjectsSumAggregateOutputType = {
    id: number
    company_id: number | null
    eligible_sector: number | null
    eligibility: number | null
    hit: number
  }

  export type ProjectsMinAggregateOutputType = {
    id: number
    name: string | null
    introduction: string | null
    company_id: number | null
    host: string | null
    due_date: Date | null
    eligible_sector: number | null
    eligibility: number | null
    outline: string | null
    detail: string | null
    application_method: string | null
    caution: string | null
    contact: string | null
    is_opened: boolean | null
    hit: number
    application_url: string | null
    is_saved: boolean | null
    request_open: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProjectsMaxAggregateOutputType = {
    id: number
    name: string | null
    introduction: string | null
    company_id: number | null
    host: string | null
    due_date: Date | null
    eligible_sector: number | null
    eligibility: number | null
    outline: string | null
    detail: string | null
    application_method: string | null
    caution: string | null
    contact: string | null
    is_opened: boolean | null
    hit: number
    application_url: string | null
    is_saved: boolean | null
    request_open: boolean | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type ProjectsCountAggregateOutputType = {
    id: number
    name: number | null
    introduction: number | null
    company_id: number | null
    host: number | null
    due_date: number | null
    eligible_sector: number | null
    eligibility: number | null
    outline: number | null
    detail: number | null
    application_method: number | null
    caution: number | null
    contact: number | null
    is_opened: number | null
    hit: number
    application_url: number | null
    is_saved: number | null
    request_open: number | null
    created_at: number | null
    updated_at: number | null
    deleted_at: number | null
    _all: number
  }


  export type ProjectsAvgAggregateInputType = {
    id?: true
    company_id?: true
    eligible_sector?: true
    eligibility?: true
    hit?: true
  }

  export type ProjectsSumAggregateInputType = {
    id?: true
    company_id?: true
    eligible_sector?: true
    eligibility?: true
    hit?: true
  }

  export type ProjectsMinAggregateInputType = {
    id?: true
    name?: true
    introduction?: true
    company_id?: true
    host?: true
    due_date?: true
    eligible_sector?: true
    eligibility?: true
    outline?: true
    detail?: true
    application_method?: true
    caution?: true
    contact?: true
    is_opened?: true
    hit?: true
    application_url?: true
    is_saved?: true
    request_open?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProjectsMaxAggregateInputType = {
    id?: true
    name?: true
    introduction?: true
    company_id?: true
    host?: true
    due_date?: true
    eligible_sector?: true
    eligibility?: true
    outline?: true
    detail?: true
    application_method?: true
    caution?: true
    contact?: true
    is_opened?: true
    hit?: true
    application_url?: true
    is_saved?: true
    request_open?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type ProjectsCountAggregateInputType = {
    id?: true
    name?: true
    introduction?: true
    company_id?: true
    host?: true
    due_date?: true
    eligible_sector?: true
    eligibility?: true
    outline?: true
    detail?: true
    application_method?: true
    caution?: true
    contact?: true
    is_opened?: true
    hit?: true
    application_url?: true
    is_saved?: true
    request_open?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type ProjectsAggregateArgs = {
    /**
     * Filter which projects to aggregate.
    **/
    where?: projectsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of projects to fetch.
    **/
    orderBy?: Enumerable<projectsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projects
    **/
    count?: true | ProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ProjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ProjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ProjectsMaxAggregateInputType
  }

  export type GetProjectsAggregateType<T extends ProjectsAggregateArgs> = {
    [P in keyof T & keyof AggregateProjects]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjects[P]>
      : GetScalarType<T[P], AggregateProjects[P]>
  }



  export type projectsSelect = {
    id?: boolean
    name?: boolean
    introduction?: boolean
    company_id?: boolean
    host?: boolean
    due_date?: boolean
    eligible_sector?: boolean
    eligibility?: boolean
    outline?: boolean
    detail?: boolean
    application_method?: boolean
    caution?: boolean
    contact?: boolean
    is_opened?: boolean
    hit?: boolean
    application_url?: boolean
    is_saved?: boolean
    request_open?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    eligible_sectors?: boolean | eligible_sectorsArgs
    eligibilities?: boolean | eligibilitiesArgs
    companies?: boolean | companiesArgs
    applicants?: boolean | applicantsFindManyArgs
    project_images?: boolean | project_imagesFindManyArgs
    project_likes?: boolean | project_likesFindManyArgs
    recent_views_project?: boolean | recent_views_projectFindManyArgs
    required_documents?: boolean | required_documentsFindManyArgs
  }

  export type projectsInclude = {
    eligible_sectors?: boolean | eligible_sectorsArgs
    eligibilities?: boolean | eligibilitiesArgs
    companies?: boolean | companiesArgs
    applicants?: boolean | applicantsFindManyArgs
    project_images?: boolean | project_imagesFindManyArgs
    project_likes?: boolean | project_likesFindManyArgs
    recent_views_project?: boolean | recent_views_projectFindManyArgs
    required_documents?: boolean | required_documentsFindManyArgs
  }

  export type projectsGetPayload<
    S extends boolean | null | undefined | projectsArgs,
    U = keyof S
      > = S extends true
        ? projects
    : S extends undefined
    ? never
    : S extends projectsArgs | projectsFindManyArgs
    ?'include' extends U
    ? projects  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'eligible_sectors'
        ? eligible_sectorsGetPayload<S['include'][P]> | null :
        P extends 'eligibilities'
        ? eligibilitiesGetPayload<S['include'][P]> | null :
        P extends 'companies'
        ? companiesGetPayload<S['include'][P]> | null :
        P extends 'applicants'
        ? Array < applicantsGetPayload<S['include'][P]>>  :
        P extends 'project_images'
        ? Array < project_imagesGetPayload<S['include'][P]>>  :
        P extends 'project_likes'
        ? Array < project_likesGetPayload<S['include'][P]>>  :
        P extends 'recent_views_project'
        ? Array < recent_views_projectGetPayload<S['include'][P]>>  :
        P extends 'required_documents'
        ? Array < required_documentsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof projects ?projects [P]
  : 
          P extends 'eligible_sectors'
        ? eligible_sectorsGetPayload<S['select'][P]> | null :
        P extends 'eligibilities'
        ? eligibilitiesGetPayload<S['select'][P]> | null :
        P extends 'companies'
        ? companiesGetPayload<S['select'][P]> | null :
        P extends 'applicants'
        ? Array < applicantsGetPayload<S['select'][P]>>  :
        P extends 'project_images'
        ? Array < project_imagesGetPayload<S['select'][P]>>  :
        P extends 'project_likes'
        ? Array < project_likesGetPayload<S['select'][P]>>  :
        P extends 'recent_views_project'
        ? Array < recent_views_projectGetPayload<S['select'][P]>>  :
        P extends 'required_documents'
        ? Array < required_documentsGetPayload<S['select'][P]>>  : never
  } 
    : projects
  : projects


  type projectsCountArgs = Merge<
    Omit<projectsFindManyArgs, 'select' | 'include'> & {
      select?: ProjectsCountAggregateInputType | true
    }
  >

  export interface projectsDelegate {
    /**
     * Find zero or one Projects that matches the filter.
     * @param {projectsFindUniqueArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends projectsFindUniqueArgs>(
      args: SelectSubset<T, projectsFindUniqueArgs>
    ): CheckSelect<T, Prisma__projectsClient<projects | null>, Prisma__projectsClient<projectsGetPayload<T> | null>>

    /**
     * Find the first Projects that matches the filter.
     * @param {projectsFindFirstArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends projectsFindFirstArgs>(
      args?: SelectSubset<T, projectsFindFirstArgs>
    ): CheckSelect<T, Prisma__projectsClient<projects | null>, Prisma__projectsClient<projectsGetPayload<T> | null>>

    /**
     * Find zero or more Projects that matches the filter.
     * @param {projectsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.projects.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.projects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectsWithIdOnly = await prisma.projects.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends projectsFindManyArgs>(
      args?: SelectSubset<T, projectsFindManyArgs>
    ): CheckSelect<T, Promise<Array<projects>>, Promise<Array<projectsGetPayload<T>>>>

    /**
     * Create a Projects.
     * @param {projectsCreateArgs} args - Arguments to create a Projects.
     * @example
     * // Create one Projects
     * const Projects = await prisma.projects.create({
     *   data: {
     *     // ... data to create a Projects
     *   }
     * })
     * 
    **/
    create<T extends projectsCreateArgs>(
      args: SelectSubset<T, projectsCreateArgs>
    ): CheckSelect<T, Prisma__projectsClient<projects>, Prisma__projectsClient<projectsGetPayload<T>>>

    /**
     * Delete a Projects.
     * @param {projectsDeleteArgs} args - Arguments to delete one Projects.
     * @example
     * // Delete one Projects
     * const Projects = await prisma.projects.delete({
     *   where: {
     *     // ... filter to delete one Projects
     *   }
     * })
     * 
    **/
    delete<T extends projectsDeleteArgs>(
      args: SelectSubset<T, projectsDeleteArgs>
    ): CheckSelect<T, Prisma__projectsClient<projects>, Prisma__projectsClient<projectsGetPayload<T>>>

    /**
     * Update one Projects.
     * @param {projectsUpdateArgs} args - Arguments to update one Projects.
     * @example
     * // Update one Projects
     * const projects = await prisma.projects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends projectsUpdateArgs>(
      args: SelectSubset<T, projectsUpdateArgs>
    ): CheckSelect<T, Prisma__projectsClient<projects>, Prisma__projectsClient<projectsGetPayload<T>>>

    /**
     * Delete zero or more Projects.
     * @param {projectsDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.projects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends projectsDeleteManyArgs>(
      args?: SelectSubset<T, projectsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Projects.
     * @param {projectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends projectsUpdateManyArgs>(
      args: SelectSubset<T, projectsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Projects.
     * @param {projectsUpsertArgs} args - Arguments to update or create a Projects.
     * @example
     * // Update or create a Projects
     * const projects = await prisma.projects.upsert({
     *   create: {
     *     // ... data to create a Projects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projects we want to update
     *   }
     * })
    **/
    upsert<T extends projectsUpsertArgs>(
      args: SelectSubset<T, projectsUpsertArgs>
    ): CheckSelect<T, Prisma__projectsClient<projects>, Prisma__projectsClient<projectsGetPayload<T>>>

    /**
     * Count the number of Projects.
     * @param {projectsCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.projects.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends projectsCountArgs>(
      args?: Subset<T, projectsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projects.
     * @param {ProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectsAggregateArgs>(args: Subset<T, ProjectsAggregateArgs>): Promise<GetProjectsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for projects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__projectsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    eligible_sectors<T extends eligible_sectorsArgs = {}>(args?: Subset<T, eligible_sectorsArgs>): CheckSelect<T, Prisma__eligible_sectorsClient<eligible_sectors | null>, Prisma__eligible_sectorsClient<eligible_sectorsGetPayload<T> | null>>;

    eligibilities<T extends eligibilitiesArgs = {}>(args?: Subset<T, eligibilitiesArgs>): CheckSelect<T, Prisma__eligibilitiesClient<eligibilities | null>, Prisma__eligibilitiesClient<eligibilitiesGetPayload<T> | null>>;

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    applicants<T extends applicantsFindManyArgs = {}>(args?: Subset<T, applicantsFindManyArgs>): CheckSelect<T, Promise<Array<applicants>>, Promise<Array<applicantsGetPayload<T>>>>;

    project_images<T extends project_imagesFindManyArgs = {}>(args?: Subset<T, project_imagesFindManyArgs>): CheckSelect<T, Promise<Array<project_images>>, Promise<Array<project_imagesGetPayload<T>>>>;

    project_likes<T extends project_likesFindManyArgs = {}>(args?: Subset<T, project_likesFindManyArgs>): CheckSelect<T, Promise<Array<project_likes>>, Promise<Array<project_likesGetPayload<T>>>>;

    recent_views_project<T extends recent_views_projectFindManyArgs = {}>(args?: Subset<T, recent_views_projectFindManyArgs>): CheckSelect<T, Promise<Array<recent_views_project>>, Promise<Array<recent_views_projectGetPayload<T>>>>;

    required_documents<T extends required_documentsFindManyArgs = {}>(args?: Subset<T, required_documentsFindManyArgs>): CheckSelect<T, Promise<Array<required_documents>>, Promise<Array<required_documentsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * projects findUnique
   */
  export type projectsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the projects
    **/
    select?: projectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: projectsInclude | null
    /**
     * Throw an Error if a projects can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which projects to fetch.
    **/
    where: projectsWhereUniqueInput
  }


  /**
   * projects findFirst
   */
  export type projectsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the projects
    **/
    select?: projectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: projectsInclude | null
    /**
     * Throw an Error if a projects can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which projects to fetch.
    **/
    where?: projectsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of projects to fetch.
    **/
    orderBy?: Enumerable<projectsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
    **/
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of projects.
    **/
    distinct?: Enumerable<ProjectsScalarFieldEnum>
  }


  /**
   * projects findMany
   */
  export type projectsFindManyArgs = {
    /**
     * Select specific fields to fetch from the projects
    **/
    select?: projectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: projectsInclude | null
    /**
     * Filter, which projects to fetch.
    **/
    where?: projectsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of projects to fetch.
    **/
    orderBy?: Enumerable<projectsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projects.
    **/
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
    **/
    skip?: number
    distinct?: Enumerable<ProjectsScalarFieldEnum>
  }


  /**
   * projects create
   */
  export type projectsCreateArgs = {
    /**
     * Select specific fields to fetch from the projects
    **/
    select?: projectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: projectsInclude | null
    /**
     * The data needed to create a projects.
    **/
    data: XOR<projectsUncheckedCreateInput, projectsCreateInput>
  }


  /**
   * projects update
   */
  export type projectsUpdateArgs = {
    /**
     * Select specific fields to fetch from the projects
    **/
    select?: projectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: projectsInclude | null
    /**
     * The data needed to update a projects.
    **/
    data: XOR<projectsUncheckedUpdateInput, projectsUpdateInput>
    /**
     * Choose, which projects to update.
    **/
    where: projectsWhereUniqueInput
  }


  /**
   * projects updateMany
   */
  export type projectsUpdateManyArgs = {
    data: XOR<projectsUncheckedUpdateManyInput, projectsUpdateManyMutationInput>
    where?: projectsWhereInput
  }


  /**
   * projects upsert
   */
  export type projectsUpsertArgs = {
    /**
     * Select specific fields to fetch from the projects
    **/
    select?: projectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: projectsInclude | null
    /**
     * The filter to search for the projects to update in case it exists.
    **/
    where: projectsWhereUniqueInput
    /**
     * In case the projects found by the `where` argument doesn't exist, create a new projects with this data.
    **/
    create: XOR<projectsUncheckedCreateInput, projectsCreateInput>
    /**
     * In case the projects was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<projectsUncheckedUpdateInput, projectsUpdateInput>
  }


  /**
   * projects delete
   */
  export type projectsDeleteArgs = {
    /**
     * Select specific fields to fetch from the projects
    **/
    select?: projectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: projectsInclude | null
    /**
     * Filter which projects to delete.
    **/
    where: projectsWhereUniqueInput
  }


  /**
   * projects deleteMany
   */
  export type projectsDeleteManyArgs = {
    where?: projectsWhereInput
  }


  /**
   * projects without action
   */
  export type projectsArgs = {
    /**
     * Select specific fields to fetch from the projects
    **/
    select?: projectsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: projectsInclude | null
  }



  /**
   * Model questions
   */


  export type AggregateQuestions = {
    count: QuestionsCountAggregateOutputType | null
    avg: QuestionsAvgAggregateOutputType | null
    sum: QuestionsSumAggregateOutputType | null
    min: QuestionsMinAggregateOutputType | null
    max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    id: number
    company_id: number
    user_id: number
    demoday_id: number
  }

  export type QuestionsSumAggregateOutputType = {
    id: number
    company_id: number
    user_id: number
    demoday_id: number
  }

  export type QuestionsMinAggregateOutputType = {
    id: number
    content: string | null
    company_id: number
    user_id: number
    created_at: Date | null
    updated_at: Date | null
    demoday_id: number
  }

  export type QuestionsMaxAggregateOutputType = {
    id: number
    content: string | null
    company_id: number
    user_id: number
    created_at: Date | null
    updated_at: Date | null
    demoday_id: number
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    content: number | null
    company_id: number
    user_id: number
    created_at: number | null
    updated_at: number | null
    demoday_id: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    id?: true
    company_id?: true
    user_id?: true
    demoday_id?: true
  }

  export type QuestionsSumAggregateInputType = {
    id?: true
    company_id?: true
    user_id?: true
    demoday_id?: true
  }

  export type QuestionsMinAggregateInputType = {
    id?: true
    content?: true
    company_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    demoday_id?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    content?: true
    company_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    demoday_id?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    content?: true
    company_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    demoday_id?: true
    _all?: true
  }

  export type QuestionsAggregateArgs = {
    /**
     * Filter which questions to aggregate.
    **/
    where?: questionsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of questions to fetch.
    **/
    orderBy?: Enumerable<questionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
    [P in keyof T & keyof AggregateQuestions]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }



  export type questionsSelect = {
    id?: boolean
    content?: boolean
    company_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    demoday_id?: boolean
    companies?: boolean | companiesArgs
    demodays?: boolean | demodaysArgs
    users?: boolean | usersArgs
    answers?: boolean | answersFindManyArgs
  }

  export type questionsInclude = {
    companies?: boolean | companiesArgs
    demodays?: boolean | demodaysArgs
    users?: boolean | usersArgs
    answers?: boolean | answersFindManyArgs
  }

  export type questionsGetPayload<
    S extends boolean | null | undefined | questionsArgs,
    U = keyof S
      > = S extends true
        ? questions
    : S extends undefined
    ? never
    : S extends questionsArgs | questionsFindManyArgs
    ?'include' extends U
    ? questions  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'demodays'
        ? demodaysGetPayload<S['include'][P]> :
        P extends 'users'
        ? usersGetPayload<S['include'][P]> :
        P extends 'answers'
        ? Array < answersGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof questions ?questions [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'demodays'
        ? demodaysGetPayload<S['select'][P]> :
        P extends 'users'
        ? usersGetPayload<S['select'][P]> :
        P extends 'answers'
        ? Array < answersGetPayload<S['select'][P]>>  : never
  } 
    : questions
  : questions


  type questionsCountArgs = Merge<
    Omit<questionsFindManyArgs, 'select' | 'include'> & {
      select?: QuestionsCountAggregateInputType | true
    }
  >

  export interface questionsDelegate {
    /**
     * Find zero or one Questions that matches the filter.
     * @param {questionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends questionsFindUniqueArgs>(
      args: SelectSubset<T, questionsFindUniqueArgs>
    ): CheckSelect<T, Prisma__questionsClient<questions | null>, Prisma__questionsClient<questionsGetPayload<T> | null>>

    /**
     * Find the first Questions that matches the filter.
     * @param {questionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends questionsFindFirstArgs>(
      args?: SelectSubset<T, questionsFindFirstArgs>
    ): CheckSelect<T, Prisma__questionsClient<questions | null>, Prisma__questionsClient<questionsGetPayload<T> | null>>

    /**
     * Find zero or more Questions that matches the filter.
     * @param {questionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends questionsFindManyArgs>(
      args?: SelectSubset<T, questionsFindManyArgs>
    ): CheckSelect<T, Promise<Array<questions>>, Promise<Array<questionsGetPayload<T>>>>

    /**
     * Create a Questions.
     * @param {questionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
    **/
    create<T extends questionsCreateArgs>(
      args: SelectSubset<T, questionsCreateArgs>
    ): CheckSelect<T, Prisma__questionsClient<questions>, Prisma__questionsClient<questionsGetPayload<T>>>

    /**
     * Delete a Questions.
     * @param {questionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
    **/
    delete<T extends questionsDeleteArgs>(
      args: SelectSubset<T, questionsDeleteArgs>
    ): CheckSelect<T, Prisma__questionsClient<questions>, Prisma__questionsClient<questionsGetPayload<T>>>

    /**
     * Update one Questions.
     * @param {questionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends questionsUpdateArgs>(
      args: SelectSubset<T, questionsUpdateArgs>
    ): CheckSelect<T, Prisma__questionsClient<questions>, Prisma__questionsClient<questionsGetPayload<T>>>

    /**
     * Delete zero or more Questions.
     * @param {questionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends questionsDeleteManyArgs>(
      args?: SelectSubset<T, questionsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Questions.
     * @param {questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends questionsUpdateManyArgs>(
      args: SelectSubset<T, questionsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Questions.
     * @param {questionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
    **/
    upsert<T extends questionsUpsertArgs>(
      args: SelectSubset<T, questionsUpsertArgs>
    ): CheckSelect<T, Prisma__questionsClient<questions>, Prisma__questionsClient<questionsGetPayload<T>>>

    /**
     * Count the number of Questions.
     * @param {questionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionsCountArgs>(
      args?: Subset<T, questionsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Promise<GetQuestionsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__questionsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    demodays<T extends demodaysArgs = {}>(args?: Subset<T, demodaysArgs>): CheckSelect<T, Prisma__demodaysClient<demodays | null>, Prisma__demodaysClient<demodaysGetPayload<T> | null>>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>;

    answers<T extends answersFindManyArgs = {}>(args?: Subset<T, answersFindManyArgs>): CheckSelect<T, Promise<Array<answers>>, Promise<Array<answersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * questions findUnique
   */
  export type questionsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the questions
    **/
    select?: questionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: questionsInclude | null
    /**
     * Throw an Error if a questions can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which questions to fetch.
    **/
    where: questionsWhereUniqueInput
  }


  /**
   * questions findFirst
   */
  export type questionsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the questions
    **/
    select?: questionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: questionsInclude | null
    /**
     * Throw an Error if a questions can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which questions to fetch.
    **/
    where?: questionsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of questions to fetch.
    **/
    orderBy?: Enumerable<questionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
    **/
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of questions.
    **/
    distinct?: Enumerable<QuestionsScalarFieldEnum>
  }


  /**
   * questions findMany
   */
  export type questionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the questions
    **/
    select?: questionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: questionsInclude | null
    /**
     * Filter, which questions to fetch.
    **/
    where?: questionsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of questions to fetch.
    **/
    orderBy?: Enumerable<questionsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
    **/
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
    **/
    skip?: number
    distinct?: Enumerable<QuestionsScalarFieldEnum>
  }


  /**
   * questions create
   */
  export type questionsCreateArgs = {
    /**
     * Select specific fields to fetch from the questions
    **/
    select?: questionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: questionsInclude | null
    /**
     * The data needed to create a questions.
    **/
    data: XOR<questionsUncheckedCreateInput, questionsCreateInput>
  }


  /**
   * questions update
   */
  export type questionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the questions
    **/
    select?: questionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: questionsInclude | null
    /**
     * The data needed to update a questions.
    **/
    data: XOR<questionsUncheckedUpdateInput, questionsUpdateInput>
    /**
     * Choose, which questions to update.
    **/
    where: questionsWhereUniqueInput
  }


  /**
   * questions updateMany
   */
  export type questionsUpdateManyArgs = {
    data: XOR<questionsUncheckedUpdateManyInput, questionsUpdateManyMutationInput>
    where?: questionsWhereInput
  }


  /**
   * questions upsert
   */
  export type questionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the questions
    **/
    select?: questionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: questionsInclude | null
    /**
     * The filter to search for the questions to update in case it exists.
    **/
    where: questionsWhereUniqueInput
    /**
     * In case the questions found by the `where` argument doesn't exist, create a new questions with this data.
    **/
    create: XOR<questionsUncheckedCreateInput, questionsCreateInput>
    /**
     * In case the questions was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<questionsUncheckedUpdateInput, questionsUpdateInput>
  }


  /**
   * questions delete
   */
  export type questionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the questions
    **/
    select?: questionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: questionsInclude | null
    /**
     * Filter which questions to delete.
    **/
    where: questionsWhereUniqueInput
  }


  /**
   * questions deleteMany
   */
  export type questionsDeleteManyArgs = {
    where?: questionsWhereInput
  }


  /**
   * questions without action
   */
  export type questionsArgs = {
    /**
     * Select specific fields to fetch from the questions
    **/
    select?: questionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: questionsInclude | null
  }



  /**
   * Model recent_views_project
   */


  export type AggregateRecent_views_project = {
    count: Recent_views_projectCountAggregateOutputType | null
    avg: Recent_views_projectAvgAggregateOutputType | null
    sum: Recent_views_projectSumAggregateOutputType | null
    min: Recent_views_projectMinAggregateOutputType | null
    max: Recent_views_projectMaxAggregateOutputType | null
  }

  export type Recent_views_projectAvgAggregateOutputType = {
    id: number
    project_id: number
    company_id: number
  }

  export type Recent_views_projectSumAggregateOutputType = {
    id: number
    project_id: number
    company_id: number
  }

  export type Recent_views_projectMinAggregateOutputType = {
    id: number
    project_id: number
    company_id: number
    created_at: Date | null
    updated_at: Date | null
  }

  export type Recent_views_projectMaxAggregateOutputType = {
    id: number
    project_id: number
    company_id: number
    created_at: Date | null
    updated_at: Date | null
  }

  export type Recent_views_projectCountAggregateOutputType = {
    id: number
    project_id: number
    company_id: number
    created_at: number | null
    updated_at: number | null
    _all: number
  }


  export type Recent_views_projectAvgAggregateInputType = {
    id?: true
    project_id?: true
    company_id?: true
  }

  export type Recent_views_projectSumAggregateInputType = {
    id?: true
    project_id?: true
    company_id?: true
  }

  export type Recent_views_projectMinAggregateInputType = {
    id?: true
    project_id?: true
    company_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Recent_views_projectMaxAggregateInputType = {
    id?: true
    project_id?: true
    company_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Recent_views_projectCountAggregateInputType = {
    id?: true
    project_id?: true
    company_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Recent_views_projectAggregateArgs = {
    /**
     * Filter which recent_views_project to aggregate.
    **/
    where?: recent_views_projectWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of recent_views_projects to fetch.
    **/
    orderBy?: Enumerable<recent_views_projectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: recent_views_projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recent_views_projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recent_views_projects.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recent_views_projects
    **/
    count?: true | Recent_views_projectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Recent_views_projectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Recent_views_projectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Recent_views_projectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Recent_views_projectMaxAggregateInputType
  }

  export type GetRecent_views_projectAggregateType<T extends Recent_views_projectAggregateArgs> = {
    [P in keyof T & keyof AggregateRecent_views_project]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecent_views_project[P]>
      : GetScalarType<T[P], AggregateRecent_views_project[P]>
  }



  export type recent_views_projectSelect = {
    id?: boolean
    project_id?: boolean
    company_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesArgs
    projects?: boolean | projectsArgs
  }

  export type recent_views_projectInclude = {
    companies?: boolean | companiesArgs
    projects?: boolean | projectsArgs
  }

  export type recent_views_projectGetPayload<
    S extends boolean | null | undefined | recent_views_projectArgs,
    U = keyof S
      > = S extends true
        ? recent_views_project
    : S extends undefined
    ? never
    : S extends recent_views_projectArgs | recent_views_projectFindManyArgs
    ?'include' extends U
    ? recent_views_project  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'projects'
        ? projectsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof recent_views_project ?recent_views_project [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'projects'
        ? projectsGetPayload<S['select'][P]> : never
  } 
    : recent_views_project
  : recent_views_project


  type recent_views_projectCountArgs = Merge<
    Omit<recent_views_projectFindManyArgs, 'select' | 'include'> & {
      select?: Recent_views_projectCountAggregateInputType | true
    }
  >

  export interface recent_views_projectDelegate {
    /**
     * Find zero or one Recent_views_project that matches the filter.
     * @param {recent_views_projectFindUniqueArgs} args - Arguments to find a Recent_views_project
     * @example
     * // Get one Recent_views_project
     * const recent_views_project = await prisma.recent_views_project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends recent_views_projectFindUniqueArgs>(
      args: SelectSubset<T, recent_views_projectFindUniqueArgs>
    ): CheckSelect<T, Prisma__recent_views_projectClient<recent_views_project | null>, Prisma__recent_views_projectClient<recent_views_projectGetPayload<T> | null>>

    /**
     * Find the first Recent_views_project that matches the filter.
     * @param {recent_views_projectFindFirstArgs} args - Arguments to find a Recent_views_project
     * @example
     * // Get one Recent_views_project
     * const recent_views_project = await prisma.recent_views_project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends recent_views_projectFindFirstArgs>(
      args?: SelectSubset<T, recent_views_projectFindFirstArgs>
    ): CheckSelect<T, Prisma__recent_views_projectClient<recent_views_project | null>, Prisma__recent_views_projectClient<recent_views_projectGetPayload<T> | null>>

    /**
     * Find zero or more Recent_views_projects that matches the filter.
     * @param {recent_views_projectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recent_views_projects
     * const recent_views_projects = await prisma.recent_views_project.findMany()
     * 
     * // Get first 10 Recent_views_projects
     * const recent_views_projects = await prisma.recent_views_project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recent_views_projectWithIdOnly = await prisma.recent_views_project.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends recent_views_projectFindManyArgs>(
      args?: SelectSubset<T, recent_views_projectFindManyArgs>
    ): CheckSelect<T, Promise<Array<recent_views_project>>, Promise<Array<recent_views_projectGetPayload<T>>>>

    /**
     * Create a Recent_views_project.
     * @param {recent_views_projectCreateArgs} args - Arguments to create a Recent_views_project.
     * @example
     * // Create one Recent_views_project
     * const Recent_views_project = await prisma.recent_views_project.create({
     *   data: {
     *     // ... data to create a Recent_views_project
     *   }
     * })
     * 
    **/
    create<T extends recent_views_projectCreateArgs>(
      args: SelectSubset<T, recent_views_projectCreateArgs>
    ): CheckSelect<T, Prisma__recent_views_projectClient<recent_views_project>, Prisma__recent_views_projectClient<recent_views_projectGetPayload<T>>>

    /**
     * Delete a Recent_views_project.
     * @param {recent_views_projectDeleteArgs} args - Arguments to delete one Recent_views_project.
     * @example
     * // Delete one Recent_views_project
     * const Recent_views_project = await prisma.recent_views_project.delete({
     *   where: {
     *     // ... filter to delete one Recent_views_project
     *   }
     * })
     * 
    **/
    delete<T extends recent_views_projectDeleteArgs>(
      args: SelectSubset<T, recent_views_projectDeleteArgs>
    ): CheckSelect<T, Prisma__recent_views_projectClient<recent_views_project>, Prisma__recent_views_projectClient<recent_views_projectGetPayload<T>>>

    /**
     * Update one Recent_views_project.
     * @param {recent_views_projectUpdateArgs} args - Arguments to update one Recent_views_project.
     * @example
     * // Update one Recent_views_project
     * const recent_views_project = await prisma.recent_views_project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends recent_views_projectUpdateArgs>(
      args: SelectSubset<T, recent_views_projectUpdateArgs>
    ): CheckSelect<T, Prisma__recent_views_projectClient<recent_views_project>, Prisma__recent_views_projectClient<recent_views_projectGetPayload<T>>>

    /**
     * Delete zero or more Recent_views_projects.
     * @param {recent_views_projectDeleteManyArgs} args - Arguments to filter Recent_views_projects to delete.
     * @example
     * // Delete a few Recent_views_projects
     * const { count } = await prisma.recent_views_project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends recent_views_projectDeleteManyArgs>(
      args?: SelectSubset<T, recent_views_projectDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Recent_views_projects.
     * @param {recent_views_projectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recent_views_projects
     * const recent_views_project = await prisma.recent_views_project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends recent_views_projectUpdateManyArgs>(
      args: SelectSubset<T, recent_views_projectUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Recent_views_project.
     * @param {recent_views_projectUpsertArgs} args - Arguments to update or create a Recent_views_project.
     * @example
     * // Update or create a Recent_views_project
     * const recent_views_project = await prisma.recent_views_project.upsert({
     *   create: {
     *     // ... data to create a Recent_views_project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recent_views_project we want to update
     *   }
     * })
    **/
    upsert<T extends recent_views_projectUpsertArgs>(
      args: SelectSubset<T, recent_views_projectUpsertArgs>
    ): CheckSelect<T, Prisma__recent_views_projectClient<recent_views_project>, Prisma__recent_views_projectClient<recent_views_projectGetPayload<T>>>

    /**
     * Count the number of Recent_views_projects.
     * @param {recent_views_projectCountArgs} args - Arguments to filter Recent_views_projects to count.
     * @example
     * // Count the number of Recent_views_projects
     * const count = await prisma.recent_views_project.count({
     *   where: {
     *     // ... the filter for the Recent_views_projects we want to count
     *   }
     * })
    **/
    count<T extends recent_views_projectCountArgs>(
      args?: Subset<T, recent_views_projectCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Recent_views_projectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recent_views_project.
     * @param {Recent_views_projectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Recent_views_projectAggregateArgs>(args: Subset<T, Recent_views_projectAggregateArgs>): Promise<GetRecent_views_projectAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for recent_views_project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__recent_views_projectClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    projects<T extends projectsArgs = {}>(args?: Subset<T, projectsArgs>): CheckSelect<T, Prisma__projectsClient<projects | null>, Prisma__projectsClient<projectsGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * recent_views_project findUnique
   */
  export type recent_views_projectFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the recent_views_project
    **/
    select?: recent_views_projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: recent_views_projectInclude | null
    /**
     * Throw an Error if a recent_views_project can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which recent_views_project to fetch.
    **/
    where: recent_views_projectWhereUniqueInput
  }


  /**
   * recent_views_project findFirst
   */
  export type recent_views_projectFindFirstArgs = {
    /**
     * Select specific fields to fetch from the recent_views_project
    **/
    select?: recent_views_projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: recent_views_projectInclude | null
    /**
     * Throw an Error if a recent_views_project can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which recent_views_project to fetch.
    **/
    where?: recent_views_projectWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of recent_views_projects to fetch.
    **/
    orderBy?: Enumerable<recent_views_projectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recent_views_projects.
    **/
    cursor?: recent_views_projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recent_views_projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recent_views_projects.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of recent_views_projects.
    **/
    distinct?: Enumerable<Recent_views_projectScalarFieldEnum>
  }


  /**
   * recent_views_project findMany
   */
  export type recent_views_projectFindManyArgs = {
    /**
     * Select specific fields to fetch from the recent_views_project
    **/
    select?: recent_views_projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: recent_views_projectInclude | null
    /**
     * Filter, which recent_views_projects to fetch.
    **/
    where?: recent_views_projectWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of recent_views_projects to fetch.
    **/
    orderBy?: Enumerable<recent_views_projectOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recent_views_projects.
    **/
    cursor?: recent_views_projectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recent_views_projects from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recent_views_projects.
    **/
    skip?: number
    distinct?: Enumerable<Recent_views_projectScalarFieldEnum>
  }


  /**
   * recent_views_project create
   */
  export type recent_views_projectCreateArgs = {
    /**
     * Select specific fields to fetch from the recent_views_project
    **/
    select?: recent_views_projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: recent_views_projectInclude | null
    /**
     * The data needed to create a recent_views_project.
    **/
    data: XOR<recent_views_projectUncheckedCreateInput, recent_views_projectCreateInput>
  }


  /**
   * recent_views_project update
   */
  export type recent_views_projectUpdateArgs = {
    /**
     * Select specific fields to fetch from the recent_views_project
    **/
    select?: recent_views_projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: recent_views_projectInclude | null
    /**
     * The data needed to update a recent_views_project.
    **/
    data: XOR<recent_views_projectUncheckedUpdateInput, recent_views_projectUpdateInput>
    /**
     * Choose, which recent_views_project to update.
    **/
    where: recent_views_projectWhereUniqueInput
  }


  /**
   * recent_views_project updateMany
   */
  export type recent_views_projectUpdateManyArgs = {
    data: XOR<recent_views_projectUncheckedUpdateManyInput, recent_views_projectUpdateManyMutationInput>
    where?: recent_views_projectWhereInput
  }


  /**
   * recent_views_project upsert
   */
  export type recent_views_projectUpsertArgs = {
    /**
     * Select specific fields to fetch from the recent_views_project
    **/
    select?: recent_views_projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: recent_views_projectInclude | null
    /**
     * The filter to search for the recent_views_project to update in case it exists.
    **/
    where: recent_views_projectWhereUniqueInput
    /**
     * In case the recent_views_project found by the `where` argument doesn't exist, create a new recent_views_project with this data.
    **/
    create: XOR<recent_views_projectUncheckedCreateInput, recent_views_projectCreateInput>
    /**
     * In case the recent_views_project was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<recent_views_projectUncheckedUpdateInput, recent_views_projectUpdateInput>
  }


  /**
   * recent_views_project delete
   */
  export type recent_views_projectDeleteArgs = {
    /**
     * Select specific fields to fetch from the recent_views_project
    **/
    select?: recent_views_projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: recent_views_projectInclude | null
    /**
     * Filter which recent_views_project to delete.
    **/
    where: recent_views_projectWhereUniqueInput
  }


  /**
   * recent_views_project deleteMany
   */
  export type recent_views_projectDeleteManyArgs = {
    where?: recent_views_projectWhereInput
  }


  /**
   * recent_views_project without action
   */
  export type recent_views_projectArgs = {
    /**
     * Select specific fields to fetch from the recent_views_project
    **/
    select?: recent_views_projectSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: recent_views_projectInclude | null
  }



  /**
   * Model required_documents
   */


  export type AggregateRequired_documents = {
    count: Required_documentsCountAggregateOutputType | null
    avg: Required_documentsAvgAggregateOutputType | null
    sum: Required_documentsSumAggregateOutputType | null
    min: Required_documentsMinAggregateOutputType | null
    max: Required_documentsMaxAggregateOutputType | null
  }

  export type Required_documentsAvgAggregateOutputType = {
    id: number
    project_id: number
    document_id: number
  }

  export type Required_documentsSumAggregateOutputType = {
    id: number
    project_id: number
    document_id: number
  }

  export type Required_documentsMinAggregateOutputType = {
    id: number
    project_id: number
    document_id: number
  }

  export type Required_documentsMaxAggregateOutputType = {
    id: number
    project_id: number
    document_id: number
  }

  export type Required_documentsCountAggregateOutputType = {
    id: number
    project_id: number
    document_id: number
    _all: number
  }


  export type Required_documentsAvgAggregateInputType = {
    id?: true
    project_id?: true
    document_id?: true
  }

  export type Required_documentsSumAggregateInputType = {
    id?: true
    project_id?: true
    document_id?: true
  }

  export type Required_documentsMinAggregateInputType = {
    id?: true
    project_id?: true
    document_id?: true
  }

  export type Required_documentsMaxAggregateInputType = {
    id?: true
    project_id?: true
    document_id?: true
  }

  export type Required_documentsCountAggregateInputType = {
    id?: true
    project_id?: true
    document_id?: true
    _all?: true
  }

  export type Required_documentsAggregateArgs = {
    /**
     * Filter which required_documents to aggregate.
    **/
    where?: required_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of required_documents to fetch.
    **/
    orderBy?: Enumerable<required_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: required_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` required_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` required_documents.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned required_documents
    **/
    count?: true | Required_documentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Required_documentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Required_documentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Required_documentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Required_documentsMaxAggregateInputType
  }

  export type GetRequired_documentsAggregateType<T extends Required_documentsAggregateArgs> = {
    [P in keyof T & keyof AggregateRequired_documents]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequired_documents[P]>
      : GetScalarType<T[P], AggregateRequired_documents[P]>
  }



  export type required_documentsSelect = {
    id?: boolean
    project_id?: boolean
    document_id?: boolean
    document_types?: boolean | document_typesArgs
    projects?: boolean | projectsArgs
  }

  export type required_documentsInclude = {
    document_types?: boolean | document_typesArgs
    projects?: boolean | projectsArgs
  }

  export type required_documentsGetPayload<
    S extends boolean | null | undefined | required_documentsArgs,
    U = keyof S
      > = S extends true
        ? required_documents
    : S extends undefined
    ? never
    : S extends required_documentsArgs | required_documentsFindManyArgs
    ?'include' extends U
    ? required_documents  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'document_types'
        ? document_typesGetPayload<S['include'][P]> :
        P extends 'projects'
        ? projectsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof required_documents ?required_documents [P]
  : 
          P extends 'document_types'
        ? document_typesGetPayload<S['select'][P]> :
        P extends 'projects'
        ? projectsGetPayload<S['select'][P]> : never
  } 
    : required_documents
  : required_documents


  type required_documentsCountArgs = Merge<
    Omit<required_documentsFindManyArgs, 'select' | 'include'> & {
      select?: Required_documentsCountAggregateInputType | true
    }
  >

  export interface required_documentsDelegate {
    /**
     * Find zero or one Required_documents that matches the filter.
     * @param {required_documentsFindUniqueArgs} args - Arguments to find a Required_documents
     * @example
     * // Get one Required_documents
     * const required_documents = await prisma.required_documents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends required_documentsFindUniqueArgs>(
      args: SelectSubset<T, required_documentsFindUniqueArgs>
    ): CheckSelect<T, Prisma__required_documentsClient<required_documents | null>, Prisma__required_documentsClient<required_documentsGetPayload<T> | null>>

    /**
     * Find the first Required_documents that matches the filter.
     * @param {required_documentsFindFirstArgs} args - Arguments to find a Required_documents
     * @example
     * // Get one Required_documents
     * const required_documents = await prisma.required_documents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends required_documentsFindFirstArgs>(
      args?: SelectSubset<T, required_documentsFindFirstArgs>
    ): CheckSelect<T, Prisma__required_documentsClient<required_documents | null>, Prisma__required_documentsClient<required_documentsGetPayload<T> | null>>

    /**
     * Find zero or more Required_documents that matches the filter.
     * @param {required_documentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Required_documents
     * const required_documents = await prisma.required_documents.findMany()
     * 
     * // Get first 10 Required_documents
     * const required_documents = await prisma.required_documents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const required_documentsWithIdOnly = await prisma.required_documents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends required_documentsFindManyArgs>(
      args?: SelectSubset<T, required_documentsFindManyArgs>
    ): CheckSelect<T, Promise<Array<required_documents>>, Promise<Array<required_documentsGetPayload<T>>>>

    /**
     * Create a Required_documents.
     * @param {required_documentsCreateArgs} args - Arguments to create a Required_documents.
     * @example
     * // Create one Required_documents
     * const Required_documents = await prisma.required_documents.create({
     *   data: {
     *     // ... data to create a Required_documents
     *   }
     * })
     * 
    **/
    create<T extends required_documentsCreateArgs>(
      args: SelectSubset<T, required_documentsCreateArgs>
    ): CheckSelect<T, Prisma__required_documentsClient<required_documents>, Prisma__required_documentsClient<required_documentsGetPayload<T>>>

    /**
     * Delete a Required_documents.
     * @param {required_documentsDeleteArgs} args - Arguments to delete one Required_documents.
     * @example
     * // Delete one Required_documents
     * const Required_documents = await prisma.required_documents.delete({
     *   where: {
     *     // ... filter to delete one Required_documents
     *   }
     * })
     * 
    **/
    delete<T extends required_documentsDeleteArgs>(
      args: SelectSubset<T, required_documentsDeleteArgs>
    ): CheckSelect<T, Prisma__required_documentsClient<required_documents>, Prisma__required_documentsClient<required_documentsGetPayload<T>>>

    /**
     * Update one Required_documents.
     * @param {required_documentsUpdateArgs} args - Arguments to update one Required_documents.
     * @example
     * // Update one Required_documents
     * const required_documents = await prisma.required_documents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends required_documentsUpdateArgs>(
      args: SelectSubset<T, required_documentsUpdateArgs>
    ): CheckSelect<T, Prisma__required_documentsClient<required_documents>, Prisma__required_documentsClient<required_documentsGetPayload<T>>>

    /**
     * Delete zero or more Required_documents.
     * @param {required_documentsDeleteManyArgs} args - Arguments to filter Required_documents to delete.
     * @example
     * // Delete a few Required_documents
     * const { count } = await prisma.required_documents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends required_documentsDeleteManyArgs>(
      args?: SelectSubset<T, required_documentsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Required_documents.
     * @param {required_documentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Required_documents
     * const required_documents = await prisma.required_documents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends required_documentsUpdateManyArgs>(
      args: SelectSubset<T, required_documentsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Required_documents.
     * @param {required_documentsUpsertArgs} args - Arguments to update or create a Required_documents.
     * @example
     * // Update or create a Required_documents
     * const required_documents = await prisma.required_documents.upsert({
     *   create: {
     *     // ... data to create a Required_documents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Required_documents we want to update
     *   }
     * })
    **/
    upsert<T extends required_documentsUpsertArgs>(
      args: SelectSubset<T, required_documentsUpsertArgs>
    ): CheckSelect<T, Prisma__required_documentsClient<required_documents>, Prisma__required_documentsClient<required_documentsGetPayload<T>>>

    /**
     * Count the number of Required_documents.
     * @param {required_documentsCountArgs} args - Arguments to filter Required_documents to count.
     * @example
     * // Count the number of Required_documents
     * const count = await prisma.required_documents.count({
     *   where: {
     *     // ... the filter for the Required_documents we want to count
     *   }
     * })
    **/
    count<T extends required_documentsCountArgs>(
      args?: Subset<T, required_documentsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Required_documentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Required_documents.
     * @param {Required_documentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Required_documentsAggregateArgs>(args: Subset<T, Required_documentsAggregateArgs>): Promise<GetRequired_documentsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for required_documents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__required_documentsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    document_types<T extends document_typesArgs = {}>(args?: Subset<T, document_typesArgs>): CheckSelect<T, Prisma__document_typesClient<document_types | null>, Prisma__document_typesClient<document_typesGetPayload<T> | null>>;

    projects<T extends projectsArgs = {}>(args?: Subset<T, projectsArgs>): CheckSelect<T, Prisma__projectsClient<projects | null>, Prisma__projectsClient<projectsGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * required_documents findUnique
   */
  export type required_documentsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the required_documents
    **/
    select?: required_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: required_documentsInclude | null
    /**
     * Throw an Error if a required_documents can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which required_documents to fetch.
    **/
    where: required_documentsWhereUniqueInput
  }


  /**
   * required_documents findFirst
   */
  export type required_documentsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the required_documents
    **/
    select?: required_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: required_documentsInclude | null
    /**
     * Throw an Error if a required_documents can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which required_documents to fetch.
    **/
    where?: required_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of required_documents to fetch.
    **/
    orderBy?: Enumerable<required_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for required_documents.
    **/
    cursor?: required_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` required_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` required_documents.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of required_documents.
    **/
    distinct?: Enumerable<Required_documentsScalarFieldEnum>
  }


  /**
   * required_documents findMany
   */
  export type required_documentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the required_documents
    **/
    select?: required_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: required_documentsInclude | null
    /**
     * Filter, which required_documents to fetch.
    **/
    where?: required_documentsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of required_documents to fetch.
    **/
    orderBy?: Enumerable<required_documentsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing required_documents.
    **/
    cursor?: required_documentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` required_documents from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` required_documents.
    **/
    skip?: number
    distinct?: Enumerable<Required_documentsScalarFieldEnum>
  }


  /**
   * required_documents create
   */
  export type required_documentsCreateArgs = {
    /**
     * Select specific fields to fetch from the required_documents
    **/
    select?: required_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: required_documentsInclude | null
    /**
     * The data needed to create a required_documents.
    **/
    data: XOR<required_documentsUncheckedCreateInput, required_documentsCreateInput>
  }


  /**
   * required_documents update
   */
  export type required_documentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the required_documents
    **/
    select?: required_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: required_documentsInclude | null
    /**
     * The data needed to update a required_documents.
    **/
    data: XOR<required_documentsUncheckedUpdateInput, required_documentsUpdateInput>
    /**
     * Choose, which required_documents to update.
    **/
    where: required_documentsWhereUniqueInput
  }


  /**
   * required_documents updateMany
   */
  export type required_documentsUpdateManyArgs = {
    data: XOR<required_documentsUncheckedUpdateManyInput, required_documentsUpdateManyMutationInput>
    where?: required_documentsWhereInput
  }


  /**
   * required_documents upsert
   */
  export type required_documentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the required_documents
    **/
    select?: required_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: required_documentsInclude | null
    /**
     * The filter to search for the required_documents to update in case it exists.
    **/
    where: required_documentsWhereUniqueInput
    /**
     * In case the required_documents found by the `where` argument doesn't exist, create a new required_documents with this data.
    **/
    create: XOR<required_documentsUncheckedCreateInput, required_documentsCreateInput>
    /**
     * In case the required_documents was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<required_documentsUncheckedUpdateInput, required_documentsUpdateInput>
  }


  /**
   * required_documents delete
   */
  export type required_documentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the required_documents
    **/
    select?: required_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: required_documentsInclude | null
    /**
     * Filter which required_documents to delete.
    **/
    where: required_documentsWhereUniqueInput
  }


  /**
   * required_documents deleteMany
   */
  export type required_documentsDeleteManyArgs = {
    where?: required_documentsWhereInput
  }


  /**
   * required_documents without action
   */
  export type required_documentsArgs = {
    /**
     * Select specific fields to fetch from the required_documents
    **/
    select?: required_documentsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: required_documentsInclude | null
  }



  /**
   * Model sectors
   */


  export type AggregateSectors = {
    count: SectorsCountAggregateOutputType | null
    avg: SectorsAvgAggregateOutputType | null
    sum: SectorsSumAggregateOutputType | null
    min: SectorsMinAggregateOutputType | null
    max: SectorsMaxAggregateOutputType | null
  }

  export type SectorsAvgAggregateOutputType = {
    id: number
  }

  export type SectorsSumAggregateOutputType = {
    id: number
  }

  export type SectorsMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type SectorsMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type SectorsCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type SectorsAvgAggregateInputType = {
    id?: true
  }

  export type SectorsSumAggregateInputType = {
    id?: true
  }

  export type SectorsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SectorsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SectorsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SectorsAggregateArgs = {
    /**
     * Filter which sectors to aggregate.
    **/
    where?: sectorsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of sectors to fetch.
    **/
    orderBy?: Enumerable<sectorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sectors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sectors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sectors
    **/
    count?: true | SectorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SectorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SectorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SectorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SectorsMaxAggregateInputType
  }

  export type GetSectorsAggregateType<T extends SectorsAggregateArgs> = {
    [P in keyof T & keyof AggregateSectors]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectors[P]>
      : GetScalarType<T[P], AggregateSectors[P]>
  }



  export type sectorsSelect = {
    id?: boolean
    name?: boolean
    startups?: boolean | startupsFindManyArgs
  }

  export type sectorsInclude = {
    startups?: boolean | startupsFindManyArgs
  }

  export type sectorsGetPayload<
    S extends boolean | null | undefined | sectorsArgs,
    U = keyof S
      > = S extends true
        ? sectors
    : S extends undefined
    ? never
    : S extends sectorsArgs | sectorsFindManyArgs
    ?'include' extends U
    ? sectors  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'startups'
        ? Array < startupsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof sectors ?sectors [P]
  : 
          P extends 'startups'
        ? Array < startupsGetPayload<S['select'][P]>>  : never
  } 
    : sectors
  : sectors


  type sectorsCountArgs = Merge<
    Omit<sectorsFindManyArgs, 'select' | 'include'> & {
      select?: SectorsCountAggregateInputType | true
    }
  >

  export interface sectorsDelegate {
    /**
     * Find zero or one Sectors that matches the filter.
     * @param {sectorsFindUniqueArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sectorsFindUniqueArgs>(
      args: SelectSubset<T, sectorsFindUniqueArgs>
    ): CheckSelect<T, Prisma__sectorsClient<sectors | null>, Prisma__sectorsClient<sectorsGetPayload<T> | null>>

    /**
     * Find the first Sectors that matches the filter.
     * @param {sectorsFindFirstArgs} args - Arguments to find a Sectors
     * @example
     * // Get one Sectors
     * const sectors = await prisma.sectors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sectorsFindFirstArgs>(
      args?: SelectSubset<T, sectorsFindFirstArgs>
    ): CheckSelect<T, Prisma__sectorsClient<sectors | null>, Prisma__sectorsClient<sectorsGetPayload<T> | null>>

    /**
     * Find zero or more Sectors that matches the filter.
     * @param {sectorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sectors
     * const sectors = await prisma.sectors.findMany()
     * 
     * // Get first 10 Sectors
     * const sectors = await prisma.sectors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectorsWithIdOnly = await prisma.sectors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sectorsFindManyArgs>(
      args?: SelectSubset<T, sectorsFindManyArgs>
    ): CheckSelect<T, Promise<Array<sectors>>, Promise<Array<sectorsGetPayload<T>>>>

    /**
     * Create a Sectors.
     * @param {sectorsCreateArgs} args - Arguments to create a Sectors.
     * @example
     * // Create one Sectors
     * const Sectors = await prisma.sectors.create({
     *   data: {
     *     // ... data to create a Sectors
     *   }
     * })
     * 
    **/
    create<T extends sectorsCreateArgs>(
      args: SelectSubset<T, sectorsCreateArgs>
    ): CheckSelect<T, Prisma__sectorsClient<sectors>, Prisma__sectorsClient<sectorsGetPayload<T>>>

    /**
     * Delete a Sectors.
     * @param {sectorsDeleteArgs} args - Arguments to delete one Sectors.
     * @example
     * // Delete one Sectors
     * const Sectors = await prisma.sectors.delete({
     *   where: {
     *     // ... filter to delete one Sectors
     *   }
     * })
     * 
    **/
    delete<T extends sectorsDeleteArgs>(
      args: SelectSubset<T, sectorsDeleteArgs>
    ): CheckSelect<T, Prisma__sectorsClient<sectors>, Prisma__sectorsClient<sectorsGetPayload<T>>>

    /**
     * Update one Sectors.
     * @param {sectorsUpdateArgs} args - Arguments to update one Sectors.
     * @example
     * // Update one Sectors
     * const sectors = await prisma.sectors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sectorsUpdateArgs>(
      args: SelectSubset<T, sectorsUpdateArgs>
    ): CheckSelect<T, Prisma__sectorsClient<sectors>, Prisma__sectorsClient<sectorsGetPayload<T>>>

    /**
     * Delete zero or more Sectors.
     * @param {sectorsDeleteManyArgs} args - Arguments to filter Sectors to delete.
     * @example
     * // Delete a few Sectors
     * const { count } = await prisma.sectors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sectorsDeleteManyArgs>(
      args?: SelectSubset<T, sectorsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Sectors.
     * @param {sectorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sectors
     * const sectors = await prisma.sectors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sectorsUpdateManyArgs>(
      args: SelectSubset<T, sectorsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Sectors.
     * @param {sectorsUpsertArgs} args - Arguments to update or create a Sectors.
     * @example
     * // Update or create a Sectors
     * const sectors = await prisma.sectors.upsert({
     *   create: {
     *     // ... data to create a Sectors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sectors we want to update
     *   }
     * })
    **/
    upsert<T extends sectorsUpsertArgs>(
      args: SelectSubset<T, sectorsUpsertArgs>
    ): CheckSelect<T, Prisma__sectorsClient<sectors>, Prisma__sectorsClient<sectorsGetPayload<T>>>

    /**
     * Count the number of Sectors.
     * @param {sectorsCountArgs} args - Arguments to filter Sectors to count.
     * @example
     * // Count the number of Sectors
     * const count = await prisma.sectors.count({
     *   where: {
     *     // ... the filter for the Sectors we want to count
     *   }
     * })
    **/
    count<T extends sectorsCountArgs>(
      args?: Subset<T, sectorsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sectors.
     * @param {SectorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectorsAggregateArgs>(args: Subset<T, SectorsAggregateArgs>): Promise<GetSectorsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for sectors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sectorsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    startups<T extends startupsFindManyArgs = {}>(args?: Subset<T, startupsFindManyArgs>): CheckSelect<T, Promise<Array<startups>>, Promise<Array<startupsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * sectors findUnique
   */
  export type sectorsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the sectors
    **/
    select?: sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: sectorsInclude | null
    /**
     * Throw an Error if a sectors can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which sectors to fetch.
    **/
    where: sectorsWhereUniqueInput
  }


  /**
   * sectors findFirst
   */
  export type sectorsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the sectors
    **/
    select?: sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: sectorsInclude | null
    /**
     * Throw an Error if a sectors can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which sectors to fetch.
    **/
    where?: sectorsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of sectors to fetch.
    **/
    orderBy?: Enumerable<sectorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sectors.
    **/
    cursor?: sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sectors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sectors.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of sectors.
    **/
    distinct?: Enumerable<SectorsScalarFieldEnum>
  }


  /**
   * sectors findMany
   */
  export type sectorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the sectors
    **/
    select?: sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: sectorsInclude | null
    /**
     * Filter, which sectors to fetch.
    **/
    where?: sectorsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of sectors to fetch.
    **/
    orderBy?: Enumerable<sectorsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sectors.
    **/
    cursor?: sectorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sectors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sectors.
    **/
    skip?: number
    distinct?: Enumerable<SectorsScalarFieldEnum>
  }


  /**
   * sectors create
   */
  export type sectorsCreateArgs = {
    /**
     * Select specific fields to fetch from the sectors
    **/
    select?: sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: sectorsInclude | null
    /**
     * The data needed to create a sectors.
    **/
    data: XOR<sectorsUncheckedCreateInput, sectorsCreateInput>
  }


  /**
   * sectors update
   */
  export type sectorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the sectors
    **/
    select?: sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: sectorsInclude | null
    /**
     * The data needed to update a sectors.
    **/
    data: XOR<sectorsUncheckedUpdateInput, sectorsUpdateInput>
    /**
     * Choose, which sectors to update.
    **/
    where: sectorsWhereUniqueInput
  }


  /**
   * sectors updateMany
   */
  export type sectorsUpdateManyArgs = {
    data: XOR<sectorsUncheckedUpdateManyInput, sectorsUpdateManyMutationInput>
    where?: sectorsWhereInput
  }


  /**
   * sectors upsert
   */
  export type sectorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the sectors
    **/
    select?: sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: sectorsInclude | null
    /**
     * The filter to search for the sectors to update in case it exists.
    **/
    where: sectorsWhereUniqueInput
    /**
     * In case the sectors found by the `where` argument doesn't exist, create a new sectors with this data.
    **/
    create: XOR<sectorsUncheckedCreateInput, sectorsCreateInput>
    /**
     * In case the sectors was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<sectorsUncheckedUpdateInput, sectorsUpdateInput>
  }


  /**
   * sectors delete
   */
  export type sectorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the sectors
    **/
    select?: sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: sectorsInclude | null
    /**
     * Filter which sectors to delete.
    **/
    where: sectorsWhereUniqueInput
  }


  /**
   * sectors deleteMany
   */
  export type sectorsDeleteManyArgs = {
    where?: sectorsWhereInput
  }


  /**
   * sectors without action
   */
  export type sectorsArgs = {
    /**
     * Select specific fields to fetch from the sectors
    **/
    select?: sectorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: sectorsInclude | null
  }



  /**
   * Model service_types
   */


  export type AggregateService_types = {
    count: Service_typesCountAggregateOutputType | null
    avg: Service_typesAvgAggregateOutputType | null
    sum: Service_typesSumAggregateOutputType | null
    min: Service_typesMinAggregateOutputType | null
    max: Service_typesMaxAggregateOutputType | null
  }

  export type Service_typesAvgAggregateOutputType = {
    id: number
  }

  export type Service_typesSumAggregateOutputType = {
    id: number
  }

  export type Service_typesMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Service_typesMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Service_typesCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type Service_typesAvgAggregateInputType = {
    id?: true
  }

  export type Service_typesSumAggregateInputType = {
    id?: true
  }

  export type Service_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Service_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Service_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Service_typesAggregateArgs = {
    /**
     * Filter which service_types to aggregate.
    **/
    where?: service_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of service_types to fetch.
    **/
    orderBy?: Enumerable<service_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: service_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_types.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_types
    **/
    count?: true | Service_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Service_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Service_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Service_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Service_typesMaxAggregateInputType
  }

  export type GetService_typesAggregateType<T extends Service_typesAggregateArgs> = {
    [P in keyof T & keyof AggregateService_types]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_types[P]>
      : GetScalarType<T[P], AggregateService_types[P]>
  }



  export type service_typesSelect = {
    id?: boolean
    name?: boolean
    startups?: boolean | startupsFindManyArgs
  }

  export type service_typesInclude = {
    startups?: boolean | startupsFindManyArgs
  }

  export type service_typesGetPayload<
    S extends boolean | null | undefined | service_typesArgs,
    U = keyof S
      > = S extends true
        ? service_types
    : S extends undefined
    ? never
    : S extends service_typesArgs | service_typesFindManyArgs
    ?'include' extends U
    ? service_types  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'startups'
        ? Array < startupsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof service_types ?service_types [P]
  : 
          P extends 'startups'
        ? Array < startupsGetPayload<S['select'][P]>>  : never
  } 
    : service_types
  : service_types


  type service_typesCountArgs = Merge<
    Omit<service_typesFindManyArgs, 'select' | 'include'> & {
      select?: Service_typesCountAggregateInputType | true
    }
  >

  export interface service_typesDelegate {
    /**
     * Find zero or one Service_types that matches the filter.
     * @param {service_typesFindUniqueArgs} args - Arguments to find a Service_types
     * @example
     * // Get one Service_types
     * const service_types = await prisma.service_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends service_typesFindUniqueArgs>(
      args: SelectSubset<T, service_typesFindUniqueArgs>
    ): CheckSelect<T, Prisma__service_typesClient<service_types | null>, Prisma__service_typesClient<service_typesGetPayload<T> | null>>

    /**
     * Find the first Service_types that matches the filter.
     * @param {service_typesFindFirstArgs} args - Arguments to find a Service_types
     * @example
     * // Get one Service_types
     * const service_types = await prisma.service_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends service_typesFindFirstArgs>(
      args?: SelectSubset<T, service_typesFindFirstArgs>
    ): CheckSelect<T, Prisma__service_typesClient<service_types | null>, Prisma__service_typesClient<service_typesGetPayload<T> | null>>

    /**
     * Find zero or more Service_types that matches the filter.
     * @param {service_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_types
     * const service_types = await prisma.service_types.findMany()
     * 
     * // Get first 10 Service_types
     * const service_types = await prisma.service_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_typesWithIdOnly = await prisma.service_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends service_typesFindManyArgs>(
      args?: SelectSubset<T, service_typesFindManyArgs>
    ): CheckSelect<T, Promise<Array<service_types>>, Promise<Array<service_typesGetPayload<T>>>>

    /**
     * Create a Service_types.
     * @param {service_typesCreateArgs} args - Arguments to create a Service_types.
     * @example
     * // Create one Service_types
     * const Service_types = await prisma.service_types.create({
     *   data: {
     *     // ... data to create a Service_types
     *   }
     * })
     * 
    **/
    create<T extends service_typesCreateArgs>(
      args: SelectSubset<T, service_typesCreateArgs>
    ): CheckSelect<T, Prisma__service_typesClient<service_types>, Prisma__service_typesClient<service_typesGetPayload<T>>>

    /**
     * Delete a Service_types.
     * @param {service_typesDeleteArgs} args - Arguments to delete one Service_types.
     * @example
     * // Delete one Service_types
     * const Service_types = await prisma.service_types.delete({
     *   where: {
     *     // ... filter to delete one Service_types
     *   }
     * })
     * 
    **/
    delete<T extends service_typesDeleteArgs>(
      args: SelectSubset<T, service_typesDeleteArgs>
    ): CheckSelect<T, Prisma__service_typesClient<service_types>, Prisma__service_typesClient<service_typesGetPayload<T>>>

    /**
     * Update one Service_types.
     * @param {service_typesUpdateArgs} args - Arguments to update one Service_types.
     * @example
     * // Update one Service_types
     * const service_types = await prisma.service_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends service_typesUpdateArgs>(
      args: SelectSubset<T, service_typesUpdateArgs>
    ): CheckSelect<T, Prisma__service_typesClient<service_types>, Prisma__service_typesClient<service_typesGetPayload<T>>>

    /**
     * Delete zero or more Service_types.
     * @param {service_typesDeleteManyArgs} args - Arguments to filter Service_types to delete.
     * @example
     * // Delete a few Service_types
     * const { count } = await prisma.service_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends service_typesDeleteManyArgs>(
      args?: SelectSubset<T, service_typesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Service_types.
     * @param {service_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_types
     * const service_types = await prisma.service_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends service_typesUpdateManyArgs>(
      args: SelectSubset<T, service_typesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Service_types.
     * @param {service_typesUpsertArgs} args - Arguments to update or create a Service_types.
     * @example
     * // Update or create a Service_types
     * const service_types = await prisma.service_types.upsert({
     *   create: {
     *     // ... data to create a Service_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_types we want to update
     *   }
     * })
    **/
    upsert<T extends service_typesUpsertArgs>(
      args: SelectSubset<T, service_typesUpsertArgs>
    ): CheckSelect<T, Prisma__service_typesClient<service_types>, Prisma__service_typesClient<service_typesGetPayload<T>>>

    /**
     * Count the number of Service_types.
     * @param {service_typesCountArgs} args - Arguments to filter Service_types to count.
     * @example
     * // Count the number of Service_types
     * const count = await prisma.service_types.count({
     *   where: {
     *     // ... the filter for the Service_types we want to count
     *   }
     * })
    **/
    count<T extends service_typesCountArgs>(
      args?: Subset<T, service_typesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_types.
     * @param {Service_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_typesAggregateArgs>(args: Subset<T, Service_typesAggregateArgs>): Promise<GetService_typesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for service_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__service_typesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    startups<T extends startupsFindManyArgs = {}>(args?: Subset<T, startupsFindManyArgs>): CheckSelect<T, Promise<Array<startups>>, Promise<Array<startupsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * service_types findUnique
   */
  export type service_typesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the service_types
    **/
    select?: service_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: service_typesInclude | null
    /**
     * Throw an Error if a service_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which service_types to fetch.
    **/
    where: service_typesWhereUniqueInput
  }


  /**
   * service_types findFirst
   */
  export type service_typesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the service_types
    **/
    select?: service_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: service_typesInclude | null
    /**
     * Throw an Error if a service_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which service_types to fetch.
    **/
    where?: service_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of service_types to fetch.
    **/
    orderBy?: Enumerable<service_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_types.
    **/
    cursor?: service_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_types.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of service_types.
    **/
    distinct?: Enumerable<Service_typesScalarFieldEnum>
  }


  /**
   * service_types findMany
   */
  export type service_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the service_types
    **/
    select?: service_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: service_typesInclude | null
    /**
     * Filter, which service_types to fetch.
    **/
    where?: service_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of service_types to fetch.
    **/
    orderBy?: Enumerable<service_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_types.
    **/
    cursor?: service_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_types.
    **/
    skip?: number
    distinct?: Enumerable<Service_typesScalarFieldEnum>
  }


  /**
   * service_types create
   */
  export type service_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the service_types
    **/
    select?: service_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: service_typesInclude | null
    /**
     * The data needed to create a service_types.
    **/
    data: XOR<service_typesUncheckedCreateInput, service_typesCreateInput>
  }


  /**
   * service_types update
   */
  export type service_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the service_types
    **/
    select?: service_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: service_typesInclude | null
    /**
     * The data needed to update a service_types.
    **/
    data: XOR<service_typesUncheckedUpdateInput, service_typesUpdateInput>
    /**
     * Choose, which service_types to update.
    **/
    where: service_typesWhereUniqueInput
  }


  /**
   * service_types updateMany
   */
  export type service_typesUpdateManyArgs = {
    data: XOR<service_typesUncheckedUpdateManyInput, service_typesUpdateManyMutationInput>
    where?: service_typesWhereInput
  }


  /**
   * service_types upsert
   */
  export type service_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the service_types
    **/
    select?: service_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: service_typesInclude | null
    /**
     * The filter to search for the service_types to update in case it exists.
    **/
    where: service_typesWhereUniqueInput
    /**
     * In case the service_types found by the `where` argument doesn't exist, create a new service_types with this data.
    **/
    create: XOR<service_typesUncheckedCreateInput, service_typesCreateInput>
    /**
     * In case the service_types was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<service_typesUncheckedUpdateInput, service_typesUpdateInput>
  }


  /**
   * service_types delete
   */
  export type service_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the service_types
    **/
    select?: service_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: service_typesInclude | null
    /**
     * Filter which service_types to delete.
    **/
    where: service_typesWhereUniqueInput
  }


  /**
   * service_types deleteMany
   */
  export type service_typesDeleteManyArgs = {
    where?: service_typesWhereInput
  }


  /**
   * service_types without action
   */
  export type service_typesArgs = {
    /**
     * Select specific fields to fetch from the service_types
    **/
    select?: service_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: service_typesInclude | null
  }



  /**
   * Model signup_methods
   */


  export type AggregateSignup_methods = {
    count: Signup_methodsCountAggregateOutputType | null
    avg: Signup_methodsAvgAggregateOutputType | null
    sum: Signup_methodsSumAggregateOutputType | null
    min: Signup_methodsMinAggregateOutputType | null
    max: Signup_methodsMaxAggregateOutputType | null
  }

  export type Signup_methodsAvgAggregateOutputType = {
    id: number
  }

  export type Signup_methodsSumAggregateOutputType = {
    id: number
  }

  export type Signup_methodsMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Signup_methodsMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type Signup_methodsCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type Signup_methodsAvgAggregateInputType = {
    id?: true
  }

  export type Signup_methodsSumAggregateInputType = {
    id?: true
  }

  export type Signup_methodsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Signup_methodsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Signup_methodsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Signup_methodsAggregateArgs = {
    /**
     * Filter which signup_methods to aggregate.
    **/
    where?: signup_methodsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of signup_methods to fetch.
    **/
    orderBy?: Enumerable<signup_methodsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: signup_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signup_methods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signup_methods.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned signup_methods
    **/
    count?: true | Signup_methodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Signup_methodsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Signup_methodsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Signup_methodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Signup_methodsMaxAggregateInputType
  }

  export type GetSignup_methodsAggregateType<T extends Signup_methodsAggregateArgs> = {
    [P in keyof T & keyof AggregateSignup_methods]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignup_methods[P]>
      : GetScalarType<T[P], AggregateSignup_methods[P]>
  }



  export type signup_methodsSelect = {
    id?: boolean
    name?: boolean
    users?: boolean | usersFindManyArgs
  }

  export type signup_methodsInclude = {
    users?: boolean | usersFindManyArgs
  }

  export type signup_methodsGetPayload<
    S extends boolean | null | undefined | signup_methodsArgs,
    U = keyof S
      > = S extends true
        ? signup_methods
    : S extends undefined
    ? never
    : S extends signup_methodsArgs | signup_methodsFindManyArgs
    ?'include' extends U
    ? signup_methods  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'users'
        ? Array < usersGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof signup_methods ?signup_methods [P]
  : 
          P extends 'users'
        ? Array < usersGetPayload<S['select'][P]>>  : never
  } 
    : signup_methods
  : signup_methods


  type signup_methodsCountArgs = Merge<
    Omit<signup_methodsFindManyArgs, 'select' | 'include'> & {
      select?: Signup_methodsCountAggregateInputType | true
    }
  >

  export interface signup_methodsDelegate {
    /**
     * Find zero or one Signup_methods that matches the filter.
     * @param {signup_methodsFindUniqueArgs} args - Arguments to find a Signup_methods
     * @example
     * // Get one Signup_methods
     * const signup_methods = await prisma.signup_methods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends signup_methodsFindUniqueArgs>(
      args: SelectSubset<T, signup_methodsFindUniqueArgs>
    ): CheckSelect<T, Prisma__signup_methodsClient<signup_methods | null>, Prisma__signup_methodsClient<signup_methodsGetPayload<T> | null>>

    /**
     * Find the first Signup_methods that matches the filter.
     * @param {signup_methodsFindFirstArgs} args - Arguments to find a Signup_methods
     * @example
     * // Get one Signup_methods
     * const signup_methods = await prisma.signup_methods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends signup_methodsFindFirstArgs>(
      args?: SelectSubset<T, signup_methodsFindFirstArgs>
    ): CheckSelect<T, Prisma__signup_methodsClient<signup_methods | null>, Prisma__signup_methodsClient<signup_methodsGetPayload<T> | null>>

    /**
     * Find zero or more Signup_methods that matches the filter.
     * @param {signup_methodsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signup_methods
     * const signup_methods = await prisma.signup_methods.findMany()
     * 
     * // Get first 10 Signup_methods
     * const signup_methods = await prisma.signup_methods.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signup_methodsWithIdOnly = await prisma.signup_methods.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends signup_methodsFindManyArgs>(
      args?: SelectSubset<T, signup_methodsFindManyArgs>
    ): CheckSelect<T, Promise<Array<signup_methods>>, Promise<Array<signup_methodsGetPayload<T>>>>

    /**
     * Create a Signup_methods.
     * @param {signup_methodsCreateArgs} args - Arguments to create a Signup_methods.
     * @example
     * // Create one Signup_methods
     * const Signup_methods = await prisma.signup_methods.create({
     *   data: {
     *     // ... data to create a Signup_methods
     *   }
     * })
     * 
    **/
    create<T extends signup_methodsCreateArgs>(
      args: SelectSubset<T, signup_methodsCreateArgs>
    ): CheckSelect<T, Prisma__signup_methodsClient<signup_methods>, Prisma__signup_methodsClient<signup_methodsGetPayload<T>>>

    /**
     * Delete a Signup_methods.
     * @param {signup_methodsDeleteArgs} args - Arguments to delete one Signup_methods.
     * @example
     * // Delete one Signup_methods
     * const Signup_methods = await prisma.signup_methods.delete({
     *   where: {
     *     // ... filter to delete one Signup_methods
     *   }
     * })
     * 
    **/
    delete<T extends signup_methodsDeleteArgs>(
      args: SelectSubset<T, signup_methodsDeleteArgs>
    ): CheckSelect<T, Prisma__signup_methodsClient<signup_methods>, Prisma__signup_methodsClient<signup_methodsGetPayload<T>>>

    /**
     * Update one Signup_methods.
     * @param {signup_methodsUpdateArgs} args - Arguments to update one Signup_methods.
     * @example
     * // Update one Signup_methods
     * const signup_methods = await prisma.signup_methods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends signup_methodsUpdateArgs>(
      args: SelectSubset<T, signup_methodsUpdateArgs>
    ): CheckSelect<T, Prisma__signup_methodsClient<signup_methods>, Prisma__signup_methodsClient<signup_methodsGetPayload<T>>>

    /**
     * Delete zero or more Signup_methods.
     * @param {signup_methodsDeleteManyArgs} args - Arguments to filter Signup_methods to delete.
     * @example
     * // Delete a few Signup_methods
     * const { count } = await prisma.signup_methods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends signup_methodsDeleteManyArgs>(
      args?: SelectSubset<T, signup_methodsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Signup_methods.
     * @param {signup_methodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signup_methods
     * const signup_methods = await prisma.signup_methods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends signup_methodsUpdateManyArgs>(
      args: SelectSubset<T, signup_methodsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Signup_methods.
     * @param {signup_methodsUpsertArgs} args - Arguments to update or create a Signup_methods.
     * @example
     * // Update or create a Signup_methods
     * const signup_methods = await prisma.signup_methods.upsert({
     *   create: {
     *     // ... data to create a Signup_methods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signup_methods we want to update
     *   }
     * })
    **/
    upsert<T extends signup_methodsUpsertArgs>(
      args: SelectSubset<T, signup_methodsUpsertArgs>
    ): CheckSelect<T, Prisma__signup_methodsClient<signup_methods>, Prisma__signup_methodsClient<signup_methodsGetPayload<T>>>

    /**
     * Count the number of Signup_methods.
     * @param {signup_methodsCountArgs} args - Arguments to filter Signup_methods to count.
     * @example
     * // Count the number of Signup_methods
     * const count = await prisma.signup_methods.count({
     *   where: {
     *     // ... the filter for the Signup_methods we want to count
     *   }
     * })
    **/
    count<T extends signup_methodsCountArgs>(
      args?: Subset<T, signup_methodsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Signup_methodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signup_methods.
     * @param {Signup_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Signup_methodsAggregateArgs>(args: Subset<T, Signup_methodsAggregateArgs>): Promise<GetSignup_methodsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for signup_methods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__signup_methodsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersFindManyArgs = {}>(args?: Subset<T, usersFindManyArgs>): CheckSelect<T, Promise<Array<users>>, Promise<Array<usersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * signup_methods findUnique
   */
  export type signup_methodsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the signup_methods
    **/
    select?: signup_methodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: signup_methodsInclude | null
    /**
     * Throw an Error if a signup_methods can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which signup_methods to fetch.
    **/
    where: signup_methodsWhereUniqueInput
  }


  /**
   * signup_methods findFirst
   */
  export type signup_methodsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the signup_methods
    **/
    select?: signup_methodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: signup_methodsInclude | null
    /**
     * Throw an Error if a signup_methods can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which signup_methods to fetch.
    **/
    where?: signup_methodsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of signup_methods to fetch.
    **/
    orderBy?: Enumerable<signup_methodsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for signup_methods.
    **/
    cursor?: signup_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signup_methods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signup_methods.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of signup_methods.
    **/
    distinct?: Enumerable<Signup_methodsScalarFieldEnum>
  }


  /**
   * signup_methods findMany
   */
  export type signup_methodsFindManyArgs = {
    /**
     * Select specific fields to fetch from the signup_methods
    **/
    select?: signup_methodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: signup_methodsInclude | null
    /**
     * Filter, which signup_methods to fetch.
    **/
    where?: signup_methodsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of signup_methods to fetch.
    **/
    orderBy?: Enumerable<signup_methodsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing signup_methods.
    **/
    cursor?: signup_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signup_methods from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signup_methods.
    **/
    skip?: number
    distinct?: Enumerable<Signup_methodsScalarFieldEnum>
  }


  /**
   * signup_methods create
   */
  export type signup_methodsCreateArgs = {
    /**
     * Select specific fields to fetch from the signup_methods
    **/
    select?: signup_methodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: signup_methodsInclude | null
    /**
     * The data needed to create a signup_methods.
    **/
    data: XOR<signup_methodsUncheckedCreateInput, signup_methodsCreateInput>
  }


  /**
   * signup_methods update
   */
  export type signup_methodsUpdateArgs = {
    /**
     * Select specific fields to fetch from the signup_methods
    **/
    select?: signup_methodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: signup_methodsInclude | null
    /**
     * The data needed to update a signup_methods.
    **/
    data: XOR<signup_methodsUncheckedUpdateInput, signup_methodsUpdateInput>
    /**
     * Choose, which signup_methods to update.
    **/
    where: signup_methodsWhereUniqueInput
  }


  /**
   * signup_methods updateMany
   */
  export type signup_methodsUpdateManyArgs = {
    data: XOR<signup_methodsUncheckedUpdateManyInput, signup_methodsUpdateManyMutationInput>
    where?: signup_methodsWhereInput
  }


  /**
   * signup_methods upsert
   */
  export type signup_methodsUpsertArgs = {
    /**
     * Select specific fields to fetch from the signup_methods
    **/
    select?: signup_methodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: signup_methodsInclude | null
    /**
     * The filter to search for the signup_methods to update in case it exists.
    **/
    where: signup_methodsWhereUniqueInput
    /**
     * In case the signup_methods found by the `where` argument doesn't exist, create a new signup_methods with this data.
    **/
    create: XOR<signup_methodsUncheckedCreateInput, signup_methodsCreateInput>
    /**
     * In case the signup_methods was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<signup_methodsUncheckedUpdateInput, signup_methodsUpdateInput>
  }


  /**
   * signup_methods delete
   */
  export type signup_methodsDeleteArgs = {
    /**
     * Select specific fields to fetch from the signup_methods
    **/
    select?: signup_methodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: signup_methodsInclude | null
    /**
     * Filter which signup_methods to delete.
    **/
    where: signup_methodsWhereUniqueInput
  }


  /**
   * signup_methods deleteMany
   */
  export type signup_methodsDeleteManyArgs = {
    where?: signup_methodsWhereInput
  }


  /**
   * signup_methods without action
   */
  export type signup_methodsArgs = {
    /**
     * Select specific fields to fetch from the signup_methods
    **/
    select?: signup_methodsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: signup_methodsInclude | null
  }



  /**
   * Model startup_images
   */


  export type AggregateStartup_images = {
    count: Startup_imagesCountAggregateOutputType | null
    avg: Startup_imagesAvgAggregateOutputType | null
    sum: Startup_imagesSumAggregateOutputType | null
    min: Startup_imagesMinAggregateOutputType | null
    max: Startup_imagesMaxAggregateOutputType | null
  }

  export type Startup_imagesAvgAggregateOutputType = {
    id: number
    startup_id: number
  }

  export type Startup_imagesSumAggregateOutputType = {
    id: number
    startup_id: number
  }

  export type Startup_imagesMinAggregateOutputType = {
    id: number
    startup_id: number
    img_url: string | null
  }

  export type Startup_imagesMaxAggregateOutputType = {
    id: number
    startup_id: number
    img_url: string | null
  }

  export type Startup_imagesCountAggregateOutputType = {
    id: number
    startup_id: number
    img_url: number | null
    _all: number
  }


  export type Startup_imagesAvgAggregateInputType = {
    id?: true
    startup_id?: true
  }

  export type Startup_imagesSumAggregateInputType = {
    id?: true
    startup_id?: true
  }

  export type Startup_imagesMinAggregateInputType = {
    id?: true
    startup_id?: true
    img_url?: true
  }

  export type Startup_imagesMaxAggregateInputType = {
    id?: true
    startup_id?: true
    img_url?: true
  }

  export type Startup_imagesCountAggregateInputType = {
    id?: true
    startup_id?: true
    img_url?: true
    _all?: true
  }

  export type Startup_imagesAggregateArgs = {
    /**
     * Filter which startup_images to aggregate.
    **/
    where?: startup_imagesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startup_images to fetch.
    **/
    orderBy?: Enumerable<startup_imagesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: startup_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startup_images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startup_images.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned startup_images
    **/
    count?: true | Startup_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Startup_imagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Startup_imagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Startup_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Startup_imagesMaxAggregateInputType
  }

  export type GetStartup_imagesAggregateType<T extends Startup_imagesAggregateArgs> = {
    [P in keyof T & keyof AggregateStartup_images]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStartup_images[P]>
      : GetScalarType<T[P], AggregateStartup_images[P]>
  }



  export type startup_imagesSelect = {
    id?: boolean
    startup_id?: boolean
    img_url?: boolean
    startups?: boolean | startupsArgs
  }

  export type startup_imagesInclude = {
    startups?: boolean | startupsArgs
  }

  export type startup_imagesGetPayload<
    S extends boolean | null | undefined | startup_imagesArgs,
    U = keyof S
      > = S extends true
        ? startup_images
    : S extends undefined
    ? never
    : S extends startup_imagesArgs | startup_imagesFindManyArgs
    ?'include' extends U
    ? startup_images  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'startups'
        ? startupsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof startup_images ?startup_images [P]
  : 
          P extends 'startups'
        ? startupsGetPayload<S['select'][P]> : never
  } 
    : startup_images
  : startup_images


  type startup_imagesCountArgs = Merge<
    Omit<startup_imagesFindManyArgs, 'select' | 'include'> & {
      select?: Startup_imagesCountAggregateInputType | true
    }
  >

  export interface startup_imagesDelegate {
    /**
     * Find zero or one Startup_images that matches the filter.
     * @param {startup_imagesFindUniqueArgs} args - Arguments to find a Startup_images
     * @example
     * // Get one Startup_images
     * const startup_images = await prisma.startup_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends startup_imagesFindUniqueArgs>(
      args: SelectSubset<T, startup_imagesFindUniqueArgs>
    ): CheckSelect<T, Prisma__startup_imagesClient<startup_images | null>, Prisma__startup_imagesClient<startup_imagesGetPayload<T> | null>>

    /**
     * Find the first Startup_images that matches the filter.
     * @param {startup_imagesFindFirstArgs} args - Arguments to find a Startup_images
     * @example
     * // Get one Startup_images
     * const startup_images = await prisma.startup_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends startup_imagesFindFirstArgs>(
      args?: SelectSubset<T, startup_imagesFindFirstArgs>
    ): CheckSelect<T, Prisma__startup_imagesClient<startup_images | null>, Prisma__startup_imagesClient<startup_imagesGetPayload<T> | null>>

    /**
     * Find zero or more Startup_images that matches the filter.
     * @param {startup_imagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Startup_images
     * const startup_images = await prisma.startup_images.findMany()
     * 
     * // Get first 10 Startup_images
     * const startup_images = await prisma.startup_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const startup_imagesWithIdOnly = await prisma.startup_images.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends startup_imagesFindManyArgs>(
      args?: SelectSubset<T, startup_imagesFindManyArgs>
    ): CheckSelect<T, Promise<Array<startup_images>>, Promise<Array<startup_imagesGetPayload<T>>>>

    /**
     * Create a Startup_images.
     * @param {startup_imagesCreateArgs} args - Arguments to create a Startup_images.
     * @example
     * // Create one Startup_images
     * const Startup_images = await prisma.startup_images.create({
     *   data: {
     *     // ... data to create a Startup_images
     *   }
     * })
     * 
    **/
    create<T extends startup_imagesCreateArgs>(
      args: SelectSubset<T, startup_imagesCreateArgs>
    ): CheckSelect<T, Prisma__startup_imagesClient<startup_images>, Prisma__startup_imagesClient<startup_imagesGetPayload<T>>>

    /**
     * Delete a Startup_images.
     * @param {startup_imagesDeleteArgs} args - Arguments to delete one Startup_images.
     * @example
     * // Delete one Startup_images
     * const Startup_images = await prisma.startup_images.delete({
     *   where: {
     *     // ... filter to delete one Startup_images
     *   }
     * })
     * 
    **/
    delete<T extends startup_imagesDeleteArgs>(
      args: SelectSubset<T, startup_imagesDeleteArgs>
    ): CheckSelect<T, Prisma__startup_imagesClient<startup_images>, Prisma__startup_imagesClient<startup_imagesGetPayload<T>>>

    /**
     * Update one Startup_images.
     * @param {startup_imagesUpdateArgs} args - Arguments to update one Startup_images.
     * @example
     * // Update one Startup_images
     * const startup_images = await prisma.startup_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends startup_imagesUpdateArgs>(
      args: SelectSubset<T, startup_imagesUpdateArgs>
    ): CheckSelect<T, Prisma__startup_imagesClient<startup_images>, Prisma__startup_imagesClient<startup_imagesGetPayload<T>>>

    /**
     * Delete zero or more Startup_images.
     * @param {startup_imagesDeleteManyArgs} args - Arguments to filter Startup_images to delete.
     * @example
     * // Delete a few Startup_images
     * const { count } = await prisma.startup_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends startup_imagesDeleteManyArgs>(
      args?: SelectSubset<T, startup_imagesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Startup_images.
     * @param {startup_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Startup_images
     * const startup_images = await prisma.startup_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends startup_imagesUpdateManyArgs>(
      args: SelectSubset<T, startup_imagesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Startup_images.
     * @param {startup_imagesUpsertArgs} args - Arguments to update or create a Startup_images.
     * @example
     * // Update or create a Startup_images
     * const startup_images = await prisma.startup_images.upsert({
     *   create: {
     *     // ... data to create a Startup_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Startup_images we want to update
     *   }
     * })
    **/
    upsert<T extends startup_imagesUpsertArgs>(
      args: SelectSubset<T, startup_imagesUpsertArgs>
    ): CheckSelect<T, Prisma__startup_imagesClient<startup_images>, Prisma__startup_imagesClient<startup_imagesGetPayload<T>>>

    /**
     * Count the number of Startup_images.
     * @param {startup_imagesCountArgs} args - Arguments to filter Startup_images to count.
     * @example
     * // Count the number of Startup_images
     * const count = await prisma.startup_images.count({
     *   where: {
     *     // ... the filter for the Startup_images we want to count
     *   }
     * })
    **/
    count<T extends startup_imagesCountArgs>(
      args?: Subset<T, startup_imagesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Startup_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Startup_images.
     * @param {Startup_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Startup_imagesAggregateArgs>(args: Subset<T, Startup_imagesAggregateArgs>): Promise<GetStartup_imagesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for startup_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__startup_imagesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    startups<T extends startupsArgs = {}>(args?: Subset<T, startupsArgs>): CheckSelect<T, Prisma__startupsClient<startups | null>, Prisma__startupsClient<startupsGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * startup_images findUnique
   */
  export type startup_imagesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the startup_images
    **/
    select?: startup_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_imagesInclude | null
    /**
     * Throw an Error if a startup_images can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which startup_images to fetch.
    **/
    where: startup_imagesWhereUniqueInput
  }


  /**
   * startup_images findFirst
   */
  export type startup_imagesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the startup_images
    **/
    select?: startup_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_imagesInclude | null
    /**
     * Throw an Error if a startup_images can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which startup_images to fetch.
    **/
    where?: startup_imagesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startup_images to fetch.
    **/
    orderBy?: Enumerable<startup_imagesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for startup_images.
    **/
    cursor?: startup_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startup_images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startup_images.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of startup_images.
    **/
    distinct?: Enumerable<Startup_imagesScalarFieldEnum>
  }


  /**
   * startup_images findMany
   */
  export type startup_imagesFindManyArgs = {
    /**
     * Select specific fields to fetch from the startup_images
    **/
    select?: startup_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_imagesInclude | null
    /**
     * Filter, which startup_images to fetch.
    **/
    where?: startup_imagesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startup_images to fetch.
    **/
    orderBy?: Enumerable<startup_imagesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing startup_images.
    **/
    cursor?: startup_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startup_images from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startup_images.
    **/
    skip?: number
    distinct?: Enumerable<Startup_imagesScalarFieldEnum>
  }


  /**
   * startup_images create
   */
  export type startup_imagesCreateArgs = {
    /**
     * Select specific fields to fetch from the startup_images
    **/
    select?: startup_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_imagesInclude | null
    /**
     * The data needed to create a startup_images.
    **/
    data: XOR<startup_imagesUncheckedCreateInput, startup_imagesCreateInput>
  }


  /**
   * startup_images update
   */
  export type startup_imagesUpdateArgs = {
    /**
     * Select specific fields to fetch from the startup_images
    **/
    select?: startup_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_imagesInclude | null
    /**
     * The data needed to update a startup_images.
    **/
    data: XOR<startup_imagesUncheckedUpdateInput, startup_imagesUpdateInput>
    /**
     * Choose, which startup_images to update.
    **/
    where: startup_imagesWhereUniqueInput
  }


  /**
   * startup_images updateMany
   */
  export type startup_imagesUpdateManyArgs = {
    data: XOR<startup_imagesUncheckedUpdateManyInput, startup_imagesUpdateManyMutationInput>
    where?: startup_imagesWhereInput
  }


  /**
   * startup_images upsert
   */
  export type startup_imagesUpsertArgs = {
    /**
     * Select specific fields to fetch from the startup_images
    **/
    select?: startup_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_imagesInclude | null
    /**
     * The filter to search for the startup_images to update in case it exists.
    **/
    where: startup_imagesWhereUniqueInput
    /**
     * In case the startup_images found by the `where` argument doesn't exist, create a new startup_images with this data.
    **/
    create: XOR<startup_imagesUncheckedCreateInput, startup_imagesCreateInput>
    /**
     * In case the startup_images was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<startup_imagesUncheckedUpdateInput, startup_imagesUpdateInput>
  }


  /**
   * startup_images delete
   */
  export type startup_imagesDeleteArgs = {
    /**
     * Select specific fields to fetch from the startup_images
    **/
    select?: startup_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_imagesInclude | null
    /**
     * Filter which startup_images to delete.
    **/
    where: startup_imagesWhereUniqueInput
  }


  /**
   * startup_images deleteMany
   */
  export type startup_imagesDeleteManyArgs = {
    where?: startup_imagesWhereInput
  }


  /**
   * startup_images without action
   */
  export type startup_imagesArgs = {
    /**
     * Select specific fields to fetch from the startup_images
    **/
    select?: startup_imagesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_imagesInclude | null
  }



  /**
   * Model startups
   */


  export type AggregateStartups = {
    count: StartupsCountAggregateOutputType | null
    avg: StartupsAvgAggregateOutputType | null
    sum: StartupsSumAggregateOutputType | null
    min: StartupsMinAggregateOutputType | null
    max: StartupsMaxAggregateOutputType | null
  }

  export type StartupsAvgAggregateOutputType = {
    id: number
    company_id: number
    sector_id: number | null
    core_technology_id: number | null
    investment_series_id: number | null
    investment_fund_id: number | null
    service_type_id: number | null
    business_type_id: number | null
  }

  export type StartupsSumAggregateOutputType = {
    id: number
    company_id: number
    sector_id: number | null
    core_technology_id: number | null
    investment_series_id: number | null
    investment_fund_id: number | null
    service_type_id: number | null
    business_type_id: number | null
  }

  export type StartupsMinAggregateOutputType = {
    id: number
    company_id: number
    rep: string | null
    sector_id: number | null
    core_technology_id: number | null
    item_description: string | null
    contact: string | null
    investment_series_id: number | null
    investment_fund_id: number | null
    address_road: string | null
    address_detail: string | null
    service_type_id: number | null
    business_type_id: number | null
    business_license_number: string | null
    email: string | null
    instagram_url: string | null
    facebook_url: string | null
    thumbnail: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type StartupsMaxAggregateOutputType = {
    id: number
    company_id: number
    rep: string | null
    sector_id: number | null
    core_technology_id: number | null
    item_description: string | null
    contact: string | null
    investment_series_id: number | null
    investment_fund_id: number | null
    address_road: string | null
    address_detail: string | null
    service_type_id: number | null
    business_type_id: number | null
    business_license_number: string | null
    email: string | null
    instagram_url: string | null
    facebook_url: string | null
    thumbnail: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type StartupsCountAggregateOutputType = {
    id: number
    company_id: number
    rep: number | null
    sector_id: number | null
    core_technology_id: number | null
    item_description: number | null
    contact: number | null
    investment_series_id: number | null
    investment_fund_id: number | null
    address_road: number | null
    address_detail: number | null
    service_type_id: number | null
    business_type_id: number | null
    business_license_number: number | null
    email: number | null
    instagram_url: number | null
    facebook_url: number | null
    thumbnail: number | null
    created_at: number | null
    updated_at: number | null
    deleted_at: number | null
    _all: number
  }


  export type StartupsAvgAggregateInputType = {
    id?: true
    company_id?: true
    sector_id?: true
    core_technology_id?: true
    investment_series_id?: true
    investment_fund_id?: true
    service_type_id?: true
    business_type_id?: true
  }

  export type StartupsSumAggregateInputType = {
    id?: true
    company_id?: true
    sector_id?: true
    core_technology_id?: true
    investment_series_id?: true
    investment_fund_id?: true
    service_type_id?: true
    business_type_id?: true
  }

  export type StartupsMinAggregateInputType = {
    id?: true
    company_id?: true
    rep?: true
    sector_id?: true
    core_technology_id?: true
    item_description?: true
    contact?: true
    investment_series_id?: true
    investment_fund_id?: true
    address_road?: true
    address_detail?: true
    service_type_id?: true
    business_type_id?: true
    business_license_number?: true
    email?: true
    instagram_url?: true
    facebook_url?: true
    thumbnail?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type StartupsMaxAggregateInputType = {
    id?: true
    company_id?: true
    rep?: true
    sector_id?: true
    core_technology_id?: true
    item_description?: true
    contact?: true
    investment_series_id?: true
    investment_fund_id?: true
    address_road?: true
    address_detail?: true
    service_type_id?: true
    business_type_id?: true
    business_license_number?: true
    email?: true
    instagram_url?: true
    facebook_url?: true
    thumbnail?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type StartupsCountAggregateInputType = {
    id?: true
    company_id?: true
    rep?: true
    sector_id?: true
    core_technology_id?: true
    item_description?: true
    contact?: true
    investment_series_id?: true
    investment_fund_id?: true
    address_road?: true
    address_detail?: true
    service_type_id?: true
    business_type_id?: true
    business_license_number?: true
    email?: true
    instagram_url?: true
    facebook_url?: true
    thumbnail?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type StartupsAggregateArgs = {
    /**
     * Filter which startups to aggregate.
    **/
    where?: startupsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startups to fetch.
    **/
    orderBy?: Enumerable<startupsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: startupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startups from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startups.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned startups
    **/
    count?: true | StartupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: StartupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: StartupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: StartupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: StartupsMaxAggregateInputType
  }

  export type GetStartupsAggregateType<T extends StartupsAggregateArgs> = {
    [P in keyof T & keyof AggregateStartups]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStartups[P]>
      : GetScalarType<T[P], AggregateStartups[P]>
  }



  export type startupsSelect = {
    id?: boolean
    company_id?: boolean
    rep?: boolean
    sector_id?: boolean
    core_technology_id?: boolean
    item_description?: boolean
    contact?: boolean
    investment_series_id?: boolean
    investment_fund_id?: boolean
    address_road?: boolean
    address_detail?: boolean
    service_type_id?: boolean
    business_type_id?: boolean
    business_license_number?: boolean
    email?: boolean
    instagram_url?: boolean
    facebook_url?: boolean
    thumbnail?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    business_types?: boolean | business_typesArgs
    companies?: boolean | companiesArgs
    technologies?: boolean | technologiesArgs
    sectors?: boolean | sectorsArgs
    service_types?: boolean | service_typesArgs
    investment_series?: boolean | investment_seriesArgs
    investment_funds?: boolean | investment_fundsArgs
    invested_from?: boolean | invested_fromFindManyArgs
    startup_images?: boolean | startup_imagesFindManyArgs
    wish_investment_series?: boolean | wish_investment_seriesFindManyArgs
    IR_requests?: boolean | IR_requestsFindManyArgs
  }

  export type startupsInclude = {
    business_types?: boolean | business_typesArgs
    companies?: boolean | companiesArgs
    technologies?: boolean | technologiesArgs
    sectors?: boolean | sectorsArgs
    service_types?: boolean | service_typesArgs
    investment_series?: boolean | investment_seriesArgs
    investment_funds?: boolean | investment_fundsArgs
    invested_from?: boolean | invested_fromFindManyArgs
    startup_images?: boolean | startup_imagesFindManyArgs
    wish_investment_series?: boolean | wish_investment_seriesFindManyArgs
    IR_requests?: boolean | IR_requestsFindManyArgs
  }

  export type startupsGetPayload<
    S extends boolean | null | undefined | startupsArgs,
    U = keyof S
      > = S extends true
        ? startups
    : S extends undefined
    ? never
    : S extends startupsArgs | startupsFindManyArgs
    ?'include' extends U
    ? startups  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'business_types'
        ? business_typesGetPayload<S['include'][P]> | null :
        P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'technologies'
        ? technologiesGetPayload<S['include'][P]> | null :
        P extends 'sectors'
        ? sectorsGetPayload<S['include'][P]> | null :
        P extends 'service_types'
        ? service_typesGetPayload<S['include'][P]> | null :
        P extends 'investment_series'
        ? investment_seriesGetPayload<S['include'][P]> | null :
        P extends 'investment_funds'
        ? investment_fundsGetPayload<S['include'][P]> | null :
        P extends 'invested_from'
        ? Array < invested_fromGetPayload<S['include'][P]>>  :
        P extends 'startup_images'
        ? Array < startup_imagesGetPayload<S['include'][P]>>  :
        P extends 'wish_investment_series'
        ? Array < wish_investment_seriesGetPayload<S['include'][P]>>  :
        P extends 'IR_requests'
        ? Array < IR_requestsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof startups ?startups [P]
  : 
          P extends 'business_types'
        ? business_typesGetPayload<S['select'][P]> | null :
        P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'technologies'
        ? technologiesGetPayload<S['select'][P]> | null :
        P extends 'sectors'
        ? sectorsGetPayload<S['select'][P]> | null :
        P extends 'service_types'
        ? service_typesGetPayload<S['select'][P]> | null :
        P extends 'investment_series'
        ? investment_seriesGetPayload<S['select'][P]> | null :
        P extends 'investment_funds'
        ? investment_fundsGetPayload<S['select'][P]> | null :
        P extends 'invested_from'
        ? Array < invested_fromGetPayload<S['select'][P]>>  :
        P extends 'startup_images'
        ? Array < startup_imagesGetPayload<S['select'][P]>>  :
        P extends 'wish_investment_series'
        ? Array < wish_investment_seriesGetPayload<S['select'][P]>>  :
        P extends 'IR_requests'
        ? Array < IR_requestsGetPayload<S['select'][P]>>  : never
  } 
    : startups
  : startups


  type startupsCountArgs = Merge<
    Omit<startupsFindManyArgs, 'select' | 'include'> & {
      select?: StartupsCountAggregateInputType | true
    }
  >

  export interface startupsDelegate {
    /**
     * Find zero or one Startups that matches the filter.
     * @param {startupsFindUniqueArgs} args - Arguments to find a Startups
     * @example
     * // Get one Startups
     * const startups = await prisma.startups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends startupsFindUniqueArgs>(
      args: SelectSubset<T, startupsFindUniqueArgs>
    ): CheckSelect<T, Prisma__startupsClient<startups | null>, Prisma__startupsClient<startupsGetPayload<T> | null>>

    /**
     * Find the first Startups that matches the filter.
     * @param {startupsFindFirstArgs} args - Arguments to find a Startups
     * @example
     * // Get one Startups
     * const startups = await prisma.startups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends startupsFindFirstArgs>(
      args?: SelectSubset<T, startupsFindFirstArgs>
    ): CheckSelect<T, Prisma__startupsClient<startups | null>, Prisma__startupsClient<startupsGetPayload<T> | null>>

    /**
     * Find zero or more Startups that matches the filter.
     * @param {startupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Startups
     * const startups = await prisma.startups.findMany()
     * 
     * // Get first 10 Startups
     * const startups = await prisma.startups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const startupsWithIdOnly = await prisma.startups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends startupsFindManyArgs>(
      args?: SelectSubset<T, startupsFindManyArgs>
    ): CheckSelect<T, Promise<Array<startups>>, Promise<Array<startupsGetPayload<T>>>>

    /**
     * Create a Startups.
     * @param {startupsCreateArgs} args - Arguments to create a Startups.
     * @example
     * // Create one Startups
     * const Startups = await prisma.startups.create({
     *   data: {
     *     // ... data to create a Startups
     *   }
     * })
     * 
    **/
    create<T extends startupsCreateArgs>(
      args: SelectSubset<T, startupsCreateArgs>
    ): CheckSelect<T, Prisma__startupsClient<startups>, Prisma__startupsClient<startupsGetPayload<T>>>

    /**
     * Delete a Startups.
     * @param {startupsDeleteArgs} args - Arguments to delete one Startups.
     * @example
     * // Delete one Startups
     * const Startups = await prisma.startups.delete({
     *   where: {
     *     // ... filter to delete one Startups
     *   }
     * })
     * 
    **/
    delete<T extends startupsDeleteArgs>(
      args: SelectSubset<T, startupsDeleteArgs>
    ): CheckSelect<T, Prisma__startupsClient<startups>, Prisma__startupsClient<startupsGetPayload<T>>>

    /**
     * Update one Startups.
     * @param {startupsUpdateArgs} args - Arguments to update one Startups.
     * @example
     * // Update one Startups
     * const startups = await prisma.startups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends startupsUpdateArgs>(
      args: SelectSubset<T, startupsUpdateArgs>
    ): CheckSelect<T, Prisma__startupsClient<startups>, Prisma__startupsClient<startupsGetPayload<T>>>

    /**
     * Delete zero or more Startups.
     * @param {startupsDeleteManyArgs} args - Arguments to filter Startups to delete.
     * @example
     * // Delete a few Startups
     * const { count } = await prisma.startups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends startupsDeleteManyArgs>(
      args?: SelectSubset<T, startupsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Startups.
     * @param {startupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Startups
     * const startups = await prisma.startups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends startupsUpdateManyArgs>(
      args: SelectSubset<T, startupsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Startups.
     * @param {startupsUpsertArgs} args - Arguments to update or create a Startups.
     * @example
     * // Update or create a Startups
     * const startups = await prisma.startups.upsert({
     *   create: {
     *     // ... data to create a Startups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Startups we want to update
     *   }
     * })
    **/
    upsert<T extends startupsUpsertArgs>(
      args: SelectSubset<T, startupsUpsertArgs>
    ): CheckSelect<T, Prisma__startupsClient<startups>, Prisma__startupsClient<startupsGetPayload<T>>>

    /**
     * Count the number of Startups.
     * @param {startupsCountArgs} args - Arguments to filter Startups to count.
     * @example
     * // Count the number of Startups
     * const count = await prisma.startups.count({
     *   where: {
     *     // ... the filter for the Startups we want to count
     *   }
     * })
    **/
    count<T extends startupsCountArgs>(
      args?: Subset<T, startupsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StartupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Startups.
     * @param {StartupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StartupsAggregateArgs>(args: Subset<T, StartupsAggregateArgs>): Promise<GetStartupsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for startups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__startupsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    business_types<T extends business_typesArgs = {}>(args?: Subset<T, business_typesArgs>): CheckSelect<T, Prisma__business_typesClient<business_types | null>, Prisma__business_typesClient<business_typesGetPayload<T> | null>>;

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    technologies<T extends technologiesArgs = {}>(args?: Subset<T, technologiesArgs>): CheckSelect<T, Prisma__technologiesClient<technologies | null>, Prisma__technologiesClient<technologiesGetPayload<T> | null>>;

    sectors<T extends sectorsArgs = {}>(args?: Subset<T, sectorsArgs>): CheckSelect<T, Prisma__sectorsClient<sectors | null>, Prisma__sectorsClient<sectorsGetPayload<T> | null>>;

    service_types<T extends service_typesArgs = {}>(args?: Subset<T, service_typesArgs>): CheckSelect<T, Prisma__service_typesClient<service_types | null>, Prisma__service_typesClient<service_typesGetPayload<T> | null>>;

    investment_series<T extends investment_seriesArgs = {}>(args?: Subset<T, investment_seriesArgs>): CheckSelect<T, Prisma__investment_seriesClient<investment_series | null>, Prisma__investment_seriesClient<investment_seriesGetPayload<T> | null>>;

    investment_funds<T extends investment_fundsArgs = {}>(args?: Subset<T, investment_fundsArgs>): CheckSelect<T, Prisma__investment_fundsClient<investment_funds | null>, Prisma__investment_fundsClient<investment_fundsGetPayload<T> | null>>;

    invested_from<T extends invested_fromFindManyArgs = {}>(args?: Subset<T, invested_fromFindManyArgs>): CheckSelect<T, Promise<Array<invested_from>>, Promise<Array<invested_fromGetPayload<T>>>>;

    startup_images<T extends startup_imagesFindManyArgs = {}>(args?: Subset<T, startup_imagesFindManyArgs>): CheckSelect<T, Promise<Array<startup_images>>, Promise<Array<startup_imagesGetPayload<T>>>>;

    wish_investment_series<T extends wish_investment_seriesFindManyArgs = {}>(args?: Subset<T, wish_investment_seriesFindManyArgs>): CheckSelect<T, Promise<Array<wish_investment_series>>, Promise<Array<wish_investment_seriesGetPayload<T>>>>;

    IR_requests<T extends IR_requestsFindManyArgs = {}>(args?: Subset<T, IR_requestsFindManyArgs>): CheckSelect<T, Promise<Array<IR_requests>>, Promise<Array<IR_requestsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * startups findUnique
   */
  export type startupsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the startups
    **/
    select?: startupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startupsInclude | null
    /**
     * Throw an Error if a startups can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which startups to fetch.
    **/
    where: startupsWhereUniqueInput
  }


  /**
   * startups findFirst
   */
  export type startupsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the startups
    **/
    select?: startupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startupsInclude | null
    /**
     * Throw an Error if a startups can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which startups to fetch.
    **/
    where?: startupsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startups to fetch.
    **/
    orderBy?: Enumerable<startupsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for startups.
    **/
    cursor?: startupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startups from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startups.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of startups.
    **/
    distinct?: Enumerable<StartupsScalarFieldEnum>
  }


  /**
   * startups findMany
   */
  export type startupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the startups
    **/
    select?: startupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startupsInclude | null
    /**
     * Filter, which startups to fetch.
    **/
    where?: startupsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startups to fetch.
    **/
    orderBy?: Enumerable<startupsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing startups.
    **/
    cursor?: startupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startups from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startups.
    **/
    skip?: number
    distinct?: Enumerable<StartupsScalarFieldEnum>
  }


  /**
   * startups create
   */
  export type startupsCreateArgs = {
    /**
     * Select specific fields to fetch from the startups
    **/
    select?: startupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startupsInclude | null
    /**
     * The data needed to create a startups.
    **/
    data: XOR<startupsUncheckedCreateInput, startupsCreateInput>
  }


  /**
   * startups update
   */
  export type startupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the startups
    **/
    select?: startupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startupsInclude | null
    /**
     * The data needed to update a startups.
    **/
    data: XOR<startupsUncheckedUpdateInput, startupsUpdateInput>
    /**
     * Choose, which startups to update.
    **/
    where: startupsWhereUniqueInput
  }


  /**
   * startups updateMany
   */
  export type startupsUpdateManyArgs = {
    data: XOR<startupsUncheckedUpdateManyInput, startupsUpdateManyMutationInput>
    where?: startupsWhereInput
  }


  /**
   * startups upsert
   */
  export type startupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the startups
    **/
    select?: startupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startupsInclude | null
    /**
     * The filter to search for the startups to update in case it exists.
    **/
    where: startupsWhereUniqueInput
    /**
     * In case the startups found by the `where` argument doesn't exist, create a new startups with this data.
    **/
    create: XOR<startupsUncheckedCreateInput, startupsCreateInput>
    /**
     * In case the startups was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<startupsUncheckedUpdateInput, startupsUpdateInput>
  }


  /**
   * startups delete
   */
  export type startupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the startups
    **/
    select?: startupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startupsInclude | null
    /**
     * Filter which startups to delete.
    **/
    where: startupsWhereUniqueInput
  }


  /**
   * startups deleteMany
   */
  export type startupsDeleteManyArgs = {
    where?: startupsWhereInput
  }


  /**
   * startups without action
   */
  export type startupsArgs = {
    /**
     * Select specific fields to fetch from the startups
    **/
    select?: startupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startupsInclude | null
  }



  /**
   * Model wish_investment_series
   */


  export type AggregateWish_investment_series = {
    count: Wish_investment_seriesCountAggregateOutputType | null
    avg: Wish_investment_seriesAvgAggregateOutputType | null
    sum: Wish_investment_seriesSumAggregateOutputType | null
    min: Wish_investment_seriesMinAggregateOutputType | null
    max: Wish_investment_seriesMaxAggregateOutputType | null
  }

  export type Wish_investment_seriesAvgAggregateOutputType = {
    id: number
    startup_id: number
    investment_series_id: number
  }

  export type Wish_investment_seriesSumAggregateOutputType = {
    id: number
    startup_id: number
    investment_series_id: number
  }

  export type Wish_investment_seriesMinAggregateOutputType = {
    id: number
    startup_id: number
    investment_series_id: number
  }

  export type Wish_investment_seriesMaxAggregateOutputType = {
    id: number
    startup_id: number
    investment_series_id: number
  }

  export type Wish_investment_seriesCountAggregateOutputType = {
    id: number
    startup_id: number
    investment_series_id: number
    _all: number
  }


  export type Wish_investment_seriesAvgAggregateInputType = {
    id?: true
    startup_id?: true
    investment_series_id?: true
  }

  export type Wish_investment_seriesSumAggregateInputType = {
    id?: true
    startup_id?: true
    investment_series_id?: true
  }

  export type Wish_investment_seriesMinAggregateInputType = {
    id?: true
    startup_id?: true
    investment_series_id?: true
  }

  export type Wish_investment_seriesMaxAggregateInputType = {
    id?: true
    startup_id?: true
    investment_series_id?: true
  }

  export type Wish_investment_seriesCountAggregateInputType = {
    id?: true
    startup_id?: true
    investment_series_id?: true
    _all?: true
  }

  export type Wish_investment_seriesAggregateArgs = {
    /**
     * Filter which wish_investment_series to aggregate.
    **/
    where?: wish_investment_seriesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of wish_investment_series to fetch.
    **/
    orderBy?: Enumerable<wish_investment_seriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: wish_investment_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wish_investment_series from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wish_investment_series.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wish_investment_series
    **/
    count?: true | Wish_investment_seriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Wish_investment_seriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Wish_investment_seriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Wish_investment_seriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Wish_investment_seriesMaxAggregateInputType
  }

  export type GetWish_investment_seriesAggregateType<T extends Wish_investment_seriesAggregateArgs> = {
    [P in keyof T & keyof AggregateWish_investment_series]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWish_investment_series[P]>
      : GetScalarType<T[P], AggregateWish_investment_series[P]>
  }



  export type wish_investment_seriesSelect = {
    id?: boolean
    startup_id?: boolean
    investment_series_id?: boolean
    startups?: boolean | startupsArgs
    investment_series?: boolean | investment_seriesArgs
  }

  export type wish_investment_seriesInclude = {
    startups?: boolean | startupsArgs
    investment_series?: boolean | investment_seriesArgs
  }

  export type wish_investment_seriesGetPayload<
    S extends boolean | null | undefined | wish_investment_seriesArgs,
    U = keyof S
      > = S extends true
        ? wish_investment_series
    : S extends undefined
    ? never
    : S extends wish_investment_seriesArgs | wish_investment_seriesFindManyArgs
    ?'include' extends U
    ? wish_investment_series  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'startups'
        ? startupsGetPayload<S['include'][P]> :
        P extends 'investment_series'
        ? investment_seriesGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof wish_investment_series ?wish_investment_series [P]
  : 
          P extends 'startups'
        ? startupsGetPayload<S['select'][P]> :
        P extends 'investment_series'
        ? investment_seriesGetPayload<S['select'][P]> : never
  } 
    : wish_investment_series
  : wish_investment_series


  type wish_investment_seriesCountArgs = Merge<
    Omit<wish_investment_seriesFindManyArgs, 'select' | 'include'> & {
      select?: Wish_investment_seriesCountAggregateInputType | true
    }
  >

  export interface wish_investment_seriesDelegate {
    /**
     * Find zero or one Wish_investment_series that matches the filter.
     * @param {wish_investment_seriesFindUniqueArgs} args - Arguments to find a Wish_investment_series
     * @example
     * // Get one Wish_investment_series
     * const wish_investment_series = await prisma.wish_investment_series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends wish_investment_seriesFindUniqueArgs>(
      args: SelectSubset<T, wish_investment_seriesFindUniqueArgs>
    ): CheckSelect<T, Prisma__wish_investment_seriesClient<wish_investment_series | null>, Prisma__wish_investment_seriesClient<wish_investment_seriesGetPayload<T> | null>>

    /**
     * Find the first Wish_investment_series that matches the filter.
     * @param {wish_investment_seriesFindFirstArgs} args - Arguments to find a Wish_investment_series
     * @example
     * // Get one Wish_investment_series
     * const wish_investment_series = await prisma.wish_investment_series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends wish_investment_seriesFindFirstArgs>(
      args?: SelectSubset<T, wish_investment_seriesFindFirstArgs>
    ): CheckSelect<T, Prisma__wish_investment_seriesClient<wish_investment_series | null>, Prisma__wish_investment_seriesClient<wish_investment_seriesGetPayload<T> | null>>

    /**
     * Find zero or more Wish_investment_series that matches the filter.
     * @param {wish_investment_seriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wish_investment_series
     * const wish_investment_series = await prisma.wish_investment_series.findMany()
     * 
     * // Get first 10 Wish_investment_series
     * const wish_investment_series = await prisma.wish_investment_series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wish_investment_seriesWithIdOnly = await prisma.wish_investment_series.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends wish_investment_seriesFindManyArgs>(
      args?: SelectSubset<T, wish_investment_seriesFindManyArgs>
    ): CheckSelect<T, Promise<Array<wish_investment_series>>, Promise<Array<wish_investment_seriesGetPayload<T>>>>

    /**
     * Create a Wish_investment_series.
     * @param {wish_investment_seriesCreateArgs} args - Arguments to create a Wish_investment_series.
     * @example
     * // Create one Wish_investment_series
     * const Wish_investment_series = await prisma.wish_investment_series.create({
     *   data: {
     *     // ... data to create a Wish_investment_series
     *   }
     * })
     * 
    **/
    create<T extends wish_investment_seriesCreateArgs>(
      args: SelectSubset<T, wish_investment_seriesCreateArgs>
    ): CheckSelect<T, Prisma__wish_investment_seriesClient<wish_investment_series>, Prisma__wish_investment_seriesClient<wish_investment_seriesGetPayload<T>>>

    /**
     * Delete a Wish_investment_series.
     * @param {wish_investment_seriesDeleteArgs} args - Arguments to delete one Wish_investment_series.
     * @example
     * // Delete one Wish_investment_series
     * const Wish_investment_series = await prisma.wish_investment_series.delete({
     *   where: {
     *     // ... filter to delete one Wish_investment_series
     *   }
     * })
     * 
    **/
    delete<T extends wish_investment_seriesDeleteArgs>(
      args: SelectSubset<T, wish_investment_seriesDeleteArgs>
    ): CheckSelect<T, Prisma__wish_investment_seriesClient<wish_investment_series>, Prisma__wish_investment_seriesClient<wish_investment_seriesGetPayload<T>>>

    /**
     * Update one Wish_investment_series.
     * @param {wish_investment_seriesUpdateArgs} args - Arguments to update one Wish_investment_series.
     * @example
     * // Update one Wish_investment_series
     * const wish_investment_series = await prisma.wish_investment_series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends wish_investment_seriesUpdateArgs>(
      args: SelectSubset<T, wish_investment_seriesUpdateArgs>
    ): CheckSelect<T, Prisma__wish_investment_seriesClient<wish_investment_series>, Prisma__wish_investment_seriesClient<wish_investment_seriesGetPayload<T>>>

    /**
     * Delete zero or more Wish_investment_series.
     * @param {wish_investment_seriesDeleteManyArgs} args - Arguments to filter Wish_investment_series to delete.
     * @example
     * // Delete a few Wish_investment_series
     * const { count } = await prisma.wish_investment_series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends wish_investment_seriesDeleteManyArgs>(
      args?: SelectSubset<T, wish_investment_seriesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Wish_investment_series.
     * @param {wish_investment_seriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wish_investment_series
     * const wish_investment_series = await prisma.wish_investment_series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends wish_investment_seriesUpdateManyArgs>(
      args: SelectSubset<T, wish_investment_seriesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Wish_investment_series.
     * @param {wish_investment_seriesUpsertArgs} args - Arguments to update or create a Wish_investment_series.
     * @example
     * // Update or create a Wish_investment_series
     * const wish_investment_series = await prisma.wish_investment_series.upsert({
     *   create: {
     *     // ... data to create a Wish_investment_series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wish_investment_series we want to update
     *   }
     * })
    **/
    upsert<T extends wish_investment_seriesUpsertArgs>(
      args: SelectSubset<T, wish_investment_seriesUpsertArgs>
    ): CheckSelect<T, Prisma__wish_investment_seriesClient<wish_investment_series>, Prisma__wish_investment_seriesClient<wish_investment_seriesGetPayload<T>>>

    /**
     * Count the number of Wish_investment_series.
     * @param {wish_investment_seriesCountArgs} args - Arguments to filter Wish_investment_series to count.
     * @example
     * // Count the number of Wish_investment_series
     * const count = await prisma.wish_investment_series.count({
     *   where: {
     *     // ... the filter for the Wish_investment_series we want to count
     *   }
     * })
    **/
    count<T extends wish_investment_seriesCountArgs>(
      args?: Subset<T, wish_investment_seriesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wish_investment_seriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wish_investment_series.
     * @param {Wish_investment_seriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wish_investment_seriesAggregateArgs>(args: Subset<T, Wish_investment_seriesAggregateArgs>): Promise<GetWish_investment_seriesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for wish_investment_series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__wish_investment_seriesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    startups<T extends startupsArgs = {}>(args?: Subset<T, startupsArgs>): CheckSelect<T, Prisma__startupsClient<startups | null>, Prisma__startupsClient<startupsGetPayload<T> | null>>;

    investment_series<T extends investment_seriesArgs = {}>(args?: Subset<T, investment_seriesArgs>): CheckSelect<T, Prisma__investment_seriesClient<investment_series | null>, Prisma__investment_seriesClient<investment_seriesGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * wish_investment_series findUnique
   */
  export type wish_investment_seriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the wish_investment_series
    **/
    select?: wish_investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: wish_investment_seriesInclude | null
    /**
     * Throw an Error if a wish_investment_series can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which wish_investment_series to fetch.
    **/
    where: wish_investment_seriesWhereUniqueInput
  }


  /**
   * wish_investment_series findFirst
   */
  export type wish_investment_seriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the wish_investment_series
    **/
    select?: wish_investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: wish_investment_seriesInclude | null
    /**
     * Throw an Error if a wish_investment_series can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which wish_investment_series to fetch.
    **/
    where?: wish_investment_seriesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of wish_investment_series to fetch.
    **/
    orderBy?: Enumerable<wish_investment_seriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wish_investment_series.
    **/
    cursor?: wish_investment_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wish_investment_series from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wish_investment_series.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of wish_investment_series.
    **/
    distinct?: Enumerable<Wish_investment_seriesScalarFieldEnum>
  }


  /**
   * wish_investment_series findMany
   */
  export type wish_investment_seriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the wish_investment_series
    **/
    select?: wish_investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: wish_investment_seriesInclude | null
    /**
     * Filter, which wish_investment_series to fetch.
    **/
    where?: wish_investment_seriesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of wish_investment_series to fetch.
    **/
    orderBy?: Enumerable<wish_investment_seriesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wish_investment_series.
    **/
    cursor?: wish_investment_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wish_investment_series from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wish_investment_series.
    **/
    skip?: number
    distinct?: Enumerable<Wish_investment_seriesScalarFieldEnum>
  }


  /**
   * wish_investment_series create
   */
  export type wish_investment_seriesCreateArgs = {
    /**
     * Select specific fields to fetch from the wish_investment_series
    **/
    select?: wish_investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: wish_investment_seriesInclude | null
    /**
     * The data needed to create a wish_investment_series.
    **/
    data: XOR<wish_investment_seriesUncheckedCreateInput, wish_investment_seriesCreateInput>
  }


  /**
   * wish_investment_series update
   */
  export type wish_investment_seriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the wish_investment_series
    **/
    select?: wish_investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: wish_investment_seriesInclude | null
    /**
     * The data needed to update a wish_investment_series.
    **/
    data: XOR<wish_investment_seriesUncheckedUpdateInput, wish_investment_seriesUpdateInput>
    /**
     * Choose, which wish_investment_series to update.
    **/
    where: wish_investment_seriesWhereUniqueInput
  }


  /**
   * wish_investment_series updateMany
   */
  export type wish_investment_seriesUpdateManyArgs = {
    data: XOR<wish_investment_seriesUncheckedUpdateManyInput, wish_investment_seriesUpdateManyMutationInput>
    where?: wish_investment_seriesWhereInput
  }


  /**
   * wish_investment_series upsert
   */
  export type wish_investment_seriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the wish_investment_series
    **/
    select?: wish_investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: wish_investment_seriesInclude | null
    /**
     * The filter to search for the wish_investment_series to update in case it exists.
    **/
    where: wish_investment_seriesWhereUniqueInput
    /**
     * In case the wish_investment_series found by the `where` argument doesn't exist, create a new wish_investment_series with this data.
    **/
    create: XOR<wish_investment_seriesUncheckedCreateInput, wish_investment_seriesCreateInput>
    /**
     * In case the wish_investment_series was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<wish_investment_seriesUncheckedUpdateInput, wish_investment_seriesUpdateInput>
  }


  /**
   * wish_investment_series delete
   */
  export type wish_investment_seriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the wish_investment_series
    **/
    select?: wish_investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: wish_investment_seriesInclude | null
    /**
     * Filter which wish_investment_series to delete.
    **/
    where: wish_investment_seriesWhereUniqueInput
  }


  /**
   * wish_investment_series deleteMany
   */
  export type wish_investment_seriesDeleteManyArgs = {
    where?: wish_investment_seriesWhereInput
  }


  /**
   * wish_investment_series without action
   */
  export type wish_investment_seriesArgs = {
    /**
     * Select specific fields to fetch from the wish_investment_series
    **/
    select?: wish_investment_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: wish_investment_seriesInclude | null
  }



  /**
   * Model startup_likes
   */


  export type AggregateStartup_likes = {
    count: Startup_likesCountAggregateOutputType | null
    avg: Startup_likesAvgAggregateOutputType | null
    sum: Startup_likesSumAggregateOutputType | null
    min: Startup_likesMinAggregateOutputType | null
    max: Startup_likesMaxAggregateOutputType | null
  }

  export type Startup_likesAvgAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
  }

  export type Startup_likesSumAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
  }

  export type Startup_likesMinAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
    is_liked: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Startup_likesMaxAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
    is_liked: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Startup_likesCountAggregateOutputType = {
    id: number
    user_id: number
    company_id: number
    is_liked: number | null
    created_at: number | null
    updated_at: number | null
    _all: number
  }


  export type Startup_likesAvgAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
  }

  export type Startup_likesSumAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
  }

  export type Startup_likesMinAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
  }

  export type Startup_likesMaxAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
  }

  export type Startup_likesCountAggregateInputType = {
    id?: true
    user_id?: true
    company_id?: true
    is_liked?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Startup_likesAggregateArgs = {
    /**
     * Filter which startup_likes to aggregate.
    **/
    where?: startup_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startup_likes to fetch.
    **/
    orderBy?: Enumerable<startup_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: startup_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startup_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startup_likes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned startup_likes
    **/
    count?: true | Startup_likesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: Startup_likesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: Startup_likesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: Startup_likesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: Startup_likesMaxAggregateInputType
  }

  export type GetStartup_likesAggregateType<T extends Startup_likesAggregateArgs> = {
    [P in keyof T & keyof AggregateStartup_likes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStartup_likes[P]>
      : GetScalarType<T[P], AggregateStartup_likes[P]>
  }



  export type startup_likesSelect = {
    id?: boolean
    user_id?: boolean
    company_id?: boolean
    is_liked?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesArgs
    users?: boolean | usersArgs
  }

  export type startup_likesInclude = {
    companies?: boolean | companiesArgs
    users?: boolean | usersArgs
  }

  export type startup_likesGetPayload<
    S extends boolean | null | undefined | startup_likesArgs,
    U = keyof S
      > = S extends true
        ? startup_likes
    : S extends undefined
    ? never
    : S extends startup_likesArgs | startup_likesFindManyArgs
    ?'include' extends U
    ? startup_likes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> :
        P extends 'users'
        ? usersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof startup_likes ?startup_likes [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> :
        P extends 'users'
        ? usersGetPayload<S['select'][P]> : never
  } 
    : startup_likes
  : startup_likes


  type startup_likesCountArgs = Merge<
    Omit<startup_likesFindManyArgs, 'select' | 'include'> & {
      select?: Startup_likesCountAggregateInputType | true
    }
  >

  export interface startup_likesDelegate {
    /**
     * Find zero or one Startup_likes that matches the filter.
     * @param {startup_likesFindUniqueArgs} args - Arguments to find a Startup_likes
     * @example
     * // Get one Startup_likes
     * const startup_likes = await prisma.startup_likes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends startup_likesFindUniqueArgs>(
      args: SelectSubset<T, startup_likesFindUniqueArgs>
    ): CheckSelect<T, Prisma__startup_likesClient<startup_likes | null>, Prisma__startup_likesClient<startup_likesGetPayload<T> | null>>

    /**
     * Find the first Startup_likes that matches the filter.
     * @param {startup_likesFindFirstArgs} args - Arguments to find a Startup_likes
     * @example
     * // Get one Startup_likes
     * const startup_likes = await prisma.startup_likes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends startup_likesFindFirstArgs>(
      args?: SelectSubset<T, startup_likesFindFirstArgs>
    ): CheckSelect<T, Prisma__startup_likesClient<startup_likes | null>, Prisma__startup_likesClient<startup_likesGetPayload<T> | null>>

    /**
     * Find zero or more Startup_likes that matches the filter.
     * @param {startup_likesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Startup_likes
     * const startup_likes = await prisma.startup_likes.findMany()
     * 
     * // Get first 10 Startup_likes
     * const startup_likes = await prisma.startup_likes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const startup_likesWithIdOnly = await prisma.startup_likes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends startup_likesFindManyArgs>(
      args?: SelectSubset<T, startup_likesFindManyArgs>
    ): CheckSelect<T, Promise<Array<startup_likes>>, Promise<Array<startup_likesGetPayload<T>>>>

    /**
     * Create a Startup_likes.
     * @param {startup_likesCreateArgs} args - Arguments to create a Startup_likes.
     * @example
     * // Create one Startup_likes
     * const Startup_likes = await prisma.startup_likes.create({
     *   data: {
     *     // ... data to create a Startup_likes
     *   }
     * })
     * 
    **/
    create<T extends startup_likesCreateArgs>(
      args: SelectSubset<T, startup_likesCreateArgs>
    ): CheckSelect<T, Prisma__startup_likesClient<startup_likes>, Prisma__startup_likesClient<startup_likesGetPayload<T>>>

    /**
     * Delete a Startup_likes.
     * @param {startup_likesDeleteArgs} args - Arguments to delete one Startup_likes.
     * @example
     * // Delete one Startup_likes
     * const Startup_likes = await prisma.startup_likes.delete({
     *   where: {
     *     // ... filter to delete one Startup_likes
     *   }
     * })
     * 
    **/
    delete<T extends startup_likesDeleteArgs>(
      args: SelectSubset<T, startup_likesDeleteArgs>
    ): CheckSelect<T, Prisma__startup_likesClient<startup_likes>, Prisma__startup_likesClient<startup_likesGetPayload<T>>>

    /**
     * Update one Startup_likes.
     * @param {startup_likesUpdateArgs} args - Arguments to update one Startup_likes.
     * @example
     * // Update one Startup_likes
     * const startup_likes = await prisma.startup_likes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends startup_likesUpdateArgs>(
      args: SelectSubset<T, startup_likesUpdateArgs>
    ): CheckSelect<T, Prisma__startup_likesClient<startup_likes>, Prisma__startup_likesClient<startup_likesGetPayload<T>>>

    /**
     * Delete zero or more Startup_likes.
     * @param {startup_likesDeleteManyArgs} args - Arguments to filter Startup_likes to delete.
     * @example
     * // Delete a few Startup_likes
     * const { count } = await prisma.startup_likes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends startup_likesDeleteManyArgs>(
      args?: SelectSubset<T, startup_likesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Startup_likes.
     * @param {startup_likesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Startup_likes
     * const startup_likes = await prisma.startup_likes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends startup_likesUpdateManyArgs>(
      args: SelectSubset<T, startup_likesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Startup_likes.
     * @param {startup_likesUpsertArgs} args - Arguments to update or create a Startup_likes.
     * @example
     * // Update or create a Startup_likes
     * const startup_likes = await prisma.startup_likes.upsert({
     *   create: {
     *     // ... data to create a Startup_likes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Startup_likes we want to update
     *   }
     * })
    **/
    upsert<T extends startup_likesUpsertArgs>(
      args: SelectSubset<T, startup_likesUpsertArgs>
    ): CheckSelect<T, Prisma__startup_likesClient<startup_likes>, Prisma__startup_likesClient<startup_likesGetPayload<T>>>

    /**
     * Count the number of Startup_likes.
     * @param {startup_likesCountArgs} args - Arguments to filter Startup_likes to count.
     * @example
     * // Count the number of Startup_likes
     * const count = await prisma.startup_likes.count({
     *   where: {
     *     // ... the filter for the Startup_likes we want to count
     *   }
     * })
    **/
    count<T extends startup_likesCountArgs>(
      args?: Subset<T, startup_likesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Startup_likesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Startup_likes.
     * @param {Startup_likesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Startup_likesAggregateArgs>(args: Subset<T, Startup_likesAggregateArgs>): Promise<GetStartup_likesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for startup_likes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__startup_likesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * startup_likes findUnique
   */
  export type startup_likesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the startup_likes
    **/
    select?: startup_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_likesInclude | null
    /**
     * Throw an Error if a startup_likes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which startup_likes to fetch.
    **/
    where: startup_likesWhereUniqueInput
  }


  /**
   * startup_likes findFirst
   */
  export type startup_likesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the startup_likes
    **/
    select?: startup_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_likesInclude | null
    /**
     * Throw an Error if a startup_likes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which startup_likes to fetch.
    **/
    where?: startup_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startup_likes to fetch.
    **/
    orderBy?: Enumerable<startup_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for startup_likes.
    **/
    cursor?: startup_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startup_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startup_likes.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of startup_likes.
    **/
    distinct?: Enumerable<Startup_likesScalarFieldEnum>
  }


  /**
   * startup_likes findMany
   */
  export type startup_likesFindManyArgs = {
    /**
     * Select specific fields to fetch from the startup_likes
    **/
    select?: startup_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_likesInclude | null
    /**
     * Filter, which startup_likes to fetch.
    **/
    where?: startup_likesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of startup_likes to fetch.
    **/
    orderBy?: Enumerable<startup_likesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing startup_likes.
    **/
    cursor?: startup_likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` startup_likes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` startup_likes.
    **/
    skip?: number
    distinct?: Enumerable<Startup_likesScalarFieldEnum>
  }


  /**
   * startup_likes create
   */
  export type startup_likesCreateArgs = {
    /**
     * Select specific fields to fetch from the startup_likes
    **/
    select?: startup_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_likesInclude | null
    /**
     * The data needed to create a startup_likes.
    **/
    data: XOR<startup_likesUncheckedCreateInput, startup_likesCreateInput>
  }


  /**
   * startup_likes update
   */
  export type startup_likesUpdateArgs = {
    /**
     * Select specific fields to fetch from the startup_likes
    **/
    select?: startup_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_likesInclude | null
    /**
     * The data needed to update a startup_likes.
    **/
    data: XOR<startup_likesUncheckedUpdateInput, startup_likesUpdateInput>
    /**
     * Choose, which startup_likes to update.
    **/
    where: startup_likesWhereUniqueInput
  }


  /**
   * startup_likes updateMany
   */
  export type startup_likesUpdateManyArgs = {
    data: XOR<startup_likesUncheckedUpdateManyInput, startup_likesUpdateManyMutationInput>
    where?: startup_likesWhereInput
  }


  /**
   * startup_likes upsert
   */
  export type startup_likesUpsertArgs = {
    /**
     * Select specific fields to fetch from the startup_likes
    **/
    select?: startup_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_likesInclude | null
    /**
     * The filter to search for the startup_likes to update in case it exists.
    **/
    where: startup_likesWhereUniqueInput
    /**
     * In case the startup_likes found by the `where` argument doesn't exist, create a new startup_likes with this data.
    **/
    create: XOR<startup_likesUncheckedCreateInput, startup_likesCreateInput>
    /**
     * In case the startup_likes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<startup_likesUncheckedUpdateInput, startup_likesUpdateInput>
  }


  /**
   * startup_likes delete
   */
  export type startup_likesDeleteArgs = {
    /**
     * Select specific fields to fetch from the startup_likes
    **/
    select?: startup_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_likesInclude | null
    /**
     * Filter which startup_likes to delete.
    **/
    where: startup_likesWhereUniqueInput
  }


  /**
   * startup_likes deleteMany
   */
  export type startup_likesDeleteManyArgs = {
    where?: startup_likesWhereInput
  }


  /**
   * startup_likes without action
   */
  export type startup_likesArgs = {
    /**
     * Select specific fields to fetch from the startup_likes
    **/
    select?: startup_likesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: startup_likesInclude | null
  }



  /**
   * Model technologies
   */


  export type AggregateTechnologies = {
    count: TechnologiesCountAggregateOutputType | null
    avg: TechnologiesAvgAggregateOutputType | null
    sum: TechnologiesSumAggregateOutputType | null
    min: TechnologiesMinAggregateOutputType | null
    max: TechnologiesMaxAggregateOutputType | null
  }

  export type TechnologiesAvgAggregateOutputType = {
    id: number
  }

  export type TechnologiesSumAggregateOutputType = {
    id: number
  }

  export type TechnologiesMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type TechnologiesMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type TechnologiesCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type TechnologiesAvgAggregateInputType = {
    id?: true
  }

  export type TechnologiesSumAggregateInputType = {
    id?: true
  }

  export type TechnologiesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TechnologiesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TechnologiesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TechnologiesAggregateArgs = {
    /**
     * Filter which technologies to aggregate.
    **/
    where?: technologiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of technologies to fetch.
    **/
    orderBy?: Enumerable<technologiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: technologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` technologies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` technologies.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned technologies
    **/
    count?: true | TechnologiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TechnologiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TechnologiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TechnologiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TechnologiesMaxAggregateInputType
  }

  export type GetTechnologiesAggregateType<T extends TechnologiesAggregateArgs> = {
    [P in keyof T & keyof AggregateTechnologies]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnologies[P]>
      : GetScalarType<T[P], AggregateTechnologies[P]>
  }



  export type technologiesSelect = {
    id?: boolean
    name?: boolean
    partners?: boolean | partnersFindManyArgs
    startups?: boolean | startupsFindManyArgs
  }

  export type technologiesInclude = {
    partners?: boolean | partnersFindManyArgs
    startups?: boolean | startupsFindManyArgs
  }

  export type technologiesGetPayload<
    S extends boolean | null | undefined | technologiesArgs,
    U = keyof S
      > = S extends true
        ? technologies
    : S extends undefined
    ? never
    : S extends technologiesArgs | technologiesFindManyArgs
    ?'include' extends U
    ? technologies  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'partners'
        ? Array < partnersGetPayload<S['include'][P]>>  :
        P extends 'startups'
        ? Array < startupsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof technologies ?technologies [P]
  : 
          P extends 'partners'
        ? Array < partnersGetPayload<S['select'][P]>>  :
        P extends 'startups'
        ? Array < startupsGetPayload<S['select'][P]>>  : never
  } 
    : technologies
  : technologies


  type technologiesCountArgs = Merge<
    Omit<technologiesFindManyArgs, 'select' | 'include'> & {
      select?: TechnologiesCountAggregateInputType | true
    }
  >

  export interface technologiesDelegate {
    /**
     * Find zero or one Technologies that matches the filter.
     * @param {technologiesFindUniqueArgs} args - Arguments to find a Technologies
     * @example
     * // Get one Technologies
     * const technologies = await prisma.technologies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends technologiesFindUniqueArgs>(
      args: SelectSubset<T, technologiesFindUniqueArgs>
    ): CheckSelect<T, Prisma__technologiesClient<technologies | null>, Prisma__technologiesClient<technologiesGetPayload<T> | null>>

    /**
     * Find the first Technologies that matches the filter.
     * @param {technologiesFindFirstArgs} args - Arguments to find a Technologies
     * @example
     * // Get one Technologies
     * const technologies = await prisma.technologies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends technologiesFindFirstArgs>(
      args?: SelectSubset<T, technologiesFindFirstArgs>
    ): CheckSelect<T, Prisma__technologiesClient<technologies | null>, Prisma__technologiesClient<technologiesGetPayload<T> | null>>

    /**
     * Find zero or more Technologies that matches the filter.
     * @param {technologiesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Technologies
     * const technologies = await prisma.technologies.findMany()
     * 
     * // Get first 10 Technologies
     * const technologies = await prisma.technologies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technologiesWithIdOnly = await prisma.technologies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends technologiesFindManyArgs>(
      args?: SelectSubset<T, technologiesFindManyArgs>
    ): CheckSelect<T, Promise<Array<technologies>>, Promise<Array<technologiesGetPayload<T>>>>

    /**
     * Create a Technologies.
     * @param {technologiesCreateArgs} args - Arguments to create a Technologies.
     * @example
     * // Create one Technologies
     * const Technologies = await prisma.technologies.create({
     *   data: {
     *     // ... data to create a Technologies
     *   }
     * })
     * 
    **/
    create<T extends technologiesCreateArgs>(
      args: SelectSubset<T, technologiesCreateArgs>
    ): CheckSelect<T, Prisma__technologiesClient<technologies>, Prisma__technologiesClient<technologiesGetPayload<T>>>

    /**
     * Delete a Technologies.
     * @param {technologiesDeleteArgs} args - Arguments to delete one Technologies.
     * @example
     * // Delete one Technologies
     * const Technologies = await prisma.technologies.delete({
     *   where: {
     *     // ... filter to delete one Technologies
     *   }
     * })
     * 
    **/
    delete<T extends technologiesDeleteArgs>(
      args: SelectSubset<T, technologiesDeleteArgs>
    ): CheckSelect<T, Prisma__technologiesClient<technologies>, Prisma__technologiesClient<technologiesGetPayload<T>>>

    /**
     * Update one Technologies.
     * @param {technologiesUpdateArgs} args - Arguments to update one Technologies.
     * @example
     * // Update one Technologies
     * const technologies = await prisma.technologies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends technologiesUpdateArgs>(
      args: SelectSubset<T, technologiesUpdateArgs>
    ): CheckSelect<T, Prisma__technologiesClient<technologies>, Prisma__technologiesClient<technologiesGetPayload<T>>>

    /**
     * Delete zero or more Technologies.
     * @param {technologiesDeleteManyArgs} args - Arguments to filter Technologies to delete.
     * @example
     * // Delete a few Technologies
     * const { count } = await prisma.technologies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends technologiesDeleteManyArgs>(
      args?: SelectSubset<T, technologiesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Technologies.
     * @param {technologiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Technologies
     * const technologies = await prisma.technologies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends technologiesUpdateManyArgs>(
      args: SelectSubset<T, technologiesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Technologies.
     * @param {technologiesUpsertArgs} args - Arguments to update or create a Technologies.
     * @example
     * // Update or create a Technologies
     * const technologies = await prisma.technologies.upsert({
     *   create: {
     *     // ... data to create a Technologies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Technologies we want to update
     *   }
     * })
    **/
    upsert<T extends technologiesUpsertArgs>(
      args: SelectSubset<T, technologiesUpsertArgs>
    ): CheckSelect<T, Prisma__technologiesClient<technologies>, Prisma__technologiesClient<technologiesGetPayload<T>>>

    /**
     * Count the number of Technologies.
     * @param {technologiesCountArgs} args - Arguments to filter Technologies to count.
     * @example
     * // Count the number of Technologies
     * const count = await prisma.technologies.count({
     *   where: {
     *     // ... the filter for the Technologies we want to count
     *   }
     * })
    **/
    count<T extends technologiesCountArgs>(
      args?: Subset<T, technologiesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnologiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Technologies.
     * @param {TechnologiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnologiesAggregateArgs>(args: Subset<T, TechnologiesAggregateArgs>): Promise<GetTechnologiesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for technologies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__technologiesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    partners<T extends partnersFindManyArgs = {}>(args?: Subset<T, partnersFindManyArgs>): CheckSelect<T, Promise<Array<partners>>, Promise<Array<partnersGetPayload<T>>>>;

    startups<T extends startupsFindManyArgs = {}>(args?: Subset<T, startupsFindManyArgs>): CheckSelect<T, Promise<Array<startups>>, Promise<Array<startupsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * technologies findUnique
   */
  export type technologiesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the technologies
    **/
    select?: technologiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: technologiesInclude | null
    /**
     * Throw an Error if a technologies can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which technologies to fetch.
    **/
    where: technologiesWhereUniqueInput
  }


  /**
   * technologies findFirst
   */
  export type technologiesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the technologies
    **/
    select?: technologiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: technologiesInclude | null
    /**
     * Throw an Error if a technologies can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which technologies to fetch.
    **/
    where?: technologiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of technologies to fetch.
    **/
    orderBy?: Enumerable<technologiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for technologies.
    **/
    cursor?: technologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` technologies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` technologies.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of technologies.
    **/
    distinct?: Enumerable<TechnologiesScalarFieldEnum>
  }


  /**
   * technologies findMany
   */
  export type technologiesFindManyArgs = {
    /**
     * Select specific fields to fetch from the technologies
    **/
    select?: technologiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: technologiesInclude | null
    /**
     * Filter, which technologies to fetch.
    **/
    where?: technologiesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of technologies to fetch.
    **/
    orderBy?: Enumerable<technologiesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing technologies.
    **/
    cursor?: technologiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` technologies from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` technologies.
    **/
    skip?: number
    distinct?: Enumerable<TechnologiesScalarFieldEnum>
  }


  /**
   * technologies create
   */
  export type technologiesCreateArgs = {
    /**
     * Select specific fields to fetch from the technologies
    **/
    select?: technologiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: technologiesInclude | null
    /**
     * The data needed to create a technologies.
    **/
    data: XOR<technologiesUncheckedCreateInput, technologiesCreateInput>
  }


  /**
   * technologies update
   */
  export type technologiesUpdateArgs = {
    /**
     * Select specific fields to fetch from the technologies
    **/
    select?: technologiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: technologiesInclude | null
    /**
     * The data needed to update a technologies.
    **/
    data: XOR<technologiesUncheckedUpdateInput, technologiesUpdateInput>
    /**
     * Choose, which technologies to update.
    **/
    where: technologiesWhereUniqueInput
  }


  /**
   * technologies updateMany
   */
  export type technologiesUpdateManyArgs = {
    data: XOR<technologiesUncheckedUpdateManyInput, technologiesUpdateManyMutationInput>
    where?: technologiesWhereInput
  }


  /**
   * technologies upsert
   */
  export type technologiesUpsertArgs = {
    /**
     * Select specific fields to fetch from the technologies
    **/
    select?: technologiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: technologiesInclude | null
    /**
     * The filter to search for the technologies to update in case it exists.
    **/
    where: technologiesWhereUniqueInput
    /**
     * In case the technologies found by the `where` argument doesn't exist, create a new technologies with this data.
    **/
    create: XOR<technologiesUncheckedCreateInput, technologiesCreateInput>
    /**
     * In case the technologies was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<technologiesUncheckedUpdateInput, technologiesUpdateInput>
  }


  /**
   * technologies delete
   */
  export type technologiesDeleteArgs = {
    /**
     * Select specific fields to fetch from the technologies
    **/
    select?: technologiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: technologiesInclude | null
    /**
     * Filter which technologies to delete.
    **/
    where: technologiesWhereUniqueInput
  }


  /**
   * technologies deleteMany
   */
  export type technologiesDeleteManyArgs = {
    where?: technologiesWhereInput
  }


  /**
   * technologies without action
   */
  export type technologiesArgs = {
    /**
     * Select specific fields to fetch from the technologies
    **/
    select?: technologiesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: technologiesInclude | null
  }



  /**
   * Model terms
   */


  export type AggregateTerms = {
    count: TermsCountAggregateOutputType | null
    avg: TermsAvgAggregateOutputType | null
    sum: TermsSumAggregateOutputType | null
    min: TermsMinAggregateOutputType | null
    max: TermsMaxAggregateOutputType | null
  }

  export type TermsAvgAggregateOutputType = {
    id: number
  }

  export type TermsSumAggregateOutputType = {
    id: number
  }

  export type TermsMinAggregateOutputType = {
    id: number
    name: string | null
    content: string | null
    required: boolean | null
  }

  export type TermsMaxAggregateOutputType = {
    id: number
    name: string | null
    content: string | null
    required: boolean | null
  }

  export type TermsCountAggregateOutputType = {
    id: number
    name: number | null
    content: number | null
    required: number | null
    _all: number
  }


  export type TermsAvgAggregateInputType = {
    id?: true
  }

  export type TermsSumAggregateInputType = {
    id?: true
  }

  export type TermsMinAggregateInputType = {
    id?: true
    name?: true
    content?: true
    required?: true
  }

  export type TermsMaxAggregateInputType = {
    id?: true
    name?: true
    content?: true
    required?: true
  }

  export type TermsCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    required?: true
    _all?: true
  }

  export type TermsAggregateArgs = {
    /**
     * Filter which terms to aggregate.
    **/
    where?: termsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of terms to fetch.
    **/
    orderBy?: Enumerable<termsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terms from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terms.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned terms
    **/
    count?: true | TermsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: TermsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: TermsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TermsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TermsMaxAggregateInputType
  }

  export type GetTermsAggregateType<T extends TermsAggregateArgs> = {
    [P in keyof T & keyof AggregateTerms]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerms[P]>
      : GetScalarType<T[P], AggregateTerms[P]>
  }



  export type termsSelect = {
    id?: boolean
    name?: boolean
    content?: boolean
    required?: boolean
    user_agreements?: boolean | user_agreementsFindManyArgs
  }

  export type termsInclude = {
    user_agreements?: boolean | user_agreementsFindManyArgs
  }

  export type termsGetPayload<
    S extends boolean | null | undefined | termsArgs,
    U = keyof S
      > = S extends true
        ? terms
    : S extends undefined
    ? never
    : S extends termsArgs | termsFindManyArgs
    ?'include' extends U
    ? terms  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user_agreements'
        ? Array < user_agreementsGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof terms ?terms [P]
  : 
          P extends 'user_agreements'
        ? Array < user_agreementsGetPayload<S['select'][P]>>  : never
  } 
    : terms
  : terms


  type termsCountArgs = Merge<
    Omit<termsFindManyArgs, 'select' | 'include'> & {
      select?: TermsCountAggregateInputType | true
    }
  >

  export interface termsDelegate {
    /**
     * Find zero or one Terms that matches the filter.
     * @param {termsFindUniqueArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends termsFindUniqueArgs>(
      args: SelectSubset<T, termsFindUniqueArgs>
    ): CheckSelect<T, Prisma__termsClient<terms | null>, Prisma__termsClient<termsGetPayload<T> | null>>

    /**
     * Find the first Terms that matches the filter.
     * @param {termsFindFirstArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends termsFindFirstArgs>(
      args?: SelectSubset<T, termsFindFirstArgs>
    ): CheckSelect<T, Prisma__termsClient<terms | null>, Prisma__termsClient<termsGetPayload<T> | null>>

    /**
     * Find zero or more Terms that matches the filter.
     * @param {termsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms
     * const terms = await prisma.terms.findMany()
     * 
     * // Get first 10 Terms
     * const terms = await prisma.terms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termsWithIdOnly = await prisma.terms.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends termsFindManyArgs>(
      args?: SelectSubset<T, termsFindManyArgs>
    ): CheckSelect<T, Promise<Array<terms>>, Promise<Array<termsGetPayload<T>>>>

    /**
     * Create a Terms.
     * @param {termsCreateArgs} args - Arguments to create a Terms.
     * @example
     * // Create one Terms
     * const Terms = await prisma.terms.create({
     *   data: {
     *     // ... data to create a Terms
     *   }
     * })
     * 
    **/
    create<T extends termsCreateArgs>(
      args: SelectSubset<T, termsCreateArgs>
    ): CheckSelect<T, Prisma__termsClient<terms>, Prisma__termsClient<termsGetPayload<T>>>

    /**
     * Delete a Terms.
     * @param {termsDeleteArgs} args - Arguments to delete one Terms.
     * @example
     * // Delete one Terms
     * const Terms = await prisma.terms.delete({
     *   where: {
     *     // ... filter to delete one Terms
     *   }
     * })
     * 
    **/
    delete<T extends termsDeleteArgs>(
      args: SelectSubset<T, termsDeleteArgs>
    ): CheckSelect<T, Prisma__termsClient<terms>, Prisma__termsClient<termsGetPayload<T>>>

    /**
     * Update one Terms.
     * @param {termsUpdateArgs} args - Arguments to update one Terms.
     * @example
     * // Update one Terms
     * const terms = await prisma.terms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends termsUpdateArgs>(
      args: SelectSubset<T, termsUpdateArgs>
    ): CheckSelect<T, Prisma__termsClient<terms>, Prisma__termsClient<termsGetPayload<T>>>

    /**
     * Delete zero or more Terms.
     * @param {termsDeleteManyArgs} args - Arguments to filter Terms to delete.
     * @example
     * // Delete a few Terms
     * const { count } = await prisma.terms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends termsDeleteManyArgs>(
      args?: SelectSubset<T, termsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Terms.
     * @param {termsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms
     * const terms = await prisma.terms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends termsUpdateManyArgs>(
      args: SelectSubset<T, termsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Terms.
     * @param {termsUpsertArgs} args - Arguments to update or create a Terms.
     * @example
     * // Update or create a Terms
     * const terms = await prisma.terms.upsert({
     *   create: {
     *     // ... data to create a Terms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terms we want to update
     *   }
     * })
    **/
    upsert<T extends termsUpsertArgs>(
      args: SelectSubset<T, termsUpsertArgs>
    ): CheckSelect<T, Prisma__termsClient<terms>, Prisma__termsClient<termsGetPayload<T>>>

    /**
     * Count the number of Terms.
     * @param {termsCountArgs} args - Arguments to filter Terms to count.
     * @example
     * // Count the number of Terms
     * const count = await prisma.terms.count({
     *   where: {
     *     // ... the filter for the Terms we want to count
     *   }
     * })
    **/
    count<T extends termsCountArgs>(
      args?: Subset<T, termsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Terms.
     * @param {TermsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermsAggregateArgs>(args: Subset<T, TermsAggregateArgs>): Promise<GetTermsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for terms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__termsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user_agreements<T extends user_agreementsFindManyArgs = {}>(args?: Subset<T, user_agreementsFindManyArgs>): CheckSelect<T, Promise<Array<user_agreements>>, Promise<Array<user_agreementsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * terms findUnique
   */
  export type termsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the terms
    **/
    select?: termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: termsInclude | null
    /**
     * Throw an Error if a terms can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which terms to fetch.
    **/
    where: termsWhereUniqueInput
  }


  /**
   * terms findFirst
   */
  export type termsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the terms
    **/
    select?: termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: termsInclude | null
    /**
     * Throw an Error if a terms can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which terms to fetch.
    **/
    where?: termsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of terms to fetch.
    **/
    orderBy?: Enumerable<termsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for terms.
    **/
    cursor?: termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terms from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terms.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of terms.
    **/
    distinct?: Enumerable<TermsScalarFieldEnum>
  }


  /**
   * terms findMany
   */
  export type termsFindManyArgs = {
    /**
     * Select specific fields to fetch from the terms
    **/
    select?: termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: termsInclude | null
    /**
     * Filter, which terms to fetch.
    **/
    where?: termsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of terms to fetch.
    **/
    orderBy?: Enumerable<termsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing terms.
    **/
    cursor?: termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terms from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terms.
    **/
    skip?: number
    distinct?: Enumerable<TermsScalarFieldEnum>
  }


  /**
   * terms create
   */
  export type termsCreateArgs = {
    /**
     * Select specific fields to fetch from the terms
    **/
    select?: termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: termsInclude | null
    /**
     * The data needed to create a terms.
    **/
    data: XOR<termsUncheckedCreateInput, termsCreateInput>
  }


  /**
   * terms update
   */
  export type termsUpdateArgs = {
    /**
     * Select specific fields to fetch from the terms
    **/
    select?: termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: termsInclude | null
    /**
     * The data needed to update a terms.
    **/
    data: XOR<termsUncheckedUpdateInput, termsUpdateInput>
    /**
     * Choose, which terms to update.
    **/
    where: termsWhereUniqueInput
  }


  /**
   * terms updateMany
   */
  export type termsUpdateManyArgs = {
    data: XOR<termsUncheckedUpdateManyInput, termsUpdateManyMutationInput>
    where?: termsWhereInput
  }


  /**
   * terms upsert
   */
  export type termsUpsertArgs = {
    /**
     * Select specific fields to fetch from the terms
    **/
    select?: termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: termsInclude | null
    /**
     * The filter to search for the terms to update in case it exists.
    **/
    where: termsWhereUniqueInput
    /**
     * In case the terms found by the `where` argument doesn't exist, create a new terms with this data.
    **/
    create: XOR<termsUncheckedCreateInput, termsCreateInput>
    /**
     * In case the terms was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<termsUncheckedUpdateInput, termsUpdateInput>
  }


  /**
   * terms delete
   */
  export type termsDeleteArgs = {
    /**
     * Select specific fields to fetch from the terms
    **/
    select?: termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: termsInclude | null
    /**
     * Filter which terms to delete.
    **/
    where: termsWhereUniqueInput
  }


  /**
   * terms deleteMany
   */
  export type termsDeleteManyArgs = {
    where?: termsWhereInput
  }


  /**
   * terms without action
   */
  export type termsArgs = {
    /**
     * Select specific fields to fetch from the terms
    **/
    select?: termsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: termsInclude | null
  }



  /**
   * Model user_agreements
   */


  export type AggregateUser_agreements = {
    count: User_agreementsCountAggregateOutputType | null
    avg: User_agreementsAvgAggregateOutputType | null
    sum: User_agreementsSumAggregateOutputType | null
    min: User_agreementsMinAggregateOutputType | null
    max: User_agreementsMaxAggregateOutputType | null
  }

  export type User_agreementsAvgAggregateOutputType = {
    id: number
    user_id: number
    term_id: number
  }

  export type User_agreementsSumAggregateOutputType = {
    id: number
    user_id: number
    term_id: number
  }

  export type User_agreementsMinAggregateOutputType = {
    id: number
    user_id: number
    term_id: number
  }

  export type User_agreementsMaxAggregateOutputType = {
    id: number
    user_id: number
    term_id: number
  }

  export type User_agreementsCountAggregateOutputType = {
    id: number
    user_id: number
    term_id: number
    _all: number
  }


  export type User_agreementsAvgAggregateInputType = {
    id?: true
    user_id?: true
    term_id?: true
  }

  export type User_agreementsSumAggregateInputType = {
    id?: true
    user_id?: true
    term_id?: true
  }

  export type User_agreementsMinAggregateInputType = {
    id?: true
    user_id?: true
    term_id?: true
  }

  export type User_agreementsMaxAggregateInputType = {
    id?: true
    user_id?: true
    term_id?: true
  }

  export type User_agreementsCountAggregateInputType = {
    id?: true
    user_id?: true
    term_id?: true
    _all?: true
  }

  export type User_agreementsAggregateArgs = {
    /**
     * Filter which user_agreements to aggregate.
    **/
    where?: user_agreementsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of user_agreements to fetch.
    **/
    orderBy?: Enumerable<user_agreementsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: user_agreementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_agreements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_agreements.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_agreements
    **/
    count?: true | User_agreementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: User_agreementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: User_agreementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: User_agreementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: User_agreementsMaxAggregateInputType
  }

  export type GetUser_agreementsAggregateType<T extends User_agreementsAggregateArgs> = {
    [P in keyof T & keyof AggregateUser_agreements]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_agreements[P]>
      : GetScalarType<T[P], AggregateUser_agreements[P]>
  }



  export type user_agreementsSelect = {
    id?: boolean
    user_id?: boolean
    term_id?: boolean
    terms?: boolean | termsArgs
    users?: boolean | usersArgs
  }

  export type user_agreementsInclude = {
    terms?: boolean | termsArgs
    users?: boolean | usersArgs
  }

  export type user_agreementsGetPayload<
    S extends boolean | null | undefined | user_agreementsArgs,
    U = keyof S
      > = S extends true
        ? user_agreements
    : S extends undefined
    ? never
    : S extends user_agreementsArgs | user_agreementsFindManyArgs
    ?'include' extends U
    ? user_agreements  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'terms'
        ? termsGetPayload<S['include'][P]> :
        P extends 'users'
        ? usersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user_agreements ?user_agreements [P]
  : 
          P extends 'terms'
        ? termsGetPayload<S['select'][P]> :
        P extends 'users'
        ? usersGetPayload<S['select'][P]> : never
  } 
    : user_agreements
  : user_agreements


  type user_agreementsCountArgs = Merge<
    Omit<user_agreementsFindManyArgs, 'select' | 'include'> & {
      select?: User_agreementsCountAggregateInputType | true
    }
  >

  export interface user_agreementsDelegate {
    /**
     * Find zero or one User_agreements that matches the filter.
     * @param {user_agreementsFindUniqueArgs} args - Arguments to find a User_agreements
     * @example
     * // Get one User_agreements
     * const user_agreements = await prisma.user_agreements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_agreementsFindUniqueArgs>(
      args: SelectSubset<T, user_agreementsFindUniqueArgs>
    ): CheckSelect<T, Prisma__user_agreementsClient<user_agreements | null>, Prisma__user_agreementsClient<user_agreementsGetPayload<T> | null>>

    /**
     * Find the first User_agreements that matches the filter.
     * @param {user_agreementsFindFirstArgs} args - Arguments to find a User_agreements
     * @example
     * // Get one User_agreements
     * const user_agreements = await prisma.user_agreements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_agreementsFindFirstArgs>(
      args?: SelectSubset<T, user_agreementsFindFirstArgs>
    ): CheckSelect<T, Prisma__user_agreementsClient<user_agreements | null>, Prisma__user_agreementsClient<user_agreementsGetPayload<T> | null>>

    /**
     * Find zero or more User_agreements that matches the filter.
     * @param {user_agreementsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_agreements
     * const user_agreements = await prisma.user_agreements.findMany()
     * 
     * // Get first 10 User_agreements
     * const user_agreements = await prisma.user_agreements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_agreementsWithIdOnly = await prisma.user_agreements.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_agreementsFindManyArgs>(
      args?: SelectSubset<T, user_agreementsFindManyArgs>
    ): CheckSelect<T, Promise<Array<user_agreements>>, Promise<Array<user_agreementsGetPayload<T>>>>

    /**
     * Create a User_agreements.
     * @param {user_agreementsCreateArgs} args - Arguments to create a User_agreements.
     * @example
     * // Create one User_agreements
     * const User_agreements = await prisma.user_agreements.create({
     *   data: {
     *     // ... data to create a User_agreements
     *   }
     * })
     * 
    **/
    create<T extends user_agreementsCreateArgs>(
      args: SelectSubset<T, user_agreementsCreateArgs>
    ): CheckSelect<T, Prisma__user_agreementsClient<user_agreements>, Prisma__user_agreementsClient<user_agreementsGetPayload<T>>>

    /**
     * Delete a User_agreements.
     * @param {user_agreementsDeleteArgs} args - Arguments to delete one User_agreements.
     * @example
     * // Delete one User_agreements
     * const User_agreements = await prisma.user_agreements.delete({
     *   where: {
     *     // ... filter to delete one User_agreements
     *   }
     * })
     * 
    **/
    delete<T extends user_agreementsDeleteArgs>(
      args: SelectSubset<T, user_agreementsDeleteArgs>
    ): CheckSelect<T, Prisma__user_agreementsClient<user_agreements>, Prisma__user_agreementsClient<user_agreementsGetPayload<T>>>

    /**
     * Update one User_agreements.
     * @param {user_agreementsUpdateArgs} args - Arguments to update one User_agreements.
     * @example
     * // Update one User_agreements
     * const user_agreements = await prisma.user_agreements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_agreementsUpdateArgs>(
      args: SelectSubset<T, user_agreementsUpdateArgs>
    ): CheckSelect<T, Prisma__user_agreementsClient<user_agreements>, Prisma__user_agreementsClient<user_agreementsGetPayload<T>>>

    /**
     * Delete zero or more User_agreements.
     * @param {user_agreementsDeleteManyArgs} args - Arguments to filter User_agreements to delete.
     * @example
     * // Delete a few User_agreements
     * const { count } = await prisma.user_agreements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_agreementsDeleteManyArgs>(
      args?: SelectSubset<T, user_agreementsDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more User_agreements.
     * @param {user_agreementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_agreements
     * const user_agreements = await prisma.user_agreements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_agreementsUpdateManyArgs>(
      args: SelectSubset<T, user_agreementsUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one User_agreements.
     * @param {user_agreementsUpsertArgs} args - Arguments to update or create a User_agreements.
     * @example
     * // Update or create a User_agreements
     * const user_agreements = await prisma.user_agreements.upsert({
     *   create: {
     *     // ... data to create a User_agreements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_agreements we want to update
     *   }
     * })
    **/
    upsert<T extends user_agreementsUpsertArgs>(
      args: SelectSubset<T, user_agreementsUpsertArgs>
    ): CheckSelect<T, Prisma__user_agreementsClient<user_agreements>, Prisma__user_agreementsClient<user_agreementsGetPayload<T>>>

    /**
     * Count the number of User_agreements.
     * @param {user_agreementsCountArgs} args - Arguments to filter User_agreements to count.
     * @example
     * // Count the number of User_agreements
     * const count = await prisma.user_agreements.count({
     *   where: {
     *     // ... the filter for the User_agreements we want to count
     *   }
     * })
    **/
    count<T extends user_agreementsCountArgs>(
      args?: Subset<T, user_agreementsCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_agreementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_agreements.
     * @param {User_agreementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_agreementsAggregateArgs>(args: Subset<T, User_agreementsAggregateArgs>): Promise<GetUser_agreementsAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for user_agreements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_agreementsClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    terms<T extends termsArgs = {}>(args?: Subset<T, termsArgs>): CheckSelect<T, Prisma__termsClient<terms | null>, Prisma__termsClient<termsGetPayload<T> | null>>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_agreements findUnique
   */
  export type user_agreementsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the user_agreements
    **/
    select?: user_agreementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_agreementsInclude | null
    /**
     * Throw an Error if a user_agreements can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user_agreements to fetch.
    **/
    where: user_agreementsWhereUniqueInput
  }


  /**
   * user_agreements findFirst
   */
  export type user_agreementsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the user_agreements
    **/
    select?: user_agreementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_agreementsInclude | null
    /**
     * Throw an Error if a user_agreements can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user_agreements to fetch.
    **/
    where?: user_agreementsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of user_agreements to fetch.
    **/
    orderBy?: Enumerable<user_agreementsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_agreements.
    **/
    cursor?: user_agreementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_agreements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_agreements.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of user_agreements.
    **/
    distinct?: Enumerable<User_agreementsScalarFieldEnum>
  }


  /**
   * user_agreements findMany
   */
  export type user_agreementsFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_agreements
    **/
    select?: user_agreementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_agreementsInclude | null
    /**
     * Filter, which user_agreements to fetch.
    **/
    where?: user_agreementsWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of user_agreements to fetch.
    **/
    orderBy?: Enumerable<user_agreementsOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_agreements.
    **/
    cursor?: user_agreementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_agreements from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_agreements.
    **/
    skip?: number
    distinct?: Enumerable<User_agreementsScalarFieldEnum>
  }


  /**
   * user_agreements create
   */
  export type user_agreementsCreateArgs = {
    /**
     * Select specific fields to fetch from the user_agreements
    **/
    select?: user_agreementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_agreementsInclude | null
    /**
     * The data needed to create a user_agreements.
    **/
    data: XOR<user_agreementsUncheckedCreateInput, user_agreementsCreateInput>
  }


  /**
   * user_agreements update
   */
  export type user_agreementsUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_agreements
    **/
    select?: user_agreementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_agreementsInclude | null
    /**
     * The data needed to update a user_agreements.
    **/
    data: XOR<user_agreementsUncheckedUpdateInput, user_agreementsUpdateInput>
    /**
     * Choose, which user_agreements to update.
    **/
    where: user_agreementsWhereUniqueInput
  }


  /**
   * user_agreements updateMany
   */
  export type user_agreementsUpdateManyArgs = {
    data: XOR<user_agreementsUncheckedUpdateManyInput, user_agreementsUpdateManyMutationInput>
    where?: user_agreementsWhereInput
  }


  /**
   * user_agreements upsert
   */
  export type user_agreementsUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_agreements
    **/
    select?: user_agreementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_agreementsInclude | null
    /**
     * The filter to search for the user_agreements to update in case it exists.
    **/
    where: user_agreementsWhereUniqueInput
    /**
     * In case the user_agreements found by the `where` argument doesn't exist, create a new user_agreements with this data.
    **/
    create: XOR<user_agreementsUncheckedCreateInput, user_agreementsCreateInput>
    /**
     * In case the user_agreements was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<user_agreementsUncheckedUpdateInput, user_agreementsUpdateInput>
  }


  /**
   * user_agreements delete
   */
  export type user_agreementsDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_agreements
    **/
    select?: user_agreementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_agreementsInclude | null
    /**
     * Filter which user_agreements to delete.
    **/
    where: user_agreementsWhereUniqueInput
  }


  /**
   * user_agreements deleteMany
   */
  export type user_agreementsDeleteManyArgs = {
    where?: user_agreementsWhereInput
  }


  /**
   * user_agreements without action
   */
  export type user_agreementsArgs = {
    /**
     * Select specific fields to fetch from the user_agreements
    **/
    select?: user_agreementsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_agreementsInclude | null
  }



  /**
   * Model user_types
   */


  export type AggregateUser_types = {
    count: User_typesCountAggregateOutputType | null
    avg: User_typesAvgAggregateOutputType | null
    sum: User_typesSumAggregateOutputType | null
    min: User_typesMinAggregateOutputType | null
    max: User_typesMaxAggregateOutputType | null
  }

  export type User_typesAvgAggregateOutputType = {
    id: number
  }

  export type User_typesSumAggregateOutputType = {
    id: number
  }

  export type User_typesMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type User_typesMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type User_typesCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type User_typesAvgAggregateInputType = {
    id?: true
  }

  export type User_typesSumAggregateInputType = {
    id?: true
  }

  export type User_typesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type User_typesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type User_typesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type User_typesAggregateArgs = {
    /**
     * Filter which user_types to aggregate.
    **/
    where?: user_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of user_types to fetch.
    **/
    orderBy?: Enumerable<user_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: user_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_types
    **/
    count?: true | User_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: User_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: User_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: User_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: User_typesMaxAggregateInputType
  }

  export type GetUser_typesAggregateType<T extends User_typesAggregateArgs> = {
    [P in keyof T & keyof AggregateUser_types]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_types[P]>
      : GetScalarType<T[P], AggregateUser_types[P]>
  }



  export type user_typesSelect = {
    id?: boolean
    name?: boolean
    users?: boolean | usersFindManyArgs
  }

  export type user_typesInclude = {
    users?: boolean | usersFindManyArgs
  }

  export type user_typesGetPayload<
    S extends boolean | null | undefined | user_typesArgs,
    U = keyof S
      > = S extends true
        ? user_types
    : S extends undefined
    ? never
    : S extends user_typesArgs | user_typesFindManyArgs
    ?'include' extends U
    ? user_types  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'users'
        ? Array < usersGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof user_types ?user_types [P]
  : 
          P extends 'users'
        ? Array < usersGetPayload<S['select'][P]>>  : never
  } 
    : user_types
  : user_types


  type user_typesCountArgs = Merge<
    Omit<user_typesFindManyArgs, 'select' | 'include'> & {
      select?: User_typesCountAggregateInputType | true
    }
  >

  export interface user_typesDelegate {
    /**
     * Find zero or one User_types that matches the filter.
     * @param {user_typesFindUniqueArgs} args - Arguments to find a User_types
     * @example
     * // Get one User_types
     * const user_types = await prisma.user_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_typesFindUniqueArgs>(
      args: SelectSubset<T, user_typesFindUniqueArgs>
    ): CheckSelect<T, Prisma__user_typesClient<user_types | null>, Prisma__user_typesClient<user_typesGetPayload<T> | null>>

    /**
     * Find the first User_types that matches the filter.
     * @param {user_typesFindFirstArgs} args - Arguments to find a User_types
     * @example
     * // Get one User_types
     * const user_types = await prisma.user_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_typesFindFirstArgs>(
      args?: SelectSubset<T, user_typesFindFirstArgs>
    ): CheckSelect<T, Prisma__user_typesClient<user_types | null>, Prisma__user_typesClient<user_typesGetPayload<T> | null>>

    /**
     * Find zero or more User_types that matches the filter.
     * @param {user_typesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_types
     * const user_types = await prisma.user_types.findMany()
     * 
     * // Get first 10 User_types
     * const user_types = await prisma.user_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_typesWithIdOnly = await prisma.user_types.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_typesFindManyArgs>(
      args?: SelectSubset<T, user_typesFindManyArgs>
    ): CheckSelect<T, Promise<Array<user_types>>, Promise<Array<user_typesGetPayload<T>>>>

    /**
     * Create a User_types.
     * @param {user_typesCreateArgs} args - Arguments to create a User_types.
     * @example
     * // Create one User_types
     * const User_types = await prisma.user_types.create({
     *   data: {
     *     // ... data to create a User_types
     *   }
     * })
     * 
    **/
    create<T extends user_typesCreateArgs>(
      args: SelectSubset<T, user_typesCreateArgs>
    ): CheckSelect<T, Prisma__user_typesClient<user_types>, Prisma__user_typesClient<user_typesGetPayload<T>>>

    /**
     * Delete a User_types.
     * @param {user_typesDeleteArgs} args - Arguments to delete one User_types.
     * @example
     * // Delete one User_types
     * const User_types = await prisma.user_types.delete({
     *   where: {
     *     // ... filter to delete one User_types
     *   }
     * })
     * 
    **/
    delete<T extends user_typesDeleteArgs>(
      args: SelectSubset<T, user_typesDeleteArgs>
    ): CheckSelect<T, Prisma__user_typesClient<user_types>, Prisma__user_typesClient<user_typesGetPayload<T>>>

    /**
     * Update one User_types.
     * @param {user_typesUpdateArgs} args - Arguments to update one User_types.
     * @example
     * // Update one User_types
     * const user_types = await prisma.user_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_typesUpdateArgs>(
      args: SelectSubset<T, user_typesUpdateArgs>
    ): CheckSelect<T, Prisma__user_typesClient<user_types>, Prisma__user_typesClient<user_typesGetPayload<T>>>

    /**
     * Delete zero or more User_types.
     * @param {user_typesDeleteManyArgs} args - Arguments to filter User_types to delete.
     * @example
     * // Delete a few User_types
     * const { count } = await prisma.user_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_typesDeleteManyArgs>(
      args?: SelectSubset<T, user_typesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more User_types.
     * @param {user_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_types
     * const user_types = await prisma.user_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_typesUpdateManyArgs>(
      args: SelectSubset<T, user_typesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one User_types.
     * @param {user_typesUpsertArgs} args - Arguments to update or create a User_types.
     * @example
     * // Update or create a User_types
     * const user_types = await prisma.user_types.upsert({
     *   create: {
     *     // ... data to create a User_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_types we want to update
     *   }
     * })
    **/
    upsert<T extends user_typesUpsertArgs>(
      args: SelectSubset<T, user_typesUpsertArgs>
    ): CheckSelect<T, Prisma__user_typesClient<user_types>, Prisma__user_typesClient<user_typesGetPayload<T>>>

    /**
     * Count the number of User_types.
     * @param {user_typesCountArgs} args - Arguments to filter User_types to count.
     * @example
     * // Count the number of User_types
     * const count = await prisma.user_types.count({
     *   where: {
     *     // ... the filter for the User_types we want to count
     *   }
     * })
    **/
    count<T extends user_typesCountArgs>(
      args?: Subset<T, user_typesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_types.
     * @param {User_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_typesAggregateArgs>(args: Subset<T, User_typesAggregateArgs>): Promise<GetUser_typesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for user_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_typesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersFindManyArgs = {}>(args?: Subset<T, usersFindManyArgs>): CheckSelect<T, Promise<Array<users>>, Promise<Array<usersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_types findUnique
   */
  export type user_typesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the user_types
    **/
    select?: user_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_typesInclude | null
    /**
     * Throw an Error if a user_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user_types to fetch.
    **/
    where: user_typesWhereUniqueInput
  }


  /**
   * user_types findFirst
   */
  export type user_typesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the user_types
    **/
    select?: user_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_typesInclude | null
    /**
     * Throw an Error if a user_types can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which user_types to fetch.
    **/
    where?: user_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of user_types to fetch.
    **/
    orderBy?: Enumerable<user_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_types.
    **/
    cursor?: user_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of user_types.
    **/
    distinct?: Enumerable<User_typesScalarFieldEnum>
  }


  /**
   * user_types findMany
   */
  export type user_typesFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_types
    **/
    select?: user_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_typesInclude | null
    /**
     * Filter, which user_types to fetch.
    **/
    where?: user_typesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of user_types to fetch.
    **/
    orderBy?: Enumerable<user_typesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_types.
    **/
    cursor?: user_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_types from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_types.
    **/
    skip?: number
    distinct?: Enumerable<User_typesScalarFieldEnum>
  }


  /**
   * user_types create
   */
  export type user_typesCreateArgs = {
    /**
     * Select specific fields to fetch from the user_types
    **/
    select?: user_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_typesInclude | null
    /**
     * The data needed to create a user_types.
    **/
    data: XOR<user_typesUncheckedCreateInput, user_typesCreateInput>
  }


  /**
   * user_types update
   */
  export type user_typesUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_types
    **/
    select?: user_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_typesInclude | null
    /**
     * The data needed to update a user_types.
    **/
    data: XOR<user_typesUncheckedUpdateInput, user_typesUpdateInput>
    /**
     * Choose, which user_types to update.
    **/
    where: user_typesWhereUniqueInput
  }


  /**
   * user_types updateMany
   */
  export type user_typesUpdateManyArgs = {
    data: XOR<user_typesUncheckedUpdateManyInput, user_typesUpdateManyMutationInput>
    where?: user_typesWhereInput
  }


  /**
   * user_types upsert
   */
  export type user_typesUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_types
    **/
    select?: user_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_typesInclude | null
    /**
     * The filter to search for the user_types to update in case it exists.
    **/
    where: user_typesWhereUniqueInput
    /**
     * In case the user_types found by the `where` argument doesn't exist, create a new user_types with this data.
    **/
    create: XOR<user_typesUncheckedCreateInput, user_typesCreateInput>
    /**
     * In case the user_types was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<user_typesUncheckedUpdateInput, user_typesUpdateInput>
  }


  /**
   * user_types delete
   */
  export type user_typesDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_types
    **/
    select?: user_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_typesInclude | null
    /**
     * Filter which user_types to delete.
    **/
    where: user_typesWhereUniqueInput
  }


  /**
   * user_types deleteMany
   */
  export type user_typesDeleteManyArgs = {
    where?: user_typesWhereInput
  }


  /**
   * user_types without action
   */
  export type user_typesArgs = {
    /**
     * Select specific fields to fetch from the user_types
    **/
    select?: user_typesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: user_typesInclude | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    count: UsersCountAggregateOutputType | null
    avg: UsersAvgAggregateOutputType | null
    sum: UsersSumAggregateOutputType | null
    min: UsersMinAggregateOutputType | null
    max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number
    type_id: number | null
    signup_method_id: number
    company_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number
    type_id: number | null
    signup_method_id: number
    company_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number
    sns_id: string | null
    name: string | null
    type_id: number | null
    profile_picture: string | null
    email: string | null
    password: string | null
    signup_method_id: number
    company_id: number | null
    phone_number: string | null
    is_verified: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number
    sns_id: string | null
    name: string | null
    type_id: number | null
    profile_picture: string | null
    email: string | null
    password: string | null
    signup_method_id: number
    company_id: number | null
    phone_number: string | null
    is_verified: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    sns_id: number | null
    name: number | null
    type_id: number | null
    profile_picture: number | null
    email: number | null
    password: number | null
    signup_method_id: number
    company_id: number | null
    phone_number: number | null
    is_verified: number | null
    created_at: number | null
    updated_at: number | null
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    type_id?: true
    signup_method_id?: true
    company_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    type_id?: true
    signup_method_id?: true
    company_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    sns_id?: true
    name?: true
    type_id?: true
    profile_picture?: true
    email?: true
    password?: true
    signup_method_id?: true
    company_id?: true
    phone_number?: true
    is_verified?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    sns_id?: true
    name?: true
    type_id?: true
    profile_picture?: true
    email?: true
    password?: true
    signup_method_id?: true
    company_id?: true
    phone_number?: true
    is_verified?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    sns_id?: true
    name?: true
    type_id?: true
    profile_picture?: true
    email?: true
    password?: true
    signup_method_id?: true
    company_id?: true
    phone_number?: true
    is_verified?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
    **/
    where?: usersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<usersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
    [P in keyof T & keyof AggregateUsers]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }



  export type usersSelect = {
    id?: boolean
    sns_id?: boolean
    name?: boolean
    type_id?: boolean
    profile_picture?: boolean
    email?: boolean
    password?: boolean
    signup_method_id?: boolean
    company_id?: boolean
    phone_number?: boolean
    is_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesArgs
    signup_methods?: boolean | signup_methodsArgs
    user_types?: boolean | user_typesArgs
    questions?: boolean | questionsFindManyArgs
    startup_likes?: boolean | startup_likesFindManyArgs
    user_agreements?: boolean | user_agreementsFindManyArgs
    votes?: boolean | votesFindManyArgs
    partner_likes?: boolean | partner_likesFindManyArgs
    project_likes?: boolean | project_likesFindManyArgs
  }

  export type usersInclude = {
    companies?: boolean | companiesArgs
    signup_methods?: boolean | signup_methodsArgs
    user_types?: boolean | user_typesArgs
    questions?: boolean | questionsFindManyArgs
    startup_likes?: boolean | startup_likesFindManyArgs
    user_agreements?: boolean | user_agreementsFindManyArgs
    votes?: boolean | votesFindManyArgs
    partner_likes?: boolean | partner_likesFindManyArgs
    project_likes?: boolean | project_likesFindManyArgs
  }

  export type usersGetPayload<
    S extends boolean | null | undefined | usersArgs,
    U = keyof S
      > = S extends true
        ? users
    : S extends undefined
    ? never
    : S extends usersArgs | usersFindManyArgs
    ?'include' extends U
    ? users  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'companies'
        ? companiesGetPayload<S['include'][P]> | null :
        P extends 'signup_methods'
        ? signup_methodsGetPayload<S['include'][P]> :
        P extends 'user_types'
        ? user_typesGetPayload<S['include'][P]> | null :
        P extends 'questions'
        ? Array < questionsGetPayload<S['include'][P]>>  :
        P extends 'startup_likes'
        ? Array < startup_likesGetPayload<S['include'][P]>>  :
        P extends 'user_agreements'
        ? Array < user_agreementsGetPayload<S['include'][P]>>  :
        P extends 'votes'
        ? Array < votesGetPayload<S['include'][P]>>  :
        P extends 'partner_likes'
        ? Array < partner_likesGetPayload<S['include'][P]>>  :
        P extends 'project_likes'
        ? Array < project_likesGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof users ?users [P]
  : 
          P extends 'companies'
        ? companiesGetPayload<S['select'][P]> | null :
        P extends 'signup_methods'
        ? signup_methodsGetPayload<S['select'][P]> :
        P extends 'user_types'
        ? user_typesGetPayload<S['select'][P]> | null :
        P extends 'questions'
        ? Array < questionsGetPayload<S['select'][P]>>  :
        P extends 'startup_likes'
        ? Array < startup_likesGetPayload<S['select'][P]>>  :
        P extends 'user_agreements'
        ? Array < user_agreementsGetPayload<S['select'][P]>>  :
        P extends 'votes'
        ? Array < votesGetPayload<S['select'][P]>>  :
        P extends 'partner_likes'
        ? Array < partner_likesGetPayload<S['select'][P]>>  :
        P extends 'project_likes'
        ? Array < project_likesGetPayload<S['select'][P]>>  : never
  } 
    : users
  : users


  type usersCountArgs = Merge<
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface usersDelegate {
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>

    /**
     * Find the first Users that matches the filter.
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): CheckSelect<T, Promise<Array<users>>, Promise<Array<usersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Users.
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Count the number of Users.
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Promise<GetUsersAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companies<T extends companiesArgs = {}>(args?: Subset<T, companiesArgs>): CheckSelect<T, Prisma__companiesClient<companies | null>, Prisma__companiesClient<companiesGetPayload<T> | null>>;

    signup_methods<T extends signup_methodsArgs = {}>(args?: Subset<T, signup_methodsArgs>): CheckSelect<T, Prisma__signup_methodsClient<signup_methods | null>, Prisma__signup_methodsClient<signup_methodsGetPayload<T> | null>>;

    user_types<T extends user_typesArgs = {}>(args?: Subset<T, user_typesArgs>): CheckSelect<T, Prisma__user_typesClient<user_types | null>, Prisma__user_typesClient<user_typesGetPayload<T> | null>>;

    questions<T extends questionsFindManyArgs = {}>(args?: Subset<T, questionsFindManyArgs>): CheckSelect<T, Promise<Array<questions>>, Promise<Array<questionsGetPayload<T>>>>;

    startup_likes<T extends startup_likesFindManyArgs = {}>(args?: Subset<T, startup_likesFindManyArgs>): CheckSelect<T, Promise<Array<startup_likes>>, Promise<Array<startup_likesGetPayload<T>>>>;

    user_agreements<T extends user_agreementsFindManyArgs = {}>(args?: Subset<T, user_agreementsFindManyArgs>): CheckSelect<T, Promise<Array<user_agreements>>, Promise<Array<user_agreementsGetPayload<T>>>>;

    votes<T extends votesFindManyArgs = {}>(args?: Subset<T, votesFindManyArgs>): CheckSelect<T, Promise<Array<votes>>, Promise<Array<votesGetPayload<T>>>>;

    partner_likes<T extends partner_likesFindManyArgs = {}>(args?: Subset<T, partner_likesFindManyArgs>): CheckSelect<T, Promise<Array<partner_likes>>, Promise<Array<partner_likesGetPayload<T>>>>;

    project_likes<T extends project_likesFindManyArgs = {}>(args?: Subset<T, project_likesFindManyArgs>): CheckSelect<T, Promise<Array<project_likes>>, Promise<Array<project_likesGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * users findUnique
   */
  export type usersFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: usersInclude | null
    /**
     * Throw an Error if a users can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which users to fetch.
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users findFirst
   */
  export type usersFindFirstArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: usersInclude | null
    /**
     * Throw an Error if a users can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which users to fetch.
    **/
    where?: usersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<usersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of users.
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
    **/
    where?: usersWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of users to fetch.
    **/
    orderBy?: Enumerable<usersOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: usersInclude | null
    /**
     * The data needed to create a users.
    **/
    data: XOR<usersUncheckedCreateInput, usersCreateInput>
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: usersInclude | null
    /**
     * The data needed to update a users.
    **/
    data: XOR<usersUncheckedUpdateInput, usersUpdateInput>
    /**
     * Choose, which users to update.
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    data: XOR<usersUncheckedUpdateManyInput, usersUpdateManyMutationInput>
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
    **/
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
    **/
    create: XOR<usersUncheckedCreateInput, usersCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<usersUncheckedUpdateInput, usersUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: usersInclude | null
    /**
     * Filter which users to delete.
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    where?: usersWhereInput
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: usersInclude | null
  }



  /**
   * Model votes
   */


  export type AggregateVotes = {
    count: VotesCountAggregateOutputType | null
    avg: VotesAvgAggregateOutputType | null
    sum: VotesSumAggregateOutputType | null
    min: VotesMinAggregateOutputType | null
    max: VotesMaxAggregateOutputType | null
  }

  export type VotesAvgAggregateOutputType = {
    id: number
    user_id: number
    participants_id: number
  }

  export type VotesSumAggregateOutputType = {
    id: number
    user_id: number
    participants_id: number
  }

  export type VotesMinAggregateOutputType = {
    id: number
    user_id: number
    participants_id: number
    created_at: Date | null
  }

  export type VotesMaxAggregateOutputType = {
    id: number
    user_id: number
    participants_id: number
    created_at: Date | null
  }

  export type VotesCountAggregateOutputType = {
    id: number
    user_id: number
    participants_id: number
    created_at: number | null
    _all: number
  }


  export type VotesAvgAggregateInputType = {
    id?: true
    user_id?: true
    participants_id?: true
  }

  export type VotesSumAggregateInputType = {
    id?: true
    user_id?: true
    participants_id?: true
  }

  export type VotesMinAggregateInputType = {
    id?: true
    user_id?: true
    participants_id?: true
    created_at?: true
  }

  export type VotesMaxAggregateInputType = {
    id?: true
    user_id?: true
    participants_id?: true
    created_at?: true
  }

  export type VotesCountAggregateInputType = {
    id?: true
    user_id?: true
    participants_id?: true
    created_at?: true
    _all?: true
  }

  export type VotesAggregateArgs = {
    /**
     * Filter which votes to aggregate.
    **/
    where?: votesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of votes to fetch.
    **/
    orderBy?: Enumerable<votesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned votes
    **/
    count?: true | VotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: VotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: VotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: VotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: VotesMaxAggregateInputType
  }

  export type GetVotesAggregateType<T extends VotesAggregateArgs> = {
    [P in keyof T & keyof AggregateVotes]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVotes[P]>
      : GetScalarType<T[P], AggregateVotes[P]>
  }



  export type votesSelect = {
    id?: boolean
    user_id?: boolean
    participants_id?: boolean
    created_at?: boolean
    participants?: boolean | participantsArgs
    users?: boolean | usersArgs
  }

  export type votesInclude = {
    participants?: boolean | participantsArgs
    users?: boolean | usersArgs
  }

  export type votesGetPayload<
    S extends boolean | null | undefined | votesArgs,
    U = keyof S
      > = S extends true
        ? votes
    : S extends undefined
    ? never
    : S extends votesArgs | votesFindManyArgs
    ?'include' extends U
    ? votes  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'participants'
        ? participantsGetPayload<S['include'][P]> :
        P extends 'users'
        ? usersGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof votes ?votes [P]
  : 
          P extends 'participants'
        ? participantsGetPayload<S['select'][P]> :
        P extends 'users'
        ? usersGetPayload<S['select'][P]> : never
  } 
    : votes
  : votes


  type votesCountArgs = Merge<
    Omit<votesFindManyArgs, 'select' | 'include'> & {
      select?: VotesCountAggregateInputType | true
    }
  >

  export interface votesDelegate {
    /**
     * Find zero or one Votes that matches the filter.
     * @param {votesFindUniqueArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends votesFindUniqueArgs>(
      args: SelectSubset<T, votesFindUniqueArgs>
    ): CheckSelect<T, Prisma__votesClient<votes | null>, Prisma__votesClient<votesGetPayload<T> | null>>

    /**
     * Find the first Votes that matches the filter.
     * @param {votesFindFirstArgs} args - Arguments to find a Votes
     * @example
     * // Get one Votes
     * const votes = await prisma.votes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends votesFindFirstArgs>(
      args?: SelectSubset<T, votesFindFirstArgs>
    ): CheckSelect<T, Prisma__votesClient<votes | null>, Prisma__votesClient<votesGetPayload<T> | null>>

    /**
     * Find zero or more Votes that matches the filter.
     * @param {votesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.votes.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.votes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const votesWithIdOnly = await prisma.votes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends votesFindManyArgs>(
      args?: SelectSubset<T, votesFindManyArgs>
    ): CheckSelect<T, Promise<Array<votes>>, Promise<Array<votesGetPayload<T>>>>

    /**
     * Create a Votes.
     * @param {votesCreateArgs} args - Arguments to create a Votes.
     * @example
     * // Create one Votes
     * const Votes = await prisma.votes.create({
     *   data: {
     *     // ... data to create a Votes
     *   }
     * })
     * 
    **/
    create<T extends votesCreateArgs>(
      args: SelectSubset<T, votesCreateArgs>
    ): CheckSelect<T, Prisma__votesClient<votes>, Prisma__votesClient<votesGetPayload<T>>>

    /**
     * Delete a Votes.
     * @param {votesDeleteArgs} args - Arguments to delete one Votes.
     * @example
     * // Delete one Votes
     * const Votes = await prisma.votes.delete({
     *   where: {
     *     // ... filter to delete one Votes
     *   }
     * })
     * 
    **/
    delete<T extends votesDeleteArgs>(
      args: SelectSubset<T, votesDeleteArgs>
    ): CheckSelect<T, Prisma__votesClient<votes>, Prisma__votesClient<votesGetPayload<T>>>

    /**
     * Update one Votes.
     * @param {votesUpdateArgs} args - Arguments to update one Votes.
     * @example
     * // Update one Votes
     * const votes = await prisma.votes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends votesUpdateArgs>(
      args: SelectSubset<T, votesUpdateArgs>
    ): CheckSelect<T, Prisma__votesClient<votes>, Prisma__votesClient<votesGetPayload<T>>>

    /**
     * Delete zero or more Votes.
     * @param {votesDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.votes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends votesDeleteManyArgs>(
      args?: SelectSubset<T, votesDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Votes.
     * @param {votesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const votes = await prisma.votes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends votesUpdateManyArgs>(
      args: SelectSubset<T, votesUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Votes.
     * @param {votesUpsertArgs} args - Arguments to update or create a Votes.
     * @example
     * // Update or create a Votes
     * const votes = await prisma.votes.upsert({
     *   create: {
     *     // ... data to create a Votes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Votes we want to update
     *   }
     * })
    **/
    upsert<T extends votesUpsertArgs>(
      args: SelectSubset<T, votesUpsertArgs>
    ): CheckSelect<T, Prisma__votesClient<votes>, Prisma__votesClient<votesGetPayload<T>>>

    /**
     * Count the number of Votes.
     * @param {votesCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.votes.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends votesCountArgs>(
      args?: Subset<T, votesCountArgs>,
    ): Promise<
      T extends Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Votes.
     * @param {VotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VotesAggregateArgs>(args: Subset<T, VotesAggregateArgs>): Promise<GetVotesAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for votes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__votesClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    participants<T extends participantsArgs = {}>(args?: Subset<T, participantsArgs>): CheckSelect<T, Prisma__participantsClient<participants | null>, Prisma__participantsClient<participantsGetPayload<T> | null>>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null>, Prisma__usersClient<usersGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * votes findUnique
   */
  export type votesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the votes
    **/
    select?: votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: votesInclude | null
    /**
     * Throw an Error if a votes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which votes to fetch.
    **/
    where: votesWhereUniqueInput
  }


  /**
   * votes findFirst
   */
  export type votesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the votes
    **/
    select?: votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: votesInclude | null
    /**
     * Throw an Error if a votes can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which votes to fetch.
    **/
    where?: votesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of votes to fetch.
    **/
    orderBy?: Enumerable<votesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for votes.
    **/
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of votes.
    **/
    distinct?: Enumerable<VotesScalarFieldEnum>
  }


  /**
   * votes findMany
   */
  export type votesFindManyArgs = {
    /**
     * Select specific fields to fetch from the votes
    **/
    select?: votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: votesInclude | null
    /**
     * Filter, which votes to fetch.
    **/
    where?: votesWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of votes to fetch.
    **/
    orderBy?: Enumerable<votesOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing votes.
    **/
    cursor?: votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` votes from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` votes.
    **/
    skip?: number
    distinct?: Enumerable<VotesScalarFieldEnum>
  }


  /**
   * votes create
   */
  export type votesCreateArgs = {
    /**
     * Select specific fields to fetch from the votes
    **/
    select?: votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: votesInclude | null
    /**
     * The data needed to create a votes.
    **/
    data: XOR<votesUncheckedCreateInput, votesCreateInput>
  }


  /**
   * votes update
   */
  export type votesUpdateArgs = {
    /**
     * Select specific fields to fetch from the votes
    **/
    select?: votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: votesInclude | null
    /**
     * The data needed to update a votes.
    **/
    data: XOR<votesUncheckedUpdateInput, votesUpdateInput>
    /**
     * Choose, which votes to update.
    **/
    where: votesWhereUniqueInput
  }


  /**
   * votes updateMany
   */
  export type votesUpdateManyArgs = {
    data: XOR<votesUncheckedUpdateManyInput, votesUpdateManyMutationInput>
    where?: votesWhereInput
  }


  /**
   * votes upsert
   */
  export type votesUpsertArgs = {
    /**
     * Select specific fields to fetch from the votes
    **/
    select?: votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: votesInclude | null
    /**
     * The filter to search for the votes to update in case it exists.
    **/
    where: votesWhereUniqueInput
    /**
     * In case the votes found by the `where` argument doesn't exist, create a new votes with this data.
    **/
    create: XOR<votesUncheckedCreateInput, votesCreateInput>
    /**
     * In case the votes was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<votesUncheckedUpdateInput, votesUpdateInput>
  }


  /**
   * votes delete
   */
  export type votesDeleteArgs = {
    /**
     * Select specific fields to fetch from the votes
    **/
    select?: votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: votesInclude | null
    /**
     * Filter which votes to delete.
    **/
    where: votesWhereUniqueInput
  }


  /**
   * votes deleteMany
   */
  export type votesDeleteManyArgs = {
    where?: votesWhereInput
  }


  /**
   * votes without action
   */
  export type votesArgs = {
    /**
     * Select specific fields to fetch from the votes
    **/
    select?: votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: votesInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AnswersScalarFieldEnum: {
    id: 'id',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at',
    question_id: 'question_id'
  };

  export type AnswersScalarFieldEnum = (typeof AnswersScalarFieldEnum)[keyof typeof AnswersScalarFieldEnum]


  export const ApplicantsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    project_id: 'project_id',
    business_brief: 'business_brief',
    business_model: 'business_model',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ApplicantsScalarFieldEnum = (typeof ApplicantsScalarFieldEnum)[keyof typeof ApplicantsScalarFieldEnum]


  export const Applicant_documentsScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    document_id: 'document_id'
  };

  export type Applicant_documentsScalarFieldEnum = (typeof Applicant_documentsScalarFieldEnum)[keyof typeof Applicant_documentsScalarFieldEnum]


  export const Business_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Business_typesScalarFieldEnum = (typeof Business_typesScalarFieldEnum)[keyof typeof Business_typesScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    type_id: 'type_id',
    name: 'name',
    logo_img: 'logo_img',
    established_date: 'established_date',
    homepage: 'homepage',
    description: 'description',
    team_intro: 'team_intro',
    member_count: 'member_count',
    is_saved: 'is_saved',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const Company_documentsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    doc_url: 'doc_url',
    type_id: 'type_id',
    name: 'name',
    file_type: 'file_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type Company_documentsScalarFieldEnum = (typeof Company_documentsScalarFieldEnum)[keyof typeof Company_documentsScalarFieldEnum]


  export const Company_membersScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    name: 'name',
    img: 'img',
    position: 'position'
  };

  export type Company_membersScalarFieldEnum = (typeof Company_membersScalarFieldEnum)[keyof typeof Company_membersScalarFieldEnum]


  export const Company_newsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    URL: 'URL'
  };

  export type Company_newsScalarFieldEnum = (typeof Company_newsScalarFieldEnum)[keyof typeof Company_newsScalarFieldEnum]


  export const Company_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Company_typesScalarFieldEnum = (typeof Company_typesScalarFieldEnum)[keyof typeof Company_typesScalarFieldEnum]


  export const DemodaysScalarFieldEnum: {
    id: 'id',
    name: 'name',
    company_id: 'company_id',
    streaming_url: 'streaming_url',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type DemodaysScalarFieldEnum = (typeof DemodaysScalarFieldEnum)[keyof typeof DemodaysScalarFieldEnum]


  export const Document_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Document_typesScalarFieldEnum = (typeof Document_typesScalarFieldEnum)[keyof typeof Document_typesScalarFieldEnum]


  export const EligibilitiesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type EligibilitiesScalarFieldEnum = (typeof EligibilitiesScalarFieldEnum)[keyof typeof EligibilitiesScalarFieldEnum]


  export const Eligible_sectorsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Eligible_sectorsScalarFieldEnum = (typeof Eligible_sectorsScalarFieldEnum)[keyof typeof Eligible_sectorsScalarFieldEnum]


  export const Email_authScalarFieldEnum: {
    email: 'email',
    auth_number: 'auth_number'
  };

  export type Email_authScalarFieldEnum = (typeof Email_authScalarFieldEnum)[keyof typeof Email_authScalarFieldEnum]


  export const Invested_fromScalarFieldEnum: {
    id: 'id',
    startup_id: 'startup_id',
    date: 'date',
    invested_institution: 'invested_institution',
    invested_fund_id: 'invested_fund_id',
    corporate_value: 'corporate_value',
    series_id: 'series_id'
  };

  export type Invested_fromScalarFieldEnum = (typeof Invested_fromScalarFieldEnum)[keyof typeof Invested_fromScalarFieldEnum]


  export const Invested_toScalarFieldEnum: {
    id: 'id',
    partner_id: 'partner_id',
    date: 'date',
    invested_startup: 'invested_startup',
    invested_fund_id: 'invested_fund_id',
    corporate_value: 'corporate_value',
    series_id: 'series_id'
  };

  export type Invested_toScalarFieldEnum = (typeof Invested_toScalarFieldEnum)[keyof typeof Invested_toScalarFieldEnum]


  export const Investment_fundsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Investment_fundsScalarFieldEnum = (typeof Investment_fundsScalarFieldEnum)[keyof typeof Investment_fundsScalarFieldEnum]


  export const Investment_portfolioScalarFieldEnum: {
    id: 'id',
    partner_id: 'partner_id',
    img_url: 'img_url'
  };

  export type Investment_portfolioScalarFieldEnum = (typeof Investment_portfolioScalarFieldEnum)[keyof typeof Investment_portfolioScalarFieldEnum]


  export const Investment_seriesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Investment_seriesScalarFieldEnum = (typeof Investment_seriesScalarFieldEnum)[keyof typeof Investment_seriesScalarFieldEnum]


  export const IR_requestsScalarFieldEnum: {
    id: 'id',
    startup_id: 'startup_id',
    partner_id: 'partner_id',
    document_id: 'document_id',
    is_checked: 'is_checked',
    from_partner: 'from_partner',
    created_at: 'created_at',
    updated_at: 'updated_at',
    companiesId: 'companiesId'
  };

  export type IR_requestsScalarFieldEnum = (typeof IR_requestsScalarFieldEnum)[keyof typeof IR_requestsScalarFieldEnum]


  export const ParticipantsScalarFieldEnum: {
    id: 'id',
    demoday_id: 'demoday_id',
    order: 'order',
    company_id: 'company_id'
  };

  export type ParticipantsScalarFieldEnum = (typeof ParticipantsScalarFieldEnum)[keyof typeof ParticipantsScalarFieldEnum]


  export const PartnersScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    interst_technology_id: 'interst_technology_id',
    invested_total_id: 'invested_total_id',
    invested_counts: 'invested_counts',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type PartnersScalarFieldEnum = (typeof PartnersScalarFieldEnum)[keyof typeof PartnersScalarFieldEnum]


  export const Partner_likesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    company_id: 'company_id',
    is_liked: 'is_liked',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Partner_likesScalarFieldEnum = (typeof Partner_likesScalarFieldEnum)[keyof typeof Partner_likesScalarFieldEnum]


  export const Phone_authScalarFieldEnum: {
    id: 'id',
    phone_number: 'phone_number',
    auth_number: 'auth_number'
  };

  export type Phone_authScalarFieldEnum = (typeof Phone_authScalarFieldEnum)[keyof typeof Phone_authScalarFieldEnum]


  export const Project_imagesScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    img_url: 'img_url'
  };

  export type Project_imagesScalarFieldEnum = (typeof Project_imagesScalarFieldEnum)[keyof typeof Project_imagesScalarFieldEnum]


  export const Project_likesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    project_id: 'project_id',
    is_liked: 'is_liked',
    created_at: 'created_at',
    updated_at: 'updated_at',
    companiesId: 'companiesId'
  };

  export type Project_likesScalarFieldEnum = (typeof Project_likesScalarFieldEnum)[keyof typeof Project_likesScalarFieldEnum]


  export const ProjectsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    introduction: 'introduction',
    company_id: 'company_id',
    host: 'host',
    due_date: 'due_date',
    eligible_sector: 'eligible_sector',
    eligibility: 'eligibility',
    outline: 'outline',
    detail: 'detail',
    application_method: 'application_method',
    caution: 'caution',
    contact: 'contact',
    is_opened: 'is_opened',
    hit: 'hit',
    application_url: 'application_url',
    is_saved: 'is_saved',
    request_open: 'request_open',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type ProjectsScalarFieldEnum = (typeof ProjectsScalarFieldEnum)[keyof typeof ProjectsScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    company_id: 'company_id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    demoday_id: 'demoday_id'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const Recent_views_projectScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    company_id: 'company_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Recent_views_projectScalarFieldEnum = (typeof Recent_views_projectScalarFieldEnum)[keyof typeof Recent_views_projectScalarFieldEnum]


  export const Required_documentsScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    document_id: 'document_id'
  };

  export type Required_documentsScalarFieldEnum = (typeof Required_documentsScalarFieldEnum)[keyof typeof Required_documentsScalarFieldEnum]


  export const SectorsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SectorsScalarFieldEnum = (typeof SectorsScalarFieldEnum)[keyof typeof SectorsScalarFieldEnum]


  export const Service_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Service_typesScalarFieldEnum = (typeof Service_typesScalarFieldEnum)[keyof typeof Service_typesScalarFieldEnum]


  export const Signup_methodsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Signup_methodsScalarFieldEnum = (typeof Signup_methodsScalarFieldEnum)[keyof typeof Signup_methodsScalarFieldEnum]


  export const Startup_imagesScalarFieldEnum: {
    id: 'id',
    startup_id: 'startup_id',
    img_url: 'img_url'
  };

  export type Startup_imagesScalarFieldEnum = (typeof Startup_imagesScalarFieldEnum)[keyof typeof Startup_imagesScalarFieldEnum]


  export const StartupsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    rep: 'rep',
    sector_id: 'sector_id',
    core_technology_id: 'core_technology_id',
    item_description: 'item_description',
    contact: 'contact',
    investment_series_id: 'investment_series_id',
    investment_fund_id: 'investment_fund_id',
    address_road: 'address_road',
    address_detail: 'address_detail',
    service_type_id: 'service_type_id',
    business_type_id: 'business_type_id',
    business_license_number: 'business_license_number',
    email: 'email',
    instagram_url: 'instagram_url',
    facebook_url: 'facebook_url',
    thumbnail: 'thumbnail',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type StartupsScalarFieldEnum = (typeof StartupsScalarFieldEnum)[keyof typeof StartupsScalarFieldEnum]


  export const Wish_investment_seriesScalarFieldEnum: {
    id: 'id',
    startup_id: 'startup_id',
    investment_series_id: 'investment_series_id'
  };

  export type Wish_investment_seriesScalarFieldEnum = (typeof Wish_investment_seriesScalarFieldEnum)[keyof typeof Wish_investment_seriesScalarFieldEnum]


  export const Startup_likesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    company_id: 'company_id',
    is_liked: 'is_liked',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Startup_likesScalarFieldEnum = (typeof Startup_likesScalarFieldEnum)[keyof typeof Startup_likesScalarFieldEnum]


  export const TechnologiesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TechnologiesScalarFieldEnum = (typeof TechnologiesScalarFieldEnum)[keyof typeof TechnologiesScalarFieldEnum]


  export const TermsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    required: 'required'
  };

  export type TermsScalarFieldEnum = (typeof TermsScalarFieldEnum)[keyof typeof TermsScalarFieldEnum]


  export const User_agreementsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    term_id: 'term_id'
  };

  export type User_agreementsScalarFieldEnum = (typeof User_agreementsScalarFieldEnum)[keyof typeof User_agreementsScalarFieldEnum]


  export const User_typesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type User_typesScalarFieldEnum = (typeof User_typesScalarFieldEnum)[keyof typeof User_typesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    sns_id: 'sns_id',
    name: 'name',
    type_id: 'type_id',
    profile_picture: 'profile_picture',
    email: 'email',
    password: 'password',
    signup_method_id: 'signup_method_id',
    company_id: 'company_id',
    phone_number: 'phone_number',
    is_verified: 'is_verified',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VotesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    participants_id: 'participants_id',
    created_at: 'created_at'
  };

  export type VotesScalarFieldEnum = (typeof VotesScalarFieldEnum)[keyof typeof VotesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type answersWhereInput = {
    AND?: Enumerable<answersWhereInput>
    OR?: Enumerable<answersWhereInput>
    NOT?: Enumerable<answersWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    question_id?: IntFilter | number
    questions?: XOR<questionsWhereInput, QuestionsRelationFilter>
  }

  export type answersOrderByInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    question_id?: SortOrder
  }

  export type answersWhereUniqueInput = {
    id?: number
  }

  export type applicantsWhereInput = {
    AND?: Enumerable<applicantsWhereInput>
    OR?: Enumerable<applicantsWhereInput>
    NOT?: Enumerable<applicantsWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    project_id?: IntFilter | number
    business_brief?: StringNullableFilter | string | null
    business_model?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
    projects?: XOR<projectsWhereInput, ProjectsRelationFilter>
    applicant_documents?: Applicant_documentsListRelationFilter
  }

  export type applicantsOrderByInput = {
    id?: SortOrder
    company_id?: SortOrder
    project_id?: SortOrder
    business_brief?: SortOrder
    business_model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type applicantsWhereUniqueInput = {
    id?: number
  }

  export type applicant_documentsWhereInput = {
    AND?: Enumerable<applicant_documentsWhereInput>
    OR?: Enumerable<applicant_documentsWhereInput>
    NOT?: Enumerable<applicant_documentsWhereInput>
    id?: IntFilter | number
    applicant_id?: IntFilter | number
    document_id?: IntFilter | number
    applicants?: XOR<applicantsWhereInput, ApplicantsRelationFilter>
    company_documents?: XOR<company_documentsWhereInput, Company_documentsRelationFilter>
  }

  export type applicant_documentsOrderByInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    document_id?: SortOrder
  }

  export type applicant_documentsWhereUniqueInput = {
    id?: number
  }

  export type business_typesWhereInput = {
    AND?: Enumerable<business_typesWhereInput>
    OR?: Enumerable<business_typesWhereInput>
    NOT?: Enumerable<business_typesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    startups?: StartupsListRelationFilter
  }

  export type business_typesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type business_typesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type companiesWhereInput = {
    AND?: Enumerable<companiesWhereInput>
    OR?: Enumerable<companiesWhereInput>
    NOT?: Enumerable<companiesWhereInput>
    id?: IntFilter | number
    type_id?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    logo_img?: StringNullableFilter | string | null
    established_date?: DateTimeNullableFilter | Date | string | null
    homepage?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    team_intro?: StringNullableFilter | string | null
    member_count?: IntNullableFilter | number | null
    is_saved?: BoolFilter | boolean
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    company_types?: XOR<company_typesWhereInput, Company_typesRelationFilter> | null
    applicants?: ApplicantsListRelationFilter
    company_documents?: Company_documentsListRelationFilter
    company_members?: Company_membersListRelationFilter
    company_news?: Company_newsListRelationFilter
    demodays?: DemodaysListRelationFilter
    IR_requests?: IR_requestsListRelationFilter
    participants?: ParticipantsListRelationFilter
    partners?: PartnersListRelationFilter
    partner_likes?: Partner_likesListRelationFilter
    project_likes?: Project_likesListRelationFilter
    projects?: ProjectsListRelationFilter
    questions?: QuestionsListRelationFilter
    recent_views_project?: Recent_views_projectListRelationFilter
    startups?: StartupsListRelationFilter
    startup_likes?: Startup_likesListRelationFilter
    users?: UsersListRelationFilter
  }

  export type companiesOrderByInput = {
    id?: SortOrder
    type_id?: SortOrder
    name?: SortOrder
    logo_img?: SortOrder
    established_date?: SortOrder
    homepage?: SortOrder
    description?: SortOrder
    team_intro?: SortOrder
    member_count?: SortOrder
    is_saved?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type companiesWhereUniqueInput = {
    id?: number
  }

  export type company_documentsWhereInput = {
    AND?: Enumerable<company_documentsWhereInput>
    OR?: Enumerable<company_documentsWhereInput>
    NOT?: Enumerable<company_documentsWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    doc_url?: StringFilter | string
    type_id?: IntFilter | number
    name?: StringFilter | string
    file_type?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
    document_types?: XOR<document_typesWhereInput, Document_typesRelationFilter>
    IR_requests?: IR_requestsListRelationFilter
    applicant_documents?: Applicant_documentsListRelationFilter
  }

  export type company_documentsOrderByInput = {
    id?: SortOrder
    company_id?: SortOrder
    doc_url?: SortOrder
    type_id?: SortOrder
    name?: SortOrder
    file_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type company_documentsWhereUniqueInput = {
    id?: number
  }

  export type company_membersWhereInput = {
    AND?: Enumerable<company_membersWhereInput>
    OR?: Enumerable<company_membersWhereInput>
    NOT?: Enumerable<company_membersWhereInput>
    id?: IntFilter | number
    company_id?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    img?: StringNullableFilter | string | null
    position?: StringNullableFilter | string | null
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter> | null
  }

  export type company_membersOrderByInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    img?: SortOrder
    position?: SortOrder
  }

  export type company_membersWhereUniqueInput = {
    id?: number
  }

  export type company_newsWhereInput = {
    AND?: Enumerable<company_newsWhereInput>
    OR?: Enumerable<company_newsWhereInput>
    NOT?: Enumerable<company_newsWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    URL?: StringFilter | string
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
  }

  export type company_newsOrderByInput = {
    id?: SortOrder
    company_id?: SortOrder
    URL?: SortOrder
  }

  export type company_newsWhereUniqueInput = {
    id?: number
  }

  export type company_typesWhereInput = {
    AND?: Enumerable<company_typesWhereInput>
    OR?: Enumerable<company_typesWhereInput>
    NOT?: Enumerable<company_typesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    companies?: CompaniesListRelationFilter
  }

  export type company_typesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type company_typesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type demodaysWhereInput = {
    AND?: Enumerable<demodaysWhereInput>
    OR?: Enumerable<demodaysWhereInput>
    NOT?: Enumerable<demodaysWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    company_id?: IntNullableFilter | number | null
    streaming_url?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter> | null
    participants?: ParticipantsListRelationFilter
    questions?: QuestionsListRelationFilter
  }

  export type demodaysOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    company_id?: SortOrder
    streaming_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type demodaysWhereUniqueInput = {
    id?: number
  }

  export type document_typesWhereInput = {
    AND?: Enumerable<document_typesWhereInput>
    OR?: Enumerable<document_typesWhereInput>
    NOT?: Enumerable<document_typesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    company_documents?: Company_documentsListRelationFilter
    required_documents?: Required_documentsListRelationFilter
  }

  export type document_typesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type document_typesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type eligibilitiesWhereInput = {
    AND?: Enumerable<eligibilitiesWhereInput>
    OR?: Enumerable<eligibilitiesWhereInput>
    NOT?: Enumerable<eligibilitiesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    projects?: ProjectsListRelationFilter
  }

  export type eligibilitiesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type eligibilitiesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type eligible_sectorsWhereInput = {
    AND?: Enumerable<eligible_sectorsWhereInput>
    OR?: Enumerable<eligible_sectorsWhereInput>
    NOT?: Enumerable<eligible_sectorsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    projects?: ProjectsListRelationFilter
  }

  export type eligible_sectorsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type eligible_sectorsWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type email_authWhereInput = {
    AND?: Enumerable<email_authWhereInput>
    OR?: Enumerable<email_authWhereInput>
    NOT?: Enumerable<email_authWhereInput>
    email?: StringFilter | string
    auth_number?: StringFilter | string
  }

  export type email_authOrderByInput = {
    email?: SortOrder
    auth_number?: SortOrder
  }

  export type email_authWhereUniqueInput = {
    email?: string
    auth_number?: string
    email_auth_number?: email_authEmailAuth_numberCompoundUniqueInput
  }

  export type invested_fromWhereInput = {
    AND?: Enumerable<invested_fromWhereInput>
    OR?: Enumerable<invested_fromWhereInput>
    NOT?: Enumerable<invested_fromWhereInput>
    id?: IntFilter | number
    startup_id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    invested_institution?: StringFilter | string
    invested_fund_id?: IntFilter | number
    corporate_value?: IntFilter | number
    series_id?: IntFilter | number
    investment_series?: XOR<investment_seriesWhereInput, Investment_seriesRelationFilter>
    investment_funds?: XOR<investment_fundsWhereInput, Investment_fundsRelationFilter>
    startups?: XOR<startupsWhereInput, StartupsRelationFilter>
  }

  export type invested_fromOrderByInput = {
    id?: SortOrder
    startup_id?: SortOrder
    date?: SortOrder
    invested_institution?: SortOrder
    invested_fund_id?: SortOrder
    corporate_value?: SortOrder
    series_id?: SortOrder
  }

  export type invested_fromWhereUniqueInput = {
    id?: number
  }

  export type invested_toWhereInput = {
    AND?: Enumerable<invested_toWhereInput>
    OR?: Enumerable<invested_toWhereInput>
    NOT?: Enumerable<invested_toWhereInput>
    id?: IntFilter | number
    partner_id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    invested_startup?: StringFilter | string
    invested_fund_id?: IntFilter | number
    corporate_value?: IntFilter | number
    series_id?: IntFilter | number
    investment_series?: XOR<investment_seriesWhereInput, Investment_seriesRelationFilter>
    investment_funds?: XOR<investment_fundsWhereInput, Investment_fundsRelationFilter>
    partners?: XOR<partnersWhereInput, PartnersRelationFilter>
  }

  export type invested_toOrderByInput = {
    id?: SortOrder
    partner_id?: SortOrder
    date?: SortOrder
    invested_startup?: SortOrder
    invested_fund_id?: SortOrder
    corporate_value?: SortOrder
    series_id?: SortOrder
  }

  export type invested_toWhereUniqueInput = {
    id?: number
  }

  export type investment_fundsWhereInput = {
    AND?: Enumerable<investment_fundsWhereInput>
    OR?: Enumerable<investment_fundsWhereInput>
    NOT?: Enumerable<investment_fundsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    partners?: PartnersListRelationFilter
    startups?: StartupsListRelationFilter
    invested_from?: Invested_fromListRelationFilter
    invested_to?: Invested_toListRelationFilter
  }

  export type investment_fundsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type investment_fundsWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type investment_portfolioWhereInput = {
    AND?: Enumerable<investment_portfolioWhereInput>
    OR?: Enumerable<investment_portfolioWhereInput>
    NOT?: Enumerable<investment_portfolioWhereInput>
    id?: IntFilter | number
    partner_id?: IntFilter | number
    img_url?: StringFilter | string
    partners?: XOR<partnersWhereInput, PartnersRelationFilter>
  }

  export type investment_portfolioOrderByInput = {
    id?: SortOrder
    partner_id?: SortOrder
    img_url?: SortOrder
  }

  export type investment_portfolioWhereUniqueInput = {
    id?: number
  }

  export type investment_seriesWhereInput = {
    AND?: Enumerable<investment_seriesWhereInput>
    OR?: Enumerable<investment_seriesWhereInput>
    NOT?: Enumerable<investment_seriesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    invested_from?: Invested_fromListRelationFilter
    invested_to?: Invested_toListRelationFilter
    startups?: StartupsListRelationFilter
    wish_investment_series?: Wish_investment_seriesListRelationFilter
  }

  export type investment_seriesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type investment_seriesWhereUniqueInput = {
    id?: number
  }

  export type IR_requestsWhereInput = {
    AND?: Enumerable<IR_requestsWhereInput>
    OR?: Enumerable<IR_requestsWhereInput>
    NOT?: Enumerable<IR_requestsWhereInput>
    id?: IntFilter | number
    startup_id?: IntFilter | number
    partner_id?: IntFilter | number
    document_id?: IntNullableFilter | number | null
    is_checked?: IntFilter | number
    from_partner?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    company_documents?: XOR<company_documentsWhereInput, Company_documentsRelationFilter> | null
    partners?: XOR<partnersWhereInput, PartnersRelationFilter>
    startups?: XOR<startupsWhereInput, StartupsRelationFilter>
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter> | null
    companiesId?: IntNullableFilter | number | null
  }

  export type IR_requestsOrderByInput = {
    id?: SortOrder
    startup_id?: SortOrder
    partner_id?: SortOrder
    document_id?: SortOrder
    is_checked?: SortOrder
    from_partner?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    companiesId?: SortOrder
  }

  export type IR_requestsWhereUniqueInput = {
    id?: number
  }

  export type participantsWhereInput = {
    AND?: Enumerable<participantsWhereInput>
    OR?: Enumerable<participantsWhereInput>
    NOT?: Enumerable<participantsWhereInput>
    id?: IntFilter | number
    demoday_id?: IntFilter | number
    order?: IntFilter | number
    company_id?: IntFilter | number
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
    demodays?: XOR<demodaysWhereInput, DemodaysRelationFilter>
    votes?: VotesListRelationFilter
  }

  export type participantsOrderByInput = {
    id?: SortOrder
    demoday_id?: SortOrder
    order?: SortOrder
    company_id?: SortOrder
  }

  export type participantsWhereUniqueInput = {
    id?: number
  }

  export type partnersWhereInput = {
    AND?: Enumerable<partnersWhereInput>
    OR?: Enumerable<partnersWhereInput>
    NOT?: Enumerable<partnersWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    interst_technology_id?: IntNullableFilter | number | null
    invested_total_id?: IntNullableFilter | number | null
    invested_counts?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
    technologies?: XOR<technologiesWhereInput, TechnologiesRelationFilter> | null
    investment_funds?: XOR<investment_fundsWhereInput, Investment_fundsRelationFilter> | null
    investment_portfolio?: Investment_portfolioListRelationFilter
    IR_requests?: IR_requestsListRelationFilter
    invested_to?: Invested_toListRelationFilter
  }

  export type partnersOrderByInput = {
    id?: SortOrder
    company_id?: SortOrder
    interst_technology_id?: SortOrder
    invested_total_id?: SortOrder
    invested_counts?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type partnersWhereUniqueInput = {
    id?: number
    company_id?: number
  }

  export type partner_likesWhereInput = {
    AND?: Enumerable<partner_likesWhereInput>
    OR?: Enumerable<partner_likesWhereInput>
    NOT?: Enumerable<partner_likesWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    company_id?: IntFilter | number
    is_liked?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    users?: XOR<usersWhereInput, UsersRelationFilter>
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
  }

  export type partner_likesOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    is_liked?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type partner_likesWhereUniqueInput = {
    id?: number
  }

  export type phone_authWhereInput = {
    AND?: Enumerable<phone_authWhereInput>
    OR?: Enumerable<phone_authWhereInput>
    NOT?: Enumerable<phone_authWhereInput>
    id?: IntFilter | number
    phone_number?: StringFilter | string
    auth_number?: StringFilter | string
  }

  export type phone_authOrderByInput = {
    id?: SortOrder
    phone_number?: SortOrder
    auth_number?: SortOrder
  }

  export type phone_authWhereUniqueInput = {
    id?: number
  }

  export type project_imagesWhereInput = {
    AND?: Enumerable<project_imagesWhereInput>
    OR?: Enumerable<project_imagesWhereInput>
    NOT?: Enumerable<project_imagesWhereInput>
    id?: IntFilter | number
    project_id?: IntFilter | number
    img_url?: StringNullableFilter | string | null
    projects?: XOR<projectsWhereInput, ProjectsRelationFilter>
  }

  export type project_imagesOrderByInput = {
    id?: SortOrder
    project_id?: SortOrder
    img_url?: SortOrder
  }

  export type project_imagesWhereUniqueInput = {
    id?: number
  }

  export type project_likesWhereInput = {
    AND?: Enumerable<project_likesWhereInput>
    OR?: Enumerable<project_likesWhereInput>
    NOT?: Enumerable<project_likesWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    project_id?: IntFilter | number
    is_liked?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    users?: XOR<usersWhereInput, UsersRelationFilter>
    projects?: XOR<projectsWhereInput, ProjectsRelationFilter>
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter> | null
    companiesId?: IntNullableFilter | number | null
  }

  export type project_likesOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    project_id?: SortOrder
    is_liked?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    companiesId?: SortOrder
  }

  export type project_likesWhereUniqueInput = {
    id?: number
  }

  export type projectsWhereInput = {
    AND?: Enumerable<projectsWhereInput>
    OR?: Enumerable<projectsWhereInput>
    NOT?: Enumerable<projectsWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    introduction?: StringNullableFilter | string | null
    company_id?: IntNullableFilter | number | null
    host?: StringNullableFilter | string | null
    due_date?: DateTimeNullableFilter | Date | string | null
    eligible_sector?: IntNullableFilter | number | null
    eligibility?: IntNullableFilter | number | null
    outline?: StringNullableFilter | string | null
    detail?: StringNullableFilter | string | null
    application_method?: StringNullableFilter | string | null
    caution?: StringNullableFilter | string | null
    contact?: StringNullableFilter | string | null
    is_opened?: BoolFilter | boolean
    hit?: IntFilter | number
    application_url?: StringNullableFilter | string | null
    is_saved?: BoolFilter | boolean
    request_open?: BoolFilter | boolean
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    eligible_sectors?: XOR<eligible_sectorsWhereInput, Eligible_sectorsRelationFilter> | null
    eligibilities?: XOR<eligibilitiesWhereInput, EligibilitiesRelationFilter> | null
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter> | null
    applicants?: ApplicantsListRelationFilter
    project_images?: Project_imagesListRelationFilter
    project_likes?: Project_likesListRelationFilter
    recent_views_project?: Recent_views_projectListRelationFilter
    required_documents?: Required_documentsListRelationFilter
  }

  export type projectsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    introduction?: SortOrder
    company_id?: SortOrder
    host?: SortOrder
    due_date?: SortOrder
    eligible_sector?: SortOrder
    eligibility?: SortOrder
    outline?: SortOrder
    detail?: SortOrder
    application_method?: SortOrder
    caution?: SortOrder
    contact?: SortOrder
    is_opened?: SortOrder
    hit?: SortOrder
    application_url?: SortOrder
    is_saved?: SortOrder
    request_open?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type projectsWhereUniqueInput = {
    id?: number
  }

  export type questionsWhereInput = {
    AND?: Enumerable<questionsWhereInput>
    OR?: Enumerable<questionsWhereInput>
    NOT?: Enumerable<questionsWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    company_id?: IntFilter | number
    user_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    demoday_id?: IntFilter | number
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
    demodays?: XOR<demodaysWhereInput, DemodaysRelationFilter>
    users?: XOR<usersWhereInput, UsersRelationFilter>
    answers?: AnswersListRelationFilter
  }

  export type questionsOrderByInput = {
    id?: SortOrder
    content?: SortOrder
    company_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    demoday_id?: SortOrder
  }

  export type questionsWhereUniqueInput = {
    id?: number
  }

  export type recent_views_projectWhereInput = {
    AND?: Enumerable<recent_views_projectWhereInput>
    OR?: Enumerable<recent_views_projectWhereInput>
    NOT?: Enumerable<recent_views_projectWhereInput>
    id?: IntFilter | number
    project_id?: IntFilter | number
    company_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
    projects?: XOR<projectsWhereInput, ProjectsRelationFilter>
  }

  export type recent_views_projectOrderByInput = {
    id?: SortOrder
    project_id?: SortOrder
    company_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type recent_views_projectWhereUniqueInput = {
    id?: number
  }

  export type required_documentsWhereInput = {
    AND?: Enumerable<required_documentsWhereInput>
    OR?: Enumerable<required_documentsWhereInput>
    NOT?: Enumerable<required_documentsWhereInput>
    id?: IntFilter | number
    project_id?: IntFilter | number
    document_id?: IntFilter | number
    document_types?: XOR<document_typesWhereInput, Document_typesRelationFilter>
    projects?: XOR<projectsWhereInput, ProjectsRelationFilter>
  }

  export type required_documentsOrderByInput = {
    id?: SortOrder
    project_id?: SortOrder
    document_id?: SortOrder
  }

  export type required_documentsWhereUniqueInput = {
    id?: number
  }

  export type sectorsWhereInput = {
    AND?: Enumerable<sectorsWhereInput>
    OR?: Enumerable<sectorsWhereInput>
    NOT?: Enumerable<sectorsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    startups?: StartupsListRelationFilter
  }

  export type sectorsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type sectorsWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type service_typesWhereInput = {
    AND?: Enumerable<service_typesWhereInput>
    OR?: Enumerable<service_typesWhereInput>
    NOT?: Enumerable<service_typesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    startups?: StartupsListRelationFilter
  }

  export type service_typesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type service_typesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type signup_methodsWhereInput = {
    AND?: Enumerable<signup_methodsWhereInput>
    OR?: Enumerable<signup_methodsWhereInput>
    NOT?: Enumerable<signup_methodsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    users?: UsersListRelationFilter
  }

  export type signup_methodsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type signup_methodsWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type startup_imagesWhereInput = {
    AND?: Enumerable<startup_imagesWhereInput>
    OR?: Enumerable<startup_imagesWhereInput>
    NOT?: Enumerable<startup_imagesWhereInput>
    id?: IntFilter | number
    startup_id?: IntFilter | number
    img_url?: StringFilter | string
    startups?: XOR<startupsWhereInput, StartupsRelationFilter>
  }

  export type startup_imagesOrderByInput = {
    id?: SortOrder
    startup_id?: SortOrder
    img_url?: SortOrder
  }

  export type startup_imagesWhereUniqueInput = {
    id?: number
  }

  export type startupsWhereInput = {
    AND?: Enumerable<startupsWhereInput>
    OR?: Enumerable<startupsWhereInput>
    NOT?: Enumerable<startupsWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    rep?: StringNullableFilter | string | null
    sector_id?: IntNullableFilter | number | null
    core_technology_id?: IntNullableFilter | number | null
    item_description?: StringNullableFilter | string | null
    contact?: StringNullableFilter | string | null
    investment_series_id?: IntNullableFilter | number | null
    investment_fund_id?: IntNullableFilter | number | null
    address_road?: StringNullableFilter | string | null
    address_detail?: StringNullableFilter | string | null
    service_type_id?: IntNullableFilter | number | null
    business_type_id?: IntNullableFilter | number | null
    business_license_number?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    instagram_url?: StringNullableFilter | string | null
    facebook_url?: StringNullableFilter | string | null
    thumbnail?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
    business_types?: XOR<business_typesWhereInput, Business_typesRelationFilter> | null
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
    technologies?: XOR<technologiesWhereInput, TechnologiesRelationFilter> | null
    sectors?: XOR<sectorsWhereInput, SectorsRelationFilter> | null
    service_types?: XOR<service_typesWhereInput, Service_typesRelationFilter> | null
    investment_series?: XOR<investment_seriesWhereInput, Investment_seriesRelationFilter> | null
    investment_funds?: XOR<investment_fundsWhereInput, Investment_fundsRelationFilter> | null
    invested_from?: Invested_fromListRelationFilter
    startup_images?: Startup_imagesListRelationFilter
    wish_investment_series?: Wish_investment_seriesListRelationFilter
    IR_requests?: IR_requestsListRelationFilter
  }

  export type startupsOrderByInput = {
    id?: SortOrder
    company_id?: SortOrder
    rep?: SortOrder
    sector_id?: SortOrder
    core_technology_id?: SortOrder
    item_description?: SortOrder
    contact?: SortOrder
    investment_series_id?: SortOrder
    investment_fund_id?: SortOrder
    address_road?: SortOrder
    address_detail?: SortOrder
    service_type_id?: SortOrder
    business_type_id?: SortOrder
    business_license_number?: SortOrder
    email?: SortOrder
    instagram_url?: SortOrder
    facebook_url?: SortOrder
    thumbnail?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type startupsWhereUniqueInput = {
    id?: number
    company_id?: number
  }

  export type wish_investment_seriesWhereInput = {
    AND?: Enumerable<wish_investment_seriesWhereInput>
    OR?: Enumerable<wish_investment_seriesWhereInput>
    NOT?: Enumerable<wish_investment_seriesWhereInput>
    id?: IntFilter | number
    startup_id?: IntFilter | number
    investment_series_id?: IntFilter | number
    startups?: XOR<startupsWhereInput, StartupsRelationFilter>
    investment_series?: XOR<investment_seriesWhereInput, Investment_seriesRelationFilter>
  }

  export type wish_investment_seriesOrderByInput = {
    id?: SortOrder
    startup_id?: SortOrder
    investment_series_id?: SortOrder
  }

  export type wish_investment_seriesWhereUniqueInput = {
    id?: number
  }

  export type startup_likesWhereInput = {
    AND?: Enumerable<startup_likesWhereInput>
    OR?: Enumerable<startup_likesWhereInput>
    NOT?: Enumerable<startup_likesWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    company_id?: IntFilter | number
    is_liked?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter>
    users?: XOR<usersWhereInput, UsersRelationFilter>
  }

  export type startup_likesOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_id?: SortOrder
    is_liked?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type startup_likesWhereUniqueInput = {
    id?: number
  }

  export type technologiesWhereInput = {
    AND?: Enumerable<technologiesWhereInput>
    OR?: Enumerable<technologiesWhereInput>
    NOT?: Enumerable<technologiesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    partners?: PartnersListRelationFilter
    startups?: StartupsListRelationFilter
  }

  export type technologiesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type technologiesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type termsWhereInput = {
    AND?: Enumerable<termsWhereInput>
    OR?: Enumerable<termsWhereInput>
    NOT?: Enumerable<termsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    content?: StringFilter | string
    required?: BoolFilter | boolean
    user_agreements?: User_agreementsListRelationFilter
  }

  export type termsOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    required?: SortOrder
  }

  export type termsWhereUniqueInput = {
    id?: number
  }

  export type user_agreementsWhereInput = {
    AND?: Enumerable<user_agreementsWhereInput>
    OR?: Enumerable<user_agreementsWhereInput>
    NOT?: Enumerable<user_agreementsWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    term_id?: IntFilter | number
    terms?: XOR<termsWhereInput, TermsRelationFilter>
    users?: XOR<usersWhereInput, UsersRelationFilter>
  }

  export type user_agreementsOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    term_id?: SortOrder
  }

  export type user_agreementsWhereUniqueInput = {
    id?: number
  }

  export type user_typesWhereInput = {
    AND?: Enumerable<user_typesWhereInput>
    OR?: Enumerable<user_typesWhereInput>
    NOT?: Enumerable<user_typesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    users?: UsersListRelationFilter
  }

  export type user_typesOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type user_typesWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    sns_id?: StringNullableFilter | string | null
    name?: StringFilter | string
    type_id?: IntNullableFilter | number | null
    profile_picture?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringNullableFilter | string | null
    signup_method_id?: IntFilter | number
    company_id?: IntNullableFilter | number | null
    phone_number?: StringNullableFilter | string | null
    is_verified?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    companies?: XOR<companiesWhereInput, CompaniesRelationFilter> | null
    signup_methods?: XOR<signup_methodsWhereInput, Signup_methodsRelationFilter>
    user_types?: XOR<user_typesWhereInput, User_typesRelationFilter> | null
    questions?: QuestionsListRelationFilter
    startup_likes?: Startup_likesListRelationFilter
    user_agreements?: User_agreementsListRelationFilter
    votes?: VotesListRelationFilter
    partner_likes?: Partner_likesListRelationFilter
    project_likes?: Project_likesListRelationFilter
  }

  export type usersOrderByInput = {
    id?: SortOrder
    sns_id?: SortOrder
    name?: SortOrder
    type_id?: SortOrder
    profile_picture?: SortOrder
    email?: SortOrder
    password?: SortOrder
    signup_method_id?: SortOrder
    company_id?: SortOrder
    phone_number?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersWhereUniqueInput = {
    id?: number
    sns_id?: string
    email?: string
  }

  export type votesWhereInput = {
    AND?: Enumerable<votesWhereInput>
    OR?: Enumerable<votesWhereInput>
    NOT?: Enumerable<votesWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    participants_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    participants?: XOR<participantsWhereInput, ParticipantsRelationFilter>
    users?: XOR<usersWhereInput, UsersRelationFilter>
  }

  export type votesOrderByInput = {
    id?: SortOrder
    user_id?: SortOrder
    participants_id?: SortOrder
    created_at?: SortOrder
  }

  export type votesWhereUniqueInput = {
    id?: number
  }

  export type answersCreateInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    questions: questionsCreateOneWithoutAnswersInput
  }

  export type answersUncheckedCreateInput = {
    id?: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    question_id: number
  }

  export type answersUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUpdateOneRequiredWithoutAnswersInput
  }

  export type answersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type answersUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type applicantsCreateInput = {
    business_brief?: string | null
    business_model?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutApplicantsInput
    projects: projectsCreateOneWithoutApplicantsInput
    applicant_documents?: applicant_documentsCreateManyWithoutApplicantsInput
  }

  export type applicantsUncheckedCreateInput = {
    id?: number
    company_id: number
    project_id: number
    business_brief?: string | null
    business_model?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicant_documents?: applicant_documentsUncheckedCreateManyWithoutApplicantsInput
  }

  export type applicantsUpdateInput = {
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutApplicantsInput
    projects?: projectsUpdateOneRequiredWithoutApplicantsInput
    applicant_documents?: applicant_documentsUpdateManyWithoutApplicantsInput
  }

  export type applicantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicant_documents?: applicant_documentsUncheckedUpdateManyWithoutApplicantsInput
  }

  export type applicantsUpdateManyMutationInput = {
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicant_documentsCreateInput = {
    applicants: applicantsCreateOneWithoutApplicant_documentsInput
    company_documents: company_documentsCreateOneWithoutApplicant_documentsInput
  }

  export type applicant_documentsUncheckedCreateInput = {
    id?: number
    applicant_id: number
    document_id: number
  }

  export type applicant_documentsUpdateInput = {
    applicants?: applicantsUpdateOneRequiredWithoutApplicant_documentsInput
    company_documents?: company_documentsUpdateOneRequiredWithoutApplicant_documentsInput
  }

  export type applicant_documentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: IntFieldUpdateOperationsInput | number
    document_id?: IntFieldUpdateOperationsInput | number
  }

  export type applicant_documentsUpdateManyMutationInput = {

  }

  export type applicant_documentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: IntFieldUpdateOperationsInput | number
    document_id?: IntFieldUpdateOperationsInput | number
  }

  export type business_typesCreateInput = {
    name: string
    startups?: startupsCreateManyWithoutBusiness_typesInput
  }

  export type business_typesUncheckedCreateInput = {
    id?: number
    name: string
    startups?: startupsUncheckedCreateManyWithoutBusiness_typesInput
  }

  export type business_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUpdateManyWithoutBusiness_typesInput
  }

  export type business_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUncheckedUpdateManyWithoutBusiness_typesInput
  }

  export type business_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type business_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type companiesCreateInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_documentsCreateInput = {
    doc_url: string
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutCompany_documentsInput
    document_types: document_typesCreateOneWithoutCompany_documentsInput
    IR_requests?: IR_requestsCreateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedCreateInput = {
    id?: number
    company_id: number
    doc_url: string
    type_id: number
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUncheckedCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsUpdateInput = {
    doc_url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_documentsInput
    document_types?: document_typesUpdateOneRequiredWithoutCompany_documentsInput
    IR_requests?: IR_requestsUpdateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    doc_url?: StringFieldUpdateOperationsInput | string
    type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUncheckedUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUpdateManyMutationInput = {
    doc_url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_documentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    doc_url?: StringFieldUpdateOperationsInput | string
    type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_membersCreateInput = {
    name?: string | null
    img?: string | null
    position?: string | null
    companies?: companiesCreateOneWithoutCompany_membersInput
  }

  export type company_membersUncheckedCreateInput = {
    id?: number
    company_id?: number | null
    name?: string | null
    img?: string | null
    position?: string | null
  }

  export type company_membersUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companies?: companiesUpdateOneWithoutCompany_membersInput
  }

  export type company_membersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_membersUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_membersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_newsCreateInput = {
    URL: string
    companies: companiesCreateOneWithoutCompany_newsInput
  }

  export type company_newsUncheckedCreateInput = {
    id?: number
    company_id: number
    URL: string
  }

  export type company_newsUpdateInput = {
    URL?: StringFieldUpdateOperationsInput | string
    companies?: companiesUpdateOneRequiredWithoutCompany_newsInput
  }

  export type company_newsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type company_newsUpdateManyMutationInput = {
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type company_newsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type company_typesCreateInput = {
    name: string
    companies?: companiesCreateManyWithoutCompany_typesInput
  }

  export type company_typesUncheckedCreateInput = {
    id?: number
    name: string
    companies?: companiesUncheckedCreateManyWithoutCompany_typesInput
  }

  export type company_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    companies?: companiesUpdateManyWithoutCompany_typesInput
  }

  export type company_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    companies?: companiesUncheckedUpdateManyWithoutCompany_typesInput
  }

  export type company_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type company_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type demodaysCreateInput = {
    name?: string | null
    streaming_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies?: companiesCreateOneWithoutDemodaysInput
    participants?: participantsCreateManyWithoutDemodaysInput
    questions?: questionsCreateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedCreateInput = {
    id?: number
    name?: string | null
    company_id?: number | null
    streaming_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    participants?: participantsUncheckedCreateManyWithoutDemodaysInput
    questions?: questionsUncheckedCreateManyWithoutDemodaysInput
  }

  export type demodaysUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneWithoutDemodaysInput
    participants?: participantsUpdateManyWithoutDemodaysInput
    questions?: questionsUpdateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: participantsUncheckedUpdateManyWithoutDemodaysInput
    questions?: questionsUncheckedUpdateManyWithoutDemodaysInput
  }

  export type demodaysUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type demodaysUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type document_typesCreateInput = {
    name: string
    company_documents?: company_documentsCreateManyWithoutDocument_typesInput
    required_documents?: required_documentsCreateManyWithoutDocument_typesInput
  }

  export type document_typesUncheckedCreateInput = {
    id?: number
    name: string
    company_documents?: company_documentsUncheckedCreateManyWithoutDocument_typesInput
    required_documents?: required_documentsUncheckedCreateManyWithoutDocument_typesInput
  }

  export type document_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    company_documents?: company_documentsUpdateManyWithoutDocument_typesInput
    required_documents?: required_documentsUpdateManyWithoutDocument_typesInput
  }

  export type document_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company_documents?: company_documentsUncheckedUpdateManyWithoutDocument_typesInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutDocument_typesInput
  }

  export type document_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type document_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type eligibilitiesCreateInput = {
    name: string
    projects?: projectsCreateManyWithoutEligibilitiesInput
  }

  export type eligibilitiesUncheckedCreateInput = {
    id?: number
    name: string
    projects?: projectsUncheckedCreateManyWithoutEligibilitiesInput
  }

  export type eligibilitiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    projects?: projectsUpdateManyWithoutEligibilitiesInput
  }

  export type eligibilitiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    projects?: projectsUncheckedUpdateManyWithoutEligibilitiesInput
  }

  export type eligibilitiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type eligibilitiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type eligible_sectorsCreateInput = {
    name: string
    projects?: projectsCreateManyWithoutEligible_sectorsInput
  }

  export type eligible_sectorsUncheckedCreateInput = {
    id?: number
    name: string
    projects?: projectsUncheckedCreateManyWithoutEligible_sectorsInput
  }

  export type eligible_sectorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    projects?: projectsUpdateManyWithoutEligible_sectorsInput
  }

  export type eligible_sectorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    projects?: projectsUncheckedUpdateManyWithoutEligible_sectorsInput
  }

  export type eligible_sectorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type eligible_sectorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type email_authCreateInput = {
    email: string
    auth_number: string
  }

  export type email_authUncheckedCreateInput = {
    email: string
    auth_number: string
  }

  export type email_authUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    auth_number?: StringFieldUpdateOperationsInput | string
  }

  export type email_authUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    auth_number?: StringFieldUpdateOperationsInput | string
  }

  export type email_authUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    auth_number?: StringFieldUpdateOperationsInput | string
  }

  export type email_authUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    auth_number?: StringFieldUpdateOperationsInput | string
  }

  export type invested_fromCreateInput = {
    date: Date | string
    invested_institution: string
    corporate_value: number
    investment_series: investment_seriesCreateOneWithoutInvested_fromInput
    investment_funds: investment_fundsCreateOneWithoutInvested_fromInput
    startups: startupsCreateOneWithoutInvested_fromInput
  }

  export type invested_fromUncheckedCreateInput = {
    id?: number
    startup_id: number
    date: Date | string
    invested_institution: string
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type invested_fromUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    investment_series?: investment_seriesUpdateOneRequiredWithoutInvested_fromInput
    investment_funds?: investment_fundsUpdateOneRequiredWithoutInvested_fromInput
    startups?: startupsUpdateOneRequiredWithoutInvested_fromInput
  }

  export type invested_fromUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    invested_fund_id?: IntFieldUpdateOperationsInput | number
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type invested_fromUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
  }

  export type invested_fromUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    invested_fund_id?: IntFieldUpdateOperationsInput | number
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type invested_toCreateInput = {
    date: Date | string
    invested_startup: string
    corporate_value: number
    investment_series: investment_seriesCreateOneWithoutInvested_toInput
    investment_funds: investment_fundsCreateOneWithoutInvested_toInput
    partners: partnersCreateOneWithoutInvested_toInput
  }

  export type invested_toUncheckedCreateInput = {
    id?: number
    partner_id: number
    date: Date | string
    invested_startup: string
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type invested_toUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    investment_series?: investment_seriesUpdateOneRequiredWithoutInvested_toInput
    investment_funds?: investment_fundsUpdateOneRequiredWithoutInvested_toInput
    partners?: partnersUpdateOneRequiredWithoutInvested_toInput
  }

  export type invested_toUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    invested_fund_id?: IntFieldUpdateOperationsInput | number
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type invested_toUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
  }

  export type invested_toUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    invested_fund_id?: IntFieldUpdateOperationsInput | number
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type investment_fundsCreateInput = {
    name: string
    partners?: partnersCreateManyWithoutInvestment_fundsInput
    startups?: startupsCreateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromCreateManyWithoutInvestment_fundsInput
    invested_to?: invested_toCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedCreateInput = {
    id?: number
    name: string
    partners?: partnersUncheckedCreateManyWithoutInvestment_fundsInput
    startups?: startupsUncheckedCreateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUncheckedCreateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUncheckedCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUpdateManyWithoutInvestment_fundsInput
    startups?: startupsUpdateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUpdateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUncheckedUpdateManyWithoutInvestment_fundsInput
    startups?: startupsUncheckedUpdateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUncheckedUpdateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUncheckedUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type investment_fundsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type investment_portfolioCreateInput = {
    img_url: string
    partners: partnersCreateOneWithoutInvestment_portfolioInput
  }

  export type investment_portfolioUncheckedCreateInput = {
    id?: number
    partner_id: number
    img_url: string
  }

  export type investment_portfolioUpdateInput = {
    img_url?: StringFieldUpdateOperationsInput | string
    partners?: partnersUpdateOneRequiredWithoutInvestment_portfolioInput
  }

  export type investment_portfolioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type investment_portfolioUpdateManyMutationInput = {
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type investment_portfolioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type investment_seriesCreateInput = {
    name: string
    invested_from?: invested_fromCreateManyWithoutInvestment_seriesInput
    invested_to?: invested_toCreateManyWithoutInvestment_seriesInput
    startups?: startupsCreateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedCreateInput = {
    id?: number
    name: string
    invested_from?: invested_fromUncheckedCreateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUncheckedCreateManyWithoutInvestment_seriesInput
    startups?: startupsUncheckedCreateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    invested_from?: invested_fromUpdateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUpdateManyWithoutInvestment_seriesInput
    startups?: startupsUpdateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    invested_from?: invested_fromUncheckedUpdateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUncheckedUpdateManyWithoutInvestment_seriesInput
    startups?: startupsUncheckedUpdateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type investment_seriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IR_requestsCreateInput = {
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    company_documents?: company_documentsCreateOneWithoutIR_requestsInput
    partners: partnersCreateOneWithoutIR_requestsInput
    startups: startupsCreateOneWithoutIR_requestsInput
    companies?: companiesCreateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedCreateInput = {
    id?: number
    startup_id: number
    partner_id: number
    document_id?: number | null
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    companiesId?: number | null
  }

  export type IR_requestsUpdateInput = {
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_documents?: company_documentsUpdateOneWithoutIR_requestsInput
    partners?: partnersUpdateOneRequiredWithoutIR_requestsInput
    startups?: startupsUpdateOneRequiredWithoutIR_requestsInput
    companies?: companiesUpdateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    document_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IR_requestsUpdateManyMutationInput = {
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IR_requestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    document_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type participantsCreateInput = {
    order: number
    companies: companiesCreateOneWithoutParticipantsInput
    demodays: demodaysCreateOneWithoutParticipantsInput
    votes?: votesCreateManyWithoutParticipantsInput
  }

  export type participantsUncheckedCreateInput = {
    id?: number
    demoday_id: number
    order: number
    company_id: number
    votes?: votesUncheckedCreateManyWithoutParticipantsInput
  }

  export type participantsUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    companies?: companiesUpdateOneRequiredWithoutParticipantsInput
    demodays?: demodaysUpdateOneRequiredWithoutParticipantsInput
    votes?: votesUpdateManyWithoutParticipantsInput
  }

  export type participantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    demoday_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    votes?: votesUncheckedUpdateManyWithoutParticipantsInput
  }

  export type participantsUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
  }

  export type participantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    demoday_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type partnersCreateInput = {
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutPartnersInput
    technologies?: technologiesCreateOneWithoutPartnersInput
    investment_funds?: investment_fundsCreateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsCreateManyWithoutPartnersInput
    invested_to?: invested_toCreateManyWithoutPartnersInput
  }

  export type partnersUncheckedCreateInput = {
    id?: number
    company_id: number
    interst_technology_id?: number | null
    invested_total_id?: number | null
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    investment_portfolio?: investment_portfolioUncheckedCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedCreateManyWithoutPartnersInput
  }

  export type partnersUpdateInput = {
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutPartnersInput
    technologies?: technologiesUpdateOneWithoutPartnersInput
    investment_funds?: investment_fundsUpdateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUpdateManyWithoutPartnersInput
    invested_to?: invested_toUpdateManyWithoutPartnersInput
  }

  export type partnersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    interst_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_total_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    investment_portfolio?: investment_portfolioUncheckedUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedUpdateManyWithoutPartnersInput
  }

  export type partnersUpdateManyMutationInput = {
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partnersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    interst_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_total_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partner_likesCreateInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateOneWithoutPartner_likesInput
    companies: companiesCreateOneWithoutPartner_likesInput
  }

  export type partner_likesUncheckedCreateInput = {
    id?: number
    user_id: number
    company_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type partner_likesUpdateInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutPartner_likesInput
    companies?: companiesUpdateOneRequiredWithoutPartner_likesInput
  }

  export type partner_likesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type partner_likesUpdateManyMutationInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type partner_likesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type phone_authCreateInput = {
    phone_number: string
    auth_number: string
  }

  export type phone_authUncheckedCreateInput = {
    id?: number
    phone_number: string
    auth_number: string
  }

  export type phone_authUpdateInput = {
    phone_number?: StringFieldUpdateOperationsInput | string
    auth_number?: StringFieldUpdateOperationsInput | string
  }

  export type phone_authUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone_number?: StringFieldUpdateOperationsInput | string
    auth_number?: StringFieldUpdateOperationsInput | string
  }

  export type phone_authUpdateManyMutationInput = {
    phone_number?: StringFieldUpdateOperationsInput | string
    auth_number?: StringFieldUpdateOperationsInput | string
  }

  export type phone_authUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    phone_number?: StringFieldUpdateOperationsInput | string
    auth_number?: StringFieldUpdateOperationsInput | string
  }

  export type project_imagesCreateInput = {
    img_url?: string | null
    projects: projectsCreateOneWithoutProject_imagesInput
  }

  export type project_imagesUncheckedCreateInput = {
    id?: number
    project_id: number
    img_url?: string | null
  }

  export type project_imagesUpdateInput = {
    img_url?: NullableStringFieldUpdateOperationsInput | string | null
    projects?: projectsUpdateOneRequiredWithoutProject_imagesInput
  }

  export type project_imagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_imagesUpdateManyMutationInput = {
    img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_imagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_likesCreateInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateOneWithoutProject_likesInput
    projects: projectsCreateOneWithoutProject_likesInput
    companies?: companiesCreateOneWithoutProject_likesInput
  }

  export type project_likesUncheckedCreateInput = {
    id?: number
    user_id: number
    project_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companiesId?: number | null
  }

  export type project_likesUpdateInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutProject_likesInput
    projects?: projectsUpdateOneRequiredWithoutProject_likesInput
    companies?: companiesUpdateOneWithoutProject_likesInput
  }

  export type project_likesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type project_likesUpdateManyMutationInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type project_likesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type projectsCreateInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligible_sectors?: eligible_sectorsCreateOneWithoutProjectsInput
    eligibilities?: eligibilitiesCreateOneWithoutProjectsInput
    companies?: companiesCreateOneWithoutProjectsInput
    applicants?: applicantsCreateManyWithoutProjectsInput
    project_images?: project_imagesCreateManyWithoutProjectsInput
    project_likes?: project_likesCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectCreateManyWithoutProjectsInput
    required_documents?: required_documentsCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    company_id?: number | null
    host?: string | null
    due_date?: Date | string | null
    eligible_sector?: number | null
    eligibility?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedCreateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sectors?: eligible_sectorsUpdateOneWithoutProjectsInput
    eligibilities?: eligibilitiesUpdateOneWithoutProjectsInput
    companies?: companiesUpdateOneWithoutProjectsInput
    applicants?: applicantsUpdateManyWithoutProjectsInput
    project_images?: project_imagesUpdateManyWithoutProjectsInput
    project_likes?: project_likesUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedUpdateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutProjectsInput
  }

  export type projectsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsCreateInput = {
    content: string
    created_at: Date | string
    updated_at: Date | string
    companies: companiesCreateOneWithoutQuestionsInput
    demodays: demodaysCreateOneWithoutQuestionsInput
    users: usersCreateOneWithoutQuestionsInput
    answers?: answersCreateManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateInput = {
    id?: number
    content: string
    company_id: number
    user_id: number
    created_at: Date | string
    updated_at: Date | string
    demoday_id: number
    answers?: answersUncheckedCreateManyWithoutQuestionsInput
  }

  export type questionsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutQuestionsInput
    demodays?: demodaysUpdateOneRequiredWithoutQuestionsInput
    users?: usersUpdateOneRequiredWithoutQuestionsInput
    answers?: answersUpdateManyWithoutQuestionsInput
  }

  export type questionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demoday_id?: IntFieldUpdateOperationsInput | number
    answers?: answersUncheckedUpdateManyWithoutQuestionsInput
  }

  export type questionsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type questionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demoday_id?: IntFieldUpdateOperationsInput | number
  }

  export type recent_views_projectCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    companies: companiesCreateOneWithoutRecent_views_projectInput
    projects: projectsCreateOneWithoutRecent_views_projectInput
  }

  export type recent_views_projectUncheckedCreateInput = {
    id?: number
    project_id: number
    company_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type recent_views_projectUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutRecent_views_projectInput
    projects?: projectsUpdateOneRequiredWithoutRecent_views_projectInput
  }

  export type recent_views_projectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recent_views_projectUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recent_views_projectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type required_documentsCreateInput = {
    document_types: document_typesCreateOneWithoutRequired_documentsInput
    projects: projectsCreateOneWithoutRequired_documentsInput
  }

  export type required_documentsUncheckedCreateInput = {
    id?: number
    project_id: number
    document_id: number
  }

  export type required_documentsUpdateInput = {
    document_types?: document_typesUpdateOneRequiredWithoutRequired_documentsInput
    projects?: projectsUpdateOneRequiredWithoutRequired_documentsInput
  }

  export type required_documentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    document_id?: IntFieldUpdateOperationsInput | number
  }

  export type required_documentsUpdateManyMutationInput = {

  }

  export type required_documentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    document_id?: IntFieldUpdateOperationsInput | number
  }

  export type sectorsCreateInput = {
    name: string
    startups?: startupsCreateManyWithoutSectorsInput
  }

  export type sectorsUncheckedCreateInput = {
    id?: number
    name: string
    startups?: startupsUncheckedCreateManyWithoutSectorsInput
  }

  export type sectorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUpdateManyWithoutSectorsInput
  }

  export type sectorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUncheckedUpdateManyWithoutSectorsInput
  }

  export type sectorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type sectorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type service_typesCreateInput = {
    name: string
    startups?: startupsCreateManyWithoutService_typesInput
  }

  export type service_typesUncheckedCreateInput = {
    id?: number
    name: string
    startups?: startupsUncheckedCreateManyWithoutService_typesInput
  }

  export type service_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUpdateManyWithoutService_typesInput
  }

  export type service_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUncheckedUpdateManyWithoutService_typesInput
  }

  export type service_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type service_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type signup_methodsCreateInput = {
    name: string
    users?: usersCreateManyWithoutSignup_methodsInput
  }

  export type signup_methodsUncheckedCreateInput = {
    id?: number
    name: string
    users?: usersUncheckedCreateManyWithoutSignup_methodsInput
  }

  export type signup_methodsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateManyWithoutSignup_methodsInput
  }

  export type signup_methodsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: usersUncheckedUpdateManyWithoutSignup_methodsInput
  }

  export type signup_methodsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type signup_methodsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type startup_imagesCreateInput = {
    img_url: string
    startups: startupsCreateOneWithoutStartup_imagesInput
  }

  export type startup_imagesUncheckedCreateInput = {
    id?: number
    startup_id: number
    img_url: string
  }

  export type startup_imagesUpdateInput = {
    img_url?: StringFieldUpdateOperationsInput | string
    startups?: startupsUpdateOneRequiredWithoutStartup_imagesInput
  }

  export type startup_imagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type startup_imagesUpdateManyMutationInput = {
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type startup_imagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type startupsCreateInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsUpdateInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type startupsUpdateManyMutationInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type startupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wish_investment_seriesCreateInput = {
    startups: startupsCreateOneWithoutWish_investment_seriesInput
    investment_series: investment_seriesCreateOneWithoutWish_investment_seriesInput
  }

  export type wish_investment_seriesUncheckedCreateInput = {
    id?: number
    startup_id: number
    investment_series_id: number
  }

  export type wish_investment_seriesUpdateInput = {
    startups?: startupsUpdateOneRequiredWithoutWish_investment_seriesInput
    investment_series?: investment_seriesUpdateOneRequiredWithoutWish_investment_seriesInput
  }

  export type wish_investment_seriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    investment_series_id?: IntFieldUpdateOperationsInput | number
  }

  export type wish_investment_seriesUpdateManyMutationInput = {

  }

  export type wish_investment_seriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    investment_series_id?: IntFieldUpdateOperationsInput | number
  }

  export type startup_likesCreateInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies: companiesCreateOneWithoutStartup_likesInput
    users: usersCreateOneWithoutStartup_likesInput
  }

  export type startup_likesUncheckedCreateInput = {
    id?: number
    user_id: number
    company_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type startup_likesUpdateInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutStartup_likesInput
    users?: usersUpdateOneRequiredWithoutStartup_likesInput
  }

  export type startup_likesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type startup_likesUpdateManyMutationInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type startup_likesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type technologiesCreateInput = {
    name: string
    partners?: partnersCreateManyWithoutTechnologiesInput
    startups?: startupsCreateManyWithoutTechnologiesInput
  }

  export type technologiesUncheckedCreateInput = {
    id?: number
    name: string
    partners?: partnersUncheckedCreateManyWithoutTechnologiesInput
    startups?: startupsUncheckedCreateManyWithoutTechnologiesInput
  }

  export type technologiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUpdateManyWithoutTechnologiesInput
    startups?: startupsUpdateManyWithoutTechnologiesInput
  }

  export type technologiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUncheckedUpdateManyWithoutTechnologiesInput
    startups?: startupsUncheckedUpdateManyWithoutTechnologiesInput
  }

  export type technologiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type technologiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type termsCreateInput = {
    name: string
    content: string
    required: boolean
    user_agreements?: user_agreementsCreateManyWithoutTermsInput
  }

  export type termsUncheckedCreateInput = {
    id?: number
    name: string
    content: string
    required: boolean
    user_agreements?: user_agreementsUncheckedCreateManyWithoutTermsInput
  }

  export type termsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    user_agreements?: user_agreementsUpdateManyWithoutTermsInput
  }

  export type termsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutTermsInput
  }

  export type termsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type termsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_agreementsCreateInput = {
    terms: termsCreateOneWithoutUser_agreementsInput
    users: usersCreateOneWithoutUser_agreementsInput
  }

  export type user_agreementsUncheckedCreateInput = {
    id?: number
    user_id: number
    term_id: number
  }

  export type user_agreementsUpdateInput = {
    terms?: termsUpdateOneRequiredWithoutUser_agreementsInput
    users?: usersUpdateOneRequiredWithoutUser_agreementsInput
  }

  export type user_agreementsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    term_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_agreementsUpdateManyMutationInput = {

  }

  export type user_agreementsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    term_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_typesCreateInput = {
    name: string
    users?: usersCreateManyWithoutUser_typesInput
  }

  export type user_typesUncheckedCreateInput = {
    id?: number
    name: string
    users?: usersUncheckedCreateManyWithoutUser_typesInput
  }

  export type user_typesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateManyWithoutUser_typesInput
  }

  export type user_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: usersUncheckedUpdateManyWithoutUser_typesInput
  }

  export type user_typesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type user_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type usersUpdateManyMutationInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesCreateInput = {
    created_at?: Date | string
    participants: participantsCreateOneWithoutVotesInput
    users: usersCreateOneWithoutVotesInput
  }

  export type votesUncheckedCreateInput = {
    id?: number
    user_id: number
    participants_id: number
    created_at?: Date | string
  }

  export type votesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: participantsUpdateOneRequiredWithoutVotesInput
    users?: usersUpdateOneRequiredWithoutVotesInput
  }

  export type votesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    participants_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    participants_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type QuestionsRelationFilter = {
    is?: questionsWhereInput
    isNot?: questionsWhereInput
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type CompaniesRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type ProjectsRelationFilter = {
    is?: projectsWhereInput
    isNot?: projectsWhereInput
  }

  export type Applicant_documentsListRelationFilter = {
    every?: applicant_documentsWhereInput
    some?: applicant_documentsWhereInput
    none?: applicant_documentsWhereInput
  }

  export type ApplicantsRelationFilter = {
    is?: applicantsWhereInput
    isNot?: applicantsWhereInput
  }

  export type Company_documentsRelationFilter = {
    is?: company_documentsWhereInput | null
    isNot?: company_documentsWhereInput | null
  }

  export type StartupsListRelationFilter = {
    every?: startupsWhereInput
    some?: startupsWhereInput
    none?: startupsWhereInput
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type Company_typesRelationFilter = {
    is?: company_typesWhereInput | null
    isNot?: company_typesWhereInput | null
  }

  export type ApplicantsListRelationFilter = {
    every?: applicantsWhereInput
    some?: applicantsWhereInput
    none?: applicantsWhereInput
  }

  export type Company_documentsListRelationFilter = {
    every?: company_documentsWhereInput
    some?: company_documentsWhereInput
    none?: company_documentsWhereInput
  }

  export type Company_membersListRelationFilter = {
    every?: company_membersWhereInput
    some?: company_membersWhereInput
    none?: company_membersWhereInput
  }

  export type Company_newsListRelationFilter = {
    every?: company_newsWhereInput
    some?: company_newsWhereInput
    none?: company_newsWhereInput
  }

  export type DemodaysListRelationFilter = {
    every?: demodaysWhereInput
    some?: demodaysWhereInput
    none?: demodaysWhereInput
  }

  export type IR_requestsListRelationFilter = {
    every?: IR_requestsWhereInput
    some?: IR_requestsWhereInput
    none?: IR_requestsWhereInput
  }

  export type ParticipantsListRelationFilter = {
    every?: participantsWhereInput
    some?: participantsWhereInput
    none?: participantsWhereInput
  }

  export type PartnersListRelationFilter = {
    every?: partnersWhereInput
    some?: partnersWhereInput
    none?: partnersWhereInput
  }

  export type Partner_likesListRelationFilter = {
    every?: partner_likesWhereInput
    some?: partner_likesWhereInput
    none?: partner_likesWhereInput
  }

  export type Project_likesListRelationFilter = {
    every?: project_likesWhereInput
    some?: project_likesWhereInput
    none?: project_likesWhereInput
  }

  export type ProjectsListRelationFilter = {
    every?: projectsWhereInput
    some?: projectsWhereInput
    none?: projectsWhereInput
  }

  export type QuestionsListRelationFilter = {
    every?: questionsWhereInput
    some?: questionsWhereInput
    none?: questionsWhereInput
  }

  export type Recent_views_projectListRelationFilter = {
    every?: recent_views_projectWhereInput
    some?: recent_views_projectWhereInput
    none?: recent_views_projectWhereInput
  }

  export type Startup_likesListRelationFilter = {
    every?: startup_likesWhereInput
    some?: startup_likesWhereInput
    none?: startup_likesWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type Document_typesRelationFilter = {
    is?: document_typesWhereInput
    isNot?: document_typesWhereInput
  }

  export type CompaniesListRelationFilter = {
    every?: companiesWhereInput
    some?: companiesWhereInput
    none?: companiesWhereInput
  }

  export type Required_documentsListRelationFilter = {
    every?: required_documentsWhereInput
    some?: required_documentsWhereInput
    none?: required_documentsWhereInput
  }

  export type email_authEmailAuth_numberCompoundUniqueInput = {
    email: string
    auth_number: string
  }

  export type Investment_seriesRelationFilter = {
    is?: investment_seriesWhereInput
    isNot?: investment_seriesWhereInput
  }

  export type Investment_fundsRelationFilter = {
    is?: investment_fundsWhereInput
    isNot?: investment_fundsWhereInput
  }

  export type StartupsRelationFilter = {
    is?: startupsWhereInput
    isNot?: startupsWhereInput
  }

  export type PartnersRelationFilter = {
    is?: partnersWhereInput
    isNot?: partnersWhereInput
  }

  export type Invested_fromListRelationFilter = {
    every?: invested_fromWhereInput
    some?: invested_fromWhereInput
    none?: invested_fromWhereInput
  }

  export type Invested_toListRelationFilter = {
    every?: invested_toWhereInput
    some?: invested_toWhereInput
    none?: invested_toWhereInput
  }

  export type Wish_investment_seriesListRelationFilter = {
    every?: wish_investment_seriesWhereInput
    some?: wish_investment_seriesWhereInput
    none?: wish_investment_seriesWhereInput
  }

  export type DemodaysRelationFilter = {
    is?: demodaysWhereInput
    isNot?: demodaysWhereInput
  }

  export type VotesListRelationFilter = {
    every?: votesWhereInput
    some?: votesWhereInput
    none?: votesWhereInput
  }

  export type TechnologiesRelationFilter = {
    is?: technologiesWhereInput | null
    isNot?: technologiesWhereInput | null
  }

  export type Investment_portfolioListRelationFilter = {
    every?: investment_portfolioWhereInput
    some?: investment_portfolioWhereInput
    none?: investment_portfolioWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type Eligible_sectorsRelationFilter = {
    is?: eligible_sectorsWhereInput | null
    isNot?: eligible_sectorsWhereInput | null
  }

  export type EligibilitiesRelationFilter = {
    is?: eligibilitiesWhereInput | null
    isNot?: eligibilitiesWhereInput | null
  }

  export type Project_imagesListRelationFilter = {
    every?: project_imagesWhereInput
    some?: project_imagesWhereInput
    none?: project_imagesWhereInput
  }

  export type AnswersListRelationFilter = {
    every?: answersWhereInput
    some?: answersWhereInput
    none?: answersWhereInput
  }

  export type Business_typesRelationFilter = {
    is?: business_typesWhereInput | null
    isNot?: business_typesWhereInput | null
  }

  export type SectorsRelationFilter = {
    is?: sectorsWhereInput | null
    isNot?: sectorsWhereInput | null
  }

  export type Service_typesRelationFilter = {
    is?: service_typesWhereInput | null
    isNot?: service_typesWhereInput | null
  }

  export type Startup_imagesListRelationFilter = {
    every?: startup_imagesWhereInput
    some?: startup_imagesWhereInput
    none?: startup_imagesWhereInput
  }

  export type User_agreementsListRelationFilter = {
    every?: user_agreementsWhereInput
    some?: user_agreementsWhereInput
    none?: user_agreementsWhereInput
  }

  export type TermsRelationFilter = {
    is?: termsWhereInput
    isNot?: termsWhereInput
  }

  export type Signup_methodsRelationFilter = {
    is?: signup_methodsWhereInput
    isNot?: signup_methodsWhereInput
  }

  export type User_typesRelationFilter = {
    is?: user_typesWhereInput | null
    isNot?: user_typesWhereInput | null
  }

  export type ParticipantsRelationFilter = {
    is?: participantsWhereInput
    isNot?: participantsWhereInput
  }

  export type questionsCreateOneWithoutAnswersInput = {
    create?: XOR<questionsUncheckedCreateWithoutAnswersInput, questionsCreateWithoutAnswersInput>
    connect?: questionsWhereUniqueInput
    connectOrCreate?: questionsCreateOrConnectWithoutanswersInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type questionsUpdateOneRequiredWithoutAnswersInput = {
    create?: XOR<questionsUncheckedCreateWithoutAnswersInput, questionsCreateWithoutAnswersInput>
    connect?: questionsWhereUniqueInput
    update?: XOR<questionsUncheckedUpdateWithoutAnswersInput, questionsUpdateWithoutAnswersInput>
    upsert?: questionsUpsertWithoutAnswersInput
    connectOrCreate?: questionsCreateOrConnectWithoutanswersInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type companiesCreateOneWithoutApplicantsInput = {
    create?: XOR<companiesUncheckedCreateWithoutApplicantsInput, companiesCreateWithoutApplicantsInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutapplicantsInput
  }

  export type projectsCreateOneWithoutApplicantsInput = {
    create?: XOR<projectsUncheckedCreateWithoutApplicantsInput, projectsCreateWithoutApplicantsInput>
    connect?: projectsWhereUniqueInput
    connectOrCreate?: projectsCreateOrConnectWithoutapplicantsInput
  }

  export type applicant_documentsCreateManyWithoutApplicantsInput = {
    create?: XOR<Enumerable<applicant_documentsUncheckedCreateWithoutApplicantsInput>, Enumerable<applicant_documentsCreateWithoutApplicantsInput>>
    connect?: Enumerable<applicant_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<applicant_documentsCreateOrConnectWithoutapplicantsInput>
  }

  export type applicant_documentsUncheckedCreateManyWithoutApplicantsInput = {
    create?: XOR<Enumerable<applicant_documentsUncheckedCreateWithoutApplicantsInput>, Enumerable<applicant_documentsCreateWithoutApplicantsInput>>
    connect?: Enumerable<applicant_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<applicant_documentsCreateOrConnectWithoutapplicantsInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type companiesUpdateOneRequiredWithoutApplicantsInput = {
    create?: XOR<companiesUncheckedCreateWithoutApplicantsInput, companiesCreateWithoutApplicantsInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutApplicantsInput, companiesUpdateWithoutApplicantsInput>
    upsert?: companiesUpsertWithoutApplicantsInput
    connectOrCreate?: companiesCreateOrConnectWithoutapplicantsInput
  }

  export type projectsUpdateOneRequiredWithoutApplicantsInput = {
    create?: XOR<projectsUncheckedCreateWithoutApplicantsInput, projectsCreateWithoutApplicantsInput>
    connect?: projectsWhereUniqueInput
    update?: XOR<projectsUncheckedUpdateWithoutApplicantsInput, projectsUpdateWithoutApplicantsInput>
    upsert?: projectsUpsertWithoutApplicantsInput
    connectOrCreate?: projectsCreateOrConnectWithoutapplicantsInput
  }

  export type applicant_documentsUpdateManyWithoutApplicantsInput = {
    create?: XOR<Enumerable<applicant_documentsUncheckedCreateWithoutApplicantsInput>, Enumerable<applicant_documentsCreateWithoutApplicantsInput>>
    connect?: Enumerable<applicant_documentsWhereUniqueInput>
    set?: Enumerable<applicant_documentsWhereUniqueInput>
    disconnect?: Enumerable<applicant_documentsWhereUniqueInput>
    delete?: Enumerable<applicant_documentsWhereUniqueInput>
    update?: Enumerable<applicant_documentsUpdateWithWhereUniqueWithoutApplicantsInput>
    updateMany?: Enumerable<applicant_documentsUpdateManyWithWhereWithoutApplicantsInput>
    deleteMany?: Enumerable<applicant_documentsScalarWhereInput>
    upsert?: Enumerable<applicant_documentsUpsertWithWhereUniqueWithoutApplicantsInput>
    connectOrCreate?: Enumerable<applicant_documentsCreateOrConnectWithoutapplicantsInput>
  }

  export type applicant_documentsUncheckedUpdateManyWithoutApplicantsInput = {
    create?: XOR<Enumerable<applicant_documentsUncheckedCreateWithoutApplicantsInput>, Enumerable<applicant_documentsCreateWithoutApplicantsInput>>
    connect?: Enumerable<applicant_documentsWhereUniqueInput>
    set?: Enumerable<applicant_documentsWhereUniqueInput>
    disconnect?: Enumerable<applicant_documentsWhereUniqueInput>
    delete?: Enumerable<applicant_documentsWhereUniqueInput>
    update?: Enumerable<applicant_documentsUpdateWithWhereUniqueWithoutApplicantsInput>
    updateMany?: Enumerable<applicant_documentsUpdateManyWithWhereWithoutApplicantsInput>
    deleteMany?: Enumerable<applicant_documentsScalarWhereInput>
    upsert?: Enumerable<applicant_documentsUpsertWithWhereUniqueWithoutApplicantsInput>
    connectOrCreate?: Enumerable<applicant_documentsCreateOrConnectWithoutapplicantsInput>
  }

  export type applicantsCreateOneWithoutApplicant_documentsInput = {
    create?: XOR<applicantsUncheckedCreateWithoutApplicant_documentsInput, applicantsCreateWithoutApplicant_documentsInput>
    connect?: applicantsWhereUniqueInput
    connectOrCreate?: applicantsCreateOrConnectWithoutapplicant_documentsInput
  }

  export type company_documentsCreateOneWithoutApplicant_documentsInput = {
    create?: XOR<company_documentsUncheckedCreateWithoutApplicant_documentsInput, company_documentsCreateWithoutApplicant_documentsInput>
    connect?: company_documentsWhereUniqueInput
    connectOrCreate?: company_documentsCreateOrConnectWithoutapplicant_documentsInput
  }

  export type applicantsUpdateOneRequiredWithoutApplicant_documentsInput = {
    create?: XOR<applicantsUncheckedCreateWithoutApplicant_documentsInput, applicantsCreateWithoutApplicant_documentsInput>
    connect?: applicantsWhereUniqueInput
    update?: XOR<applicantsUncheckedUpdateWithoutApplicant_documentsInput, applicantsUpdateWithoutApplicant_documentsInput>
    upsert?: applicantsUpsertWithoutApplicant_documentsInput
    connectOrCreate?: applicantsCreateOrConnectWithoutapplicant_documentsInput
  }

  export type company_documentsUpdateOneRequiredWithoutApplicant_documentsInput = {
    create?: XOR<company_documentsUncheckedCreateWithoutApplicant_documentsInput, company_documentsCreateWithoutApplicant_documentsInput>
    connect?: company_documentsWhereUniqueInput
    update?: XOR<company_documentsUncheckedUpdateWithoutApplicant_documentsInput, company_documentsUpdateWithoutApplicant_documentsInput>
    upsert?: company_documentsUpsertWithoutApplicant_documentsInput
    connectOrCreate?: company_documentsCreateOrConnectWithoutapplicant_documentsInput
  }

  export type startupsCreateManyWithoutBusiness_typesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutBusiness_typesInput>, Enumerable<startupsCreateWithoutBusiness_typesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutbusiness_typesInput>
  }

  export type startupsUncheckedCreateManyWithoutBusiness_typesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutBusiness_typesInput>, Enumerable<startupsCreateWithoutBusiness_typesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutbusiness_typesInput>
  }

  export type startupsUpdateManyWithoutBusiness_typesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutBusiness_typesInput>, Enumerable<startupsCreateWithoutBusiness_typesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutBusiness_typesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutBusiness_typesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutBusiness_typesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutbusiness_typesInput>
  }

  export type startupsUncheckedUpdateManyWithoutBusiness_typesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutBusiness_typesInput>, Enumerable<startupsCreateWithoutBusiness_typesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutBusiness_typesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutBusiness_typesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutBusiness_typesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutbusiness_typesInput>
  }

  export type company_typesCreateOneWithoutCompaniesInput = {
    create?: XOR<company_typesUncheckedCreateWithoutCompaniesInput, company_typesCreateWithoutCompaniesInput>
    connect?: company_typesWhereUniqueInput
    connectOrCreate?: company_typesCreateOrConnectWithoutcompaniesInput
  }

  export type applicantsCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<applicantsUncheckedCreateWithoutCompaniesInput>, Enumerable<applicantsCreateWithoutCompaniesInput>>
    connect?: Enumerable<applicantsWhereUniqueInput>
    connectOrCreate?: Enumerable<applicantsCreateOrConnectWithoutcompaniesInput>
  }

  export type company_documentsCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_documentsUncheckedCreateWithoutCompaniesInput>, Enumerable<company_documentsCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<company_documentsCreateOrConnectWithoutcompaniesInput>
  }

  export type company_membersCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_membersUncheckedCreateWithoutCompaniesInput>, Enumerable<company_membersCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_membersWhereUniqueInput>
    connectOrCreate?: Enumerable<company_membersCreateOrConnectWithoutcompaniesInput>
  }

  export type company_newsCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_newsUncheckedCreateWithoutCompaniesInput>, Enumerable<company_newsCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_newsWhereUniqueInput>
    connectOrCreate?: Enumerable<company_newsCreateOrConnectWithoutcompaniesInput>
  }

  export type demodaysCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<demodaysUncheckedCreateWithoutCompaniesInput>, Enumerable<demodaysCreateWithoutCompaniesInput>>
    connect?: Enumerable<demodaysWhereUniqueInput>
    connectOrCreate?: Enumerable<demodaysCreateOrConnectWithoutcompaniesInput>
  }

  export type IR_requestsCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutCompaniesInput>, Enumerable<IR_requestsCreateWithoutCompaniesInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutcompaniesInput>
  }

  export type participantsCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<participantsUncheckedCreateWithoutCompaniesInput>, Enumerable<participantsCreateWithoutCompaniesInput>>
    connect?: Enumerable<participantsWhereUniqueInput>
    connectOrCreate?: Enumerable<participantsCreateOrConnectWithoutcompaniesInput>
  }

  export type partnersCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutCompaniesInput>, Enumerable<partnersCreateWithoutCompaniesInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithoutcompaniesInput>
  }

  export type partner_likesCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<partner_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<partner_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<partner_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<partner_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type project_likesCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<project_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type projectsCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutCompaniesInput>, Enumerable<projectsCreateWithoutCompaniesInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithoutcompaniesInput>
  }

  export type questionsCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutCompaniesInput>, Enumerable<questionsCreateWithoutCompaniesInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutcompaniesInput>
  }

  export type recent_views_projectCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<recent_views_projectUncheckedCreateWithoutCompaniesInput>, Enumerable<recent_views_projectCreateWithoutCompaniesInput>>
    connect?: Enumerable<recent_views_projectWhereUniqueInput>
    connectOrCreate?: Enumerable<recent_views_projectCreateOrConnectWithoutcompaniesInput>
  }

  export type startupsCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutCompaniesInput>, Enumerable<startupsCreateWithoutCompaniesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutcompaniesInput>
  }

  export type startup_likesCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<startup_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<startup_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<startup_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<startup_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type usersCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutCompaniesInput>, Enumerable<usersCreateWithoutCompaniesInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutcompaniesInput>
  }

  export type applicantsUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<applicantsUncheckedCreateWithoutCompaniesInput>, Enumerable<applicantsCreateWithoutCompaniesInput>>
    connect?: Enumerable<applicantsWhereUniqueInput>
    connectOrCreate?: Enumerable<applicantsCreateOrConnectWithoutcompaniesInput>
  }

  export type company_documentsUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_documentsUncheckedCreateWithoutCompaniesInput>, Enumerable<company_documentsCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<company_documentsCreateOrConnectWithoutcompaniesInput>
  }

  export type company_membersUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_membersUncheckedCreateWithoutCompaniesInput>, Enumerable<company_membersCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_membersWhereUniqueInput>
    connectOrCreate?: Enumerable<company_membersCreateOrConnectWithoutcompaniesInput>
  }

  export type company_newsUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_newsUncheckedCreateWithoutCompaniesInput>, Enumerable<company_newsCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_newsWhereUniqueInput>
    connectOrCreate?: Enumerable<company_newsCreateOrConnectWithoutcompaniesInput>
  }

  export type demodaysUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<demodaysUncheckedCreateWithoutCompaniesInput>, Enumerable<demodaysCreateWithoutCompaniesInput>>
    connect?: Enumerable<demodaysWhereUniqueInput>
    connectOrCreate?: Enumerable<demodaysCreateOrConnectWithoutcompaniesInput>
  }

  export type IR_requestsUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutCompaniesInput>, Enumerable<IR_requestsCreateWithoutCompaniesInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutcompaniesInput>
  }

  export type participantsUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<participantsUncheckedCreateWithoutCompaniesInput>, Enumerable<participantsCreateWithoutCompaniesInput>>
    connect?: Enumerable<participantsWhereUniqueInput>
    connectOrCreate?: Enumerable<participantsCreateOrConnectWithoutcompaniesInput>
  }

  export type partnersUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutCompaniesInput>, Enumerable<partnersCreateWithoutCompaniesInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithoutcompaniesInput>
  }

  export type partner_likesUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<partner_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<partner_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<partner_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<partner_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type project_likesUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<project_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type projectsUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutCompaniesInput>, Enumerable<projectsCreateWithoutCompaniesInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithoutcompaniesInput>
  }

  export type questionsUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutCompaniesInput>, Enumerable<questionsCreateWithoutCompaniesInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutcompaniesInput>
  }

  export type recent_views_projectUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<recent_views_projectUncheckedCreateWithoutCompaniesInput>, Enumerable<recent_views_projectCreateWithoutCompaniesInput>>
    connect?: Enumerable<recent_views_projectWhereUniqueInput>
    connectOrCreate?: Enumerable<recent_views_projectCreateOrConnectWithoutcompaniesInput>
  }

  export type startupsUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutCompaniesInput>, Enumerable<startupsCreateWithoutCompaniesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutcompaniesInput>
  }

  export type startup_likesUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<startup_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<startup_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<startup_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<startup_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type usersUncheckedCreateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutCompaniesInput>, Enumerable<usersCreateWithoutCompaniesInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutcompaniesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type company_typesUpdateOneWithoutCompaniesInput = {
    create?: XOR<company_typesUncheckedCreateWithoutCompaniesInput, company_typesCreateWithoutCompaniesInput>
    connect?: company_typesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<company_typesUncheckedUpdateWithoutCompaniesInput, company_typesUpdateWithoutCompaniesInput>
    upsert?: company_typesUpsertWithoutCompaniesInput
    connectOrCreate?: company_typesCreateOrConnectWithoutcompaniesInput
  }

  export type applicantsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<applicantsUncheckedCreateWithoutCompaniesInput>, Enumerable<applicantsCreateWithoutCompaniesInput>>
    connect?: Enumerable<applicantsWhereUniqueInput>
    set?: Enumerable<applicantsWhereUniqueInput>
    disconnect?: Enumerable<applicantsWhereUniqueInput>
    delete?: Enumerable<applicantsWhereUniqueInput>
    update?: Enumerable<applicantsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<applicantsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<applicantsScalarWhereInput>
    upsert?: Enumerable<applicantsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<applicantsCreateOrConnectWithoutcompaniesInput>
  }

  export type company_documentsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_documentsUncheckedCreateWithoutCompaniesInput>, Enumerable<company_documentsCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_documentsWhereUniqueInput>
    set?: Enumerable<company_documentsWhereUniqueInput>
    disconnect?: Enumerable<company_documentsWhereUniqueInput>
    delete?: Enumerable<company_documentsWhereUniqueInput>
    update?: Enumerable<company_documentsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<company_documentsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<company_documentsScalarWhereInput>
    upsert?: Enumerable<company_documentsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<company_documentsCreateOrConnectWithoutcompaniesInput>
  }

  export type company_membersUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_membersUncheckedCreateWithoutCompaniesInput>, Enumerable<company_membersCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_membersWhereUniqueInput>
    set?: Enumerable<company_membersWhereUniqueInput>
    disconnect?: Enumerable<company_membersWhereUniqueInput>
    delete?: Enumerable<company_membersWhereUniqueInput>
    update?: Enumerable<company_membersUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<company_membersUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<company_membersScalarWhereInput>
    upsert?: Enumerable<company_membersUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<company_membersCreateOrConnectWithoutcompaniesInput>
  }

  export type company_newsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_newsUncheckedCreateWithoutCompaniesInput>, Enumerable<company_newsCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_newsWhereUniqueInput>
    set?: Enumerable<company_newsWhereUniqueInput>
    disconnect?: Enumerable<company_newsWhereUniqueInput>
    delete?: Enumerable<company_newsWhereUniqueInput>
    update?: Enumerable<company_newsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<company_newsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<company_newsScalarWhereInput>
    upsert?: Enumerable<company_newsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<company_newsCreateOrConnectWithoutcompaniesInput>
  }

  export type demodaysUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<demodaysUncheckedCreateWithoutCompaniesInput>, Enumerable<demodaysCreateWithoutCompaniesInput>>
    connect?: Enumerable<demodaysWhereUniqueInput>
    set?: Enumerable<demodaysWhereUniqueInput>
    disconnect?: Enumerable<demodaysWhereUniqueInput>
    delete?: Enumerable<demodaysWhereUniqueInput>
    update?: Enumerable<demodaysUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<demodaysUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<demodaysScalarWhereInput>
    upsert?: Enumerable<demodaysUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<demodaysCreateOrConnectWithoutcompaniesInput>
  }

  export type IR_requestsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutCompaniesInput>, Enumerable<IR_requestsCreateWithoutCompaniesInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    set?: Enumerable<IR_requestsWhereUniqueInput>
    disconnect?: Enumerable<IR_requestsWhereUniqueInput>
    delete?: Enumerable<IR_requestsWhereUniqueInput>
    update?: Enumerable<IR_requestsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<IR_requestsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<IR_requestsScalarWhereInput>
    upsert?: Enumerable<IR_requestsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutcompaniesInput>
  }

  export type participantsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<participantsUncheckedCreateWithoutCompaniesInput>, Enumerable<participantsCreateWithoutCompaniesInput>>
    connect?: Enumerable<participantsWhereUniqueInput>
    set?: Enumerable<participantsWhereUniqueInput>
    disconnect?: Enumerable<participantsWhereUniqueInput>
    delete?: Enumerable<participantsWhereUniqueInput>
    update?: Enumerable<participantsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<participantsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<participantsScalarWhereInput>
    upsert?: Enumerable<participantsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<participantsCreateOrConnectWithoutcompaniesInput>
  }

  export type partnersUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutCompaniesInput>, Enumerable<partnersCreateWithoutCompaniesInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    set?: Enumerable<partnersWhereUniqueInput>
    disconnect?: Enumerable<partnersWhereUniqueInput>
    delete?: Enumerable<partnersWhereUniqueInput>
    update?: Enumerable<partnersUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<partnersUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<partnersScalarWhereInput>
    upsert?: Enumerable<partnersUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithoutcompaniesInput>
  }

  export type partner_likesUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<partner_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<partner_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<partner_likesWhereUniqueInput>
    set?: Enumerable<partner_likesWhereUniqueInput>
    disconnect?: Enumerable<partner_likesWhereUniqueInput>
    delete?: Enumerable<partner_likesWhereUniqueInput>
    update?: Enumerable<partner_likesUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<partner_likesUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<partner_likesScalarWhereInput>
    upsert?: Enumerable<partner_likesUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<partner_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type project_likesUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<project_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    set?: Enumerable<project_likesWhereUniqueInput>
    disconnect?: Enumerable<project_likesWhereUniqueInput>
    delete?: Enumerable<project_likesWhereUniqueInput>
    update?: Enumerable<project_likesUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<project_likesUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<project_likesScalarWhereInput>
    upsert?: Enumerable<project_likesUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type projectsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutCompaniesInput>, Enumerable<projectsCreateWithoutCompaniesInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    set?: Enumerable<projectsWhereUniqueInput>
    disconnect?: Enumerable<projectsWhereUniqueInput>
    delete?: Enumerable<projectsWhereUniqueInput>
    update?: Enumerable<projectsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<projectsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<projectsScalarWhereInput>
    upsert?: Enumerable<projectsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithoutcompaniesInput>
  }

  export type questionsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutCompaniesInput>, Enumerable<questionsCreateWithoutCompaniesInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    set?: Enumerable<questionsWhereUniqueInput>
    disconnect?: Enumerable<questionsWhereUniqueInput>
    delete?: Enumerable<questionsWhereUniqueInput>
    update?: Enumerable<questionsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<questionsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<questionsScalarWhereInput>
    upsert?: Enumerable<questionsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutcompaniesInput>
  }

  export type recent_views_projectUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<recent_views_projectUncheckedCreateWithoutCompaniesInput>, Enumerable<recent_views_projectCreateWithoutCompaniesInput>>
    connect?: Enumerable<recent_views_projectWhereUniqueInput>
    set?: Enumerable<recent_views_projectWhereUniqueInput>
    disconnect?: Enumerable<recent_views_projectWhereUniqueInput>
    delete?: Enumerable<recent_views_projectWhereUniqueInput>
    update?: Enumerable<recent_views_projectUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<recent_views_projectUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<recent_views_projectScalarWhereInput>
    upsert?: Enumerable<recent_views_projectUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<recent_views_projectCreateOrConnectWithoutcompaniesInput>
  }

  export type startupsUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutCompaniesInput>, Enumerable<startupsCreateWithoutCompaniesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutcompaniesInput>
  }

  export type startup_likesUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<startup_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<startup_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<startup_likesWhereUniqueInput>
    set?: Enumerable<startup_likesWhereUniqueInput>
    disconnect?: Enumerable<startup_likesWhereUniqueInput>
    delete?: Enumerable<startup_likesWhereUniqueInput>
    update?: Enumerable<startup_likesUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<startup_likesUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<startup_likesScalarWhereInput>
    upsert?: Enumerable<startup_likesUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<startup_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type usersUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutCompaniesInput>, Enumerable<usersCreateWithoutCompaniesInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutcompaniesInput>
  }

  export type applicantsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<applicantsUncheckedCreateWithoutCompaniesInput>, Enumerable<applicantsCreateWithoutCompaniesInput>>
    connect?: Enumerable<applicantsWhereUniqueInput>
    set?: Enumerable<applicantsWhereUniqueInput>
    disconnect?: Enumerable<applicantsWhereUniqueInput>
    delete?: Enumerable<applicantsWhereUniqueInput>
    update?: Enumerable<applicantsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<applicantsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<applicantsScalarWhereInput>
    upsert?: Enumerable<applicantsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<applicantsCreateOrConnectWithoutcompaniesInput>
  }

  export type company_documentsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_documentsUncheckedCreateWithoutCompaniesInput>, Enumerable<company_documentsCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_documentsWhereUniqueInput>
    set?: Enumerable<company_documentsWhereUniqueInput>
    disconnect?: Enumerable<company_documentsWhereUniqueInput>
    delete?: Enumerable<company_documentsWhereUniqueInput>
    update?: Enumerable<company_documentsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<company_documentsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<company_documentsScalarWhereInput>
    upsert?: Enumerable<company_documentsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<company_documentsCreateOrConnectWithoutcompaniesInput>
  }

  export type company_membersUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_membersUncheckedCreateWithoutCompaniesInput>, Enumerable<company_membersCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_membersWhereUniqueInput>
    set?: Enumerable<company_membersWhereUniqueInput>
    disconnect?: Enumerable<company_membersWhereUniqueInput>
    delete?: Enumerable<company_membersWhereUniqueInput>
    update?: Enumerable<company_membersUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<company_membersUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<company_membersScalarWhereInput>
    upsert?: Enumerable<company_membersUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<company_membersCreateOrConnectWithoutcompaniesInput>
  }

  export type company_newsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<company_newsUncheckedCreateWithoutCompaniesInput>, Enumerable<company_newsCreateWithoutCompaniesInput>>
    connect?: Enumerable<company_newsWhereUniqueInput>
    set?: Enumerable<company_newsWhereUniqueInput>
    disconnect?: Enumerable<company_newsWhereUniqueInput>
    delete?: Enumerable<company_newsWhereUniqueInput>
    update?: Enumerable<company_newsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<company_newsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<company_newsScalarWhereInput>
    upsert?: Enumerable<company_newsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<company_newsCreateOrConnectWithoutcompaniesInput>
  }

  export type demodaysUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<demodaysUncheckedCreateWithoutCompaniesInput>, Enumerable<demodaysCreateWithoutCompaniesInput>>
    connect?: Enumerable<demodaysWhereUniqueInput>
    set?: Enumerable<demodaysWhereUniqueInput>
    disconnect?: Enumerable<demodaysWhereUniqueInput>
    delete?: Enumerable<demodaysWhereUniqueInput>
    update?: Enumerable<demodaysUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<demodaysUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<demodaysScalarWhereInput>
    upsert?: Enumerable<demodaysUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<demodaysCreateOrConnectWithoutcompaniesInput>
  }

  export type IR_requestsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutCompaniesInput>, Enumerable<IR_requestsCreateWithoutCompaniesInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    set?: Enumerable<IR_requestsWhereUniqueInput>
    disconnect?: Enumerable<IR_requestsWhereUniqueInput>
    delete?: Enumerable<IR_requestsWhereUniqueInput>
    update?: Enumerable<IR_requestsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<IR_requestsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<IR_requestsScalarWhereInput>
    upsert?: Enumerable<IR_requestsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutcompaniesInput>
  }

  export type participantsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<participantsUncheckedCreateWithoutCompaniesInput>, Enumerable<participantsCreateWithoutCompaniesInput>>
    connect?: Enumerable<participantsWhereUniqueInput>
    set?: Enumerable<participantsWhereUniqueInput>
    disconnect?: Enumerable<participantsWhereUniqueInput>
    delete?: Enumerable<participantsWhereUniqueInput>
    update?: Enumerable<participantsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<participantsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<participantsScalarWhereInput>
    upsert?: Enumerable<participantsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<participantsCreateOrConnectWithoutcompaniesInput>
  }

  export type partnersUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutCompaniesInput>, Enumerable<partnersCreateWithoutCompaniesInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    set?: Enumerable<partnersWhereUniqueInput>
    disconnect?: Enumerable<partnersWhereUniqueInput>
    delete?: Enumerable<partnersWhereUniqueInput>
    update?: Enumerable<partnersUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<partnersUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<partnersScalarWhereInput>
    upsert?: Enumerable<partnersUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithoutcompaniesInput>
  }

  export type partner_likesUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<partner_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<partner_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<partner_likesWhereUniqueInput>
    set?: Enumerable<partner_likesWhereUniqueInput>
    disconnect?: Enumerable<partner_likesWhereUniqueInput>
    delete?: Enumerable<partner_likesWhereUniqueInput>
    update?: Enumerable<partner_likesUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<partner_likesUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<partner_likesScalarWhereInput>
    upsert?: Enumerable<partner_likesUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<partner_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type project_likesUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<project_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    set?: Enumerable<project_likesWhereUniqueInput>
    disconnect?: Enumerable<project_likesWhereUniqueInput>
    delete?: Enumerable<project_likesWhereUniqueInput>
    update?: Enumerable<project_likesUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<project_likesUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<project_likesScalarWhereInput>
    upsert?: Enumerable<project_likesUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type projectsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutCompaniesInput>, Enumerable<projectsCreateWithoutCompaniesInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    set?: Enumerable<projectsWhereUniqueInput>
    disconnect?: Enumerable<projectsWhereUniqueInput>
    delete?: Enumerable<projectsWhereUniqueInput>
    update?: Enumerable<projectsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<projectsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<projectsScalarWhereInput>
    upsert?: Enumerable<projectsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithoutcompaniesInput>
  }

  export type questionsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutCompaniesInput>, Enumerable<questionsCreateWithoutCompaniesInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    set?: Enumerable<questionsWhereUniqueInput>
    disconnect?: Enumerable<questionsWhereUniqueInput>
    delete?: Enumerable<questionsWhereUniqueInput>
    update?: Enumerable<questionsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<questionsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<questionsScalarWhereInput>
    upsert?: Enumerable<questionsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutcompaniesInput>
  }

  export type recent_views_projectUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<recent_views_projectUncheckedCreateWithoutCompaniesInput>, Enumerable<recent_views_projectCreateWithoutCompaniesInput>>
    connect?: Enumerable<recent_views_projectWhereUniqueInput>
    set?: Enumerable<recent_views_projectWhereUniqueInput>
    disconnect?: Enumerable<recent_views_projectWhereUniqueInput>
    delete?: Enumerable<recent_views_projectWhereUniqueInput>
    update?: Enumerable<recent_views_projectUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<recent_views_projectUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<recent_views_projectScalarWhereInput>
    upsert?: Enumerable<recent_views_projectUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<recent_views_projectCreateOrConnectWithoutcompaniesInput>
  }

  export type startupsUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutCompaniesInput>, Enumerable<startupsCreateWithoutCompaniesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutcompaniesInput>
  }

  export type startup_likesUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<startup_likesUncheckedCreateWithoutCompaniesInput>, Enumerable<startup_likesCreateWithoutCompaniesInput>>
    connect?: Enumerable<startup_likesWhereUniqueInput>
    set?: Enumerable<startup_likesWhereUniqueInput>
    disconnect?: Enumerable<startup_likesWhereUniqueInput>
    delete?: Enumerable<startup_likesWhereUniqueInput>
    update?: Enumerable<startup_likesUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<startup_likesUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<startup_likesScalarWhereInput>
    upsert?: Enumerable<startup_likesUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<startup_likesCreateOrConnectWithoutcompaniesInput>
  }

  export type usersUncheckedUpdateManyWithoutCompaniesInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutCompaniesInput>, Enumerable<usersCreateWithoutCompaniesInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutCompaniesInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutCompaniesInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutCompaniesInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutcompaniesInput>
  }

  export type companiesCreateOneWithoutCompany_documentsInput = {
    create?: XOR<companiesUncheckedCreateWithoutCompany_documentsInput, companiesCreateWithoutCompany_documentsInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutcompany_documentsInput
  }

  export type document_typesCreateOneWithoutCompany_documentsInput = {
    create?: XOR<document_typesUncheckedCreateWithoutCompany_documentsInput, document_typesCreateWithoutCompany_documentsInput>
    connect?: document_typesWhereUniqueInput
    connectOrCreate?: document_typesCreateOrConnectWithoutcompany_documentsInput
  }

  export type IR_requestsCreateManyWithoutCompany_documentsInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutCompany_documentsInput>, Enumerable<IR_requestsCreateWithoutCompany_documentsInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutcompany_documentsInput>
  }

  export type applicant_documentsCreateManyWithoutCompany_documentsInput = {
    create?: XOR<Enumerable<applicant_documentsUncheckedCreateWithoutCompany_documentsInput>, Enumerable<applicant_documentsCreateWithoutCompany_documentsInput>>
    connect?: Enumerable<applicant_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<applicant_documentsCreateOrConnectWithoutcompany_documentsInput>
  }

  export type IR_requestsUncheckedCreateManyWithoutCompany_documentsInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutCompany_documentsInput>, Enumerable<IR_requestsCreateWithoutCompany_documentsInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutcompany_documentsInput>
  }

  export type applicant_documentsUncheckedCreateManyWithoutCompany_documentsInput = {
    create?: XOR<Enumerable<applicant_documentsUncheckedCreateWithoutCompany_documentsInput>, Enumerable<applicant_documentsCreateWithoutCompany_documentsInput>>
    connect?: Enumerable<applicant_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<applicant_documentsCreateOrConnectWithoutcompany_documentsInput>
  }

  export type companiesUpdateOneRequiredWithoutCompany_documentsInput = {
    create?: XOR<companiesUncheckedCreateWithoutCompany_documentsInput, companiesCreateWithoutCompany_documentsInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutCompany_documentsInput, companiesUpdateWithoutCompany_documentsInput>
    upsert?: companiesUpsertWithoutCompany_documentsInput
    connectOrCreate?: companiesCreateOrConnectWithoutcompany_documentsInput
  }

  export type document_typesUpdateOneRequiredWithoutCompany_documentsInput = {
    create?: XOR<document_typesUncheckedCreateWithoutCompany_documentsInput, document_typesCreateWithoutCompany_documentsInput>
    connect?: document_typesWhereUniqueInput
    update?: XOR<document_typesUncheckedUpdateWithoutCompany_documentsInput, document_typesUpdateWithoutCompany_documentsInput>
    upsert?: document_typesUpsertWithoutCompany_documentsInput
    connectOrCreate?: document_typesCreateOrConnectWithoutcompany_documentsInput
  }

  export type IR_requestsUpdateManyWithoutCompany_documentsInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutCompany_documentsInput>, Enumerable<IR_requestsCreateWithoutCompany_documentsInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    set?: Enumerable<IR_requestsWhereUniqueInput>
    disconnect?: Enumerable<IR_requestsWhereUniqueInput>
    delete?: Enumerable<IR_requestsWhereUniqueInput>
    update?: Enumerable<IR_requestsUpdateWithWhereUniqueWithoutCompany_documentsInput>
    updateMany?: Enumerable<IR_requestsUpdateManyWithWhereWithoutCompany_documentsInput>
    deleteMany?: Enumerable<IR_requestsScalarWhereInput>
    upsert?: Enumerable<IR_requestsUpsertWithWhereUniqueWithoutCompany_documentsInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutcompany_documentsInput>
  }

  export type applicant_documentsUpdateManyWithoutCompany_documentsInput = {
    create?: XOR<Enumerable<applicant_documentsUncheckedCreateWithoutCompany_documentsInput>, Enumerable<applicant_documentsCreateWithoutCompany_documentsInput>>
    connect?: Enumerable<applicant_documentsWhereUniqueInput>
    set?: Enumerable<applicant_documentsWhereUniqueInput>
    disconnect?: Enumerable<applicant_documentsWhereUniqueInput>
    delete?: Enumerable<applicant_documentsWhereUniqueInput>
    update?: Enumerable<applicant_documentsUpdateWithWhereUniqueWithoutCompany_documentsInput>
    updateMany?: Enumerable<applicant_documentsUpdateManyWithWhereWithoutCompany_documentsInput>
    deleteMany?: Enumerable<applicant_documentsScalarWhereInput>
    upsert?: Enumerable<applicant_documentsUpsertWithWhereUniqueWithoutCompany_documentsInput>
    connectOrCreate?: Enumerable<applicant_documentsCreateOrConnectWithoutcompany_documentsInput>
  }

  export type IR_requestsUncheckedUpdateManyWithoutCompany_documentsInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutCompany_documentsInput>, Enumerable<IR_requestsCreateWithoutCompany_documentsInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    set?: Enumerable<IR_requestsWhereUniqueInput>
    disconnect?: Enumerable<IR_requestsWhereUniqueInput>
    delete?: Enumerable<IR_requestsWhereUniqueInput>
    update?: Enumerable<IR_requestsUpdateWithWhereUniqueWithoutCompany_documentsInput>
    updateMany?: Enumerable<IR_requestsUpdateManyWithWhereWithoutCompany_documentsInput>
    deleteMany?: Enumerable<IR_requestsScalarWhereInput>
    upsert?: Enumerable<IR_requestsUpsertWithWhereUniqueWithoutCompany_documentsInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutcompany_documentsInput>
  }

  export type applicant_documentsUncheckedUpdateManyWithoutCompany_documentsInput = {
    create?: XOR<Enumerable<applicant_documentsUncheckedCreateWithoutCompany_documentsInput>, Enumerable<applicant_documentsCreateWithoutCompany_documentsInput>>
    connect?: Enumerable<applicant_documentsWhereUniqueInput>
    set?: Enumerable<applicant_documentsWhereUniqueInput>
    disconnect?: Enumerable<applicant_documentsWhereUniqueInput>
    delete?: Enumerable<applicant_documentsWhereUniqueInput>
    update?: Enumerable<applicant_documentsUpdateWithWhereUniqueWithoutCompany_documentsInput>
    updateMany?: Enumerable<applicant_documentsUpdateManyWithWhereWithoutCompany_documentsInput>
    deleteMany?: Enumerable<applicant_documentsScalarWhereInput>
    upsert?: Enumerable<applicant_documentsUpsertWithWhereUniqueWithoutCompany_documentsInput>
    connectOrCreate?: Enumerable<applicant_documentsCreateOrConnectWithoutcompany_documentsInput>
  }

  export type companiesCreateOneWithoutCompany_membersInput = {
    create?: XOR<companiesUncheckedCreateWithoutCompany_membersInput, companiesCreateWithoutCompany_membersInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutcompany_membersInput
  }

  export type companiesUpdateOneWithoutCompany_membersInput = {
    create?: XOR<companiesUncheckedCreateWithoutCompany_membersInput, companiesCreateWithoutCompany_membersInput>
    connect?: companiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<companiesUncheckedUpdateWithoutCompany_membersInput, companiesUpdateWithoutCompany_membersInput>
    upsert?: companiesUpsertWithoutCompany_membersInput
    connectOrCreate?: companiesCreateOrConnectWithoutcompany_membersInput
  }

  export type companiesCreateOneWithoutCompany_newsInput = {
    create?: XOR<companiesUncheckedCreateWithoutCompany_newsInput, companiesCreateWithoutCompany_newsInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutcompany_newsInput
  }

  export type companiesUpdateOneRequiredWithoutCompany_newsInput = {
    create?: XOR<companiesUncheckedCreateWithoutCompany_newsInput, companiesCreateWithoutCompany_newsInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutCompany_newsInput, companiesUpdateWithoutCompany_newsInput>
    upsert?: companiesUpsertWithoutCompany_newsInput
    connectOrCreate?: companiesCreateOrConnectWithoutcompany_newsInput
  }

  export type companiesCreateManyWithoutCompany_typesInput = {
    create?: XOR<Enumerable<companiesUncheckedCreateWithoutCompany_typesInput>, Enumerable<companiesCreateWithoutCompany_typesInput>>
    connect?: Enumerable<companiesWhereUniqueInput>
    connectOrCreate?: Enumerable<companiesCreateOrConnectWithoutcompany_typesInput>
  }

  export type companiesUncheckedCreateManyWithoutCompany_typesInput = {
    create?: XOR<Enumerable<companiesUncheckedCreateWithoutCompany_typesInput>, Enumerable<companiesCreateWithoutCompany_typesInput>>
    connect?: Enumerable<companiesWhereUniqueInput>
    connectOrCreate?: Enumerable<companiesCreateOrConnectWithoutcompany_typesInput>
  }

  export type companiesUpdateManyWithoutCompany_typesInput = {
    create?: XOR<Enumerable<companiesUncheckedCreateWithoutCompany_typesInput>, Enumerable<companiesCreateWithoutCompany_typesInput>>
    connect?: Enumerable<companiesWhereUniqueInput>
    set?: Enumerable<companiesWhereUniqueInput>
    disconnect?: Enumerable<companiesWhereUniqueInput>
    delete?: Enumerable<companiesWhereUniqueInput>
    update?: Enumerable<companiesUpdateWithWhereUniqueWithoutCompany_typesInput>
    updateMany?: Enumerable<companiesUpdateManyWithWhereWithoutCompany_typesInput>
    deleteMany?: Enumerable<companiesScalarWhereInput>
    upsert?: Enumerable<companiesUpsertWithWhereUniqueWithoutCompany_typesInput>
    connectOrCreate?: Enumerable<companiesCreateOrConnectWithoutcompany_typesInput>
  }

  export type companiesUncheckedUpdateManyWithoutCompany_typesInput = {
    create?: XOR<Enumerable<companiesUncheckedCreateWithoutCompany_typesInput>, Enumerable<companiesCreateWithoutCompany_typesInput>>
    connect?: Enumerable<companiesWhereUniqueInput>
    set?: Enumerable<companiesWhereUniqueInput>
    disconnect?: Enumerable<companiesWhereUniqueInput>
    delete?: Enumerable<companiesWhereUniqueInput>
    update?: Enumerable<companiesUpdateWithWhereUniqueWithoutCompany_typesInput>
    updateMany?: Enumerable<companiesUpdateManyWithWhereWithoutCompany_typesInput>
    deleteMany?: Enumerable<companiesScalarWhereInput>
    upsert?: Enumerable<companiesUpsertWithWhereUniqueWithoutCompany_typesInput>
    connectOrCreate?: Enumerable<companiesCreateOrConnectWithoutcompany_typesInput>
  }

  export type companiesCreateOneWithoutDemodaysInput = {
    create?: XOR<companiesUncheckedCreateWithoutDemodaysInput, companiesCreateWithoutDemodaysInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutdemodaysInput
  }

  export type participantsCreateManyWithoutDemodaysInput = {
    create?: XOR<Enumerable<participantsUncheckedCreateWithoutDemodaysInput>, Enumerable<participantsCreateWithoutDemodaysInput>>
    connect?: Enumerable<participantsWhereUniqueInput>
    connectOrCreate?: Enumerable<participantsCreateOrConnectWithoutdemodaysInput>
  }

  export type questionsCreateManyWithoutDemodaysInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutDemodaysInput>, Enumerable<questionsCreateWithoutDemodaysInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutdemodaysInput>
  }

  export type participantsUncheckedCreateManyWithoutDemodaysInput = {
    create?: XOR<Enumerable<participantsUncheckedCreateWithoutDemodaysInput>, Enumerable<participantsCreateWithoutDemodaysInput>>
    connect?: Enumerable<participantsWhereUniqueInput>
    connectOrCreate?: Enumerable<participantsCreateOrConnectWithoutdemodaysInput>
  }

  export type questionsUncheckedCreateManyWithoutDemodaysInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutDemodaysInput>, Enumerable<questionsCreateWithoutDemodaysInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutdemodaysInput>
  }

  export type companiesUpdateOneWithoutDemodaysInput = {
    create?: XOR<companiesUncheckedCreateWithoutDemodaysInput, companiesCreateWithoutDemodaysInput>
    connect?: companiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<companiesUncheckedUpdateWithoutDemodaysInput, companiesUpdateWithoutDemodaysInput>
    upsert?: companiesUpsertWithoutDemodaysInput
    connectOrCreate?: companiesCreateOrConnectWithoutdemodaysInput
  }

  export type participantsUpdateManyWithoutDemodaysInput = {
    create?: XOR<Enumerable<participantsUncheckedCreateWithoutDemodaysInput>, Enumerable<participantsCreateWithoutDemodaysInput>>
    connect?: Enumerable<participantsWhereUniqueInput>
    set?: Enumerable<participantsWhereUniqueInput>
    disconnect?: Enumerable<participantsWhereUniqueInput>
    delete?: Enumerable<participantsWhereUniqueInput>
    update?: Enumerable<participantsUpdateWithWhereUniqueWithoutDemodaysInput>
    updateMany?: Enumerable<participantsUpdateManyWithWhereWithoutDemodaysInput>
    deleteMany?: Enumerable<participantsScalarWhereInput>
    upsert?: Enumerable<participantsUpsertWithWhereUniqueWithoutDemodaysInput>
    connectOrCreate?: Enumerable<participantsCreateOrConnectWithoutdemodaysInput>
  }

  export type questionsUpdateManyWithoutDemodaysInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutDemodaysInput>, Enumerable<questionsCreateWithoutDemodaysInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    set?: Enumerable<questionsWhereUniqueInput>
    disconnect?: Enumerable<questionsWhereUniqueInput>
    delete?: Enumerable<questionsWhereUniqueInput>
    update?: Enumerable<questionsUpdateWithWhereUniqueWithoutDemodaysInput>
    updateMany?: Enumerable<questionsUpdateManyWithWhereWithoutDemodaysInput>
    deleteMany?: Enumerable<questionsScalarWhereInput>
    upsert?: Enumerable<questionsUpsertWithWhereUniqueWithoutDemodaysInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutdemodaysInput>
  }

  export type participantsUncheckedUpdateManyWithoutDemodaysInput = {
    create?: XOR<Enumerable<participantsUncheckedCreateWithoutDemodaysInput>, Enumerable<participantsCreateWithoutDemodaysInput>>
    connect?: Enumerable<participantsWhereUniqueInput>
    set?: Enumerable<participantsWhereUniqueInput>
    disconnect?: Enumerable<participantsWhereUniqueInput>
    delete?: Enumerable<participantsWhereUniqueInput>
    update?: Enumerable<participantsUpdateWithWhereUniqueWithoutDemodaysInput>
    updateMany?: Enumerable<participantsUpdateManyWithWhereWithoutDemodaysInput>
    deleteMany?: Enumerable<participantsScalarWhereInput>
    upsert?: Enumerable<participantsUpsertWithWhereUniqueWithoutDemodaysInput>
    connectOrCreate?: Enumerable<participantsCreateOrConnectWithoutdemodaysInput>
  }

  export type questionsUncheckedUpdateManyWithoutDemodaysInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutDemodaysInput>, Enumerable<questionsCreateWithoutDemodaysInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    set?: Enumerable<questionsWhereUniqueInput>
    disconnect?: Enumerable<questionsWhereUniqueInput>
    delete?: Enumerable<questionsWhereUniqueInput>
    update?: Enumerable<questionsUpdateWithWhereUniqueWithoutDemodaysInput>
    updateMany?: Enumerable<questionsUpdateManyWithWhereWithoutDemodaysInput>
    deleteMany?: Enumerable<questionsScalarWhereInput>
    upsert?: Enumerable<questionsUpsertWithWhereUniqueWithoutDemodaysInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutdemodaysInput>
  }

  export type company_documentsCreateManyWithoutDocument_typesInput = {
    create?: XOR<Enumerable<company_documentsUncheckedCreateWithoutDocument_typesInput>, Enumerable<company_documentsCreateWithoutDocument_typesInput>>
    connect?: Enumerable<company_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<company_documentsCreateOrConnectWithoutdocument_typesInput>
  }

  export type required_documentsCreateManyWithoutDocument_typesInput = {
    create?: XOR<Enumerable<required_documentsUncheckedCreateWithoutDocument_typesInput>, Enumerable<required_documentsCreateWithoutDocument_typesInput>>
    connect?: Enumerable<required_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<required_documentsCreateOrConnectWithoutdocument_typesInput>
  }

  export type company_documentsUncheckedCreateManyWithoutDocument_typesInput = {
    create?: XOR<Enumerable<company_documentsUncheckedCreateWithoutDocument_typesInput>, Enumerable<company_documentsCreateWithoutDocument_typesInput>>
    connect?: Enumerable<company_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<company_documentsCreateOrConnectWithoutdocument_typesInput>
  }

  export type required_documentsUncheckedCreateManyWithoutDocument_typesInput = {
    create?: XOR<Enumerable<required_documentsUncheckedCreateWithoutDocument_typesInput>, Enumerable<required_documentsCreateWithoutDocument_typesInput>>
    connect?: Enumerable<required_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<required_documentsCreateOrConnectWithoutdocument_typesInput>
  }

  export type company_documentsUpdateManyWithoutDocument_typesInput = {
    create?: XOR<Enumerable<company_documentsUncheckedCreateWithoutDocument_typesInput>, Enumerable<company_documentsCreateWithoutDocument_typesInput>>
    connect?: Enumerable<company_documentsWhereUniqueInput>
    set?: Enumerable<company_documentsWhereUniqueInput>
    disconnect?: Enumerable<company_documentsWhereUniqueInput>
    delete?: Enumerable<company_documentsWhereUniqueInput>
    update?: Enumerable<company_documentsUpdateWithWhereUniqueWithoutDocument_typesInput>
    updateMany?: Enumerable<company_documentsUpdateManyWithWhereWithoutDocument_typesInput>
    deleteMany?: Enumerable<company_documentsScalarWhereInput>
    upsert?: Enumerable<company_documentsUpsertWithWhereUniqueWithoutDocument_typesInput>
    connectOrCreate?: Enumerable<company_documentsCreateOrConnectWithoutdocument_typesInput>
  }

  export type required_documentsUpdateManyWithoutDocument_typesInput = {
    create?: XOR<Enumerable<required_documentsUncheckedCreateWithoutDocument_typesInput>, Enumerable<required_documentsCreateWithoutDocument_typesInput>>
    connect?: Enumerable<required_documentsWhereUniqueInput>
    set?: Enumerable<required_documentsWhereUniqueInput>
    disconnect?: Enumerable<required_documentsWhereUniqueInput>
    delete?: Enumerable<required_documentsWhereUniqueInput>
    update?: Enumerable<required_documentsUpdateWithWhereUniqueWithoutDocument_typesInput>
    updateMany?: Enumerable<required_documentsUpdateManyWithWhereWithoutDocument_typesInput>
    deleteMany?: Enumerable<required_documentsScalarWhereInput>
    upsert?: Enumerable<required_documentsUpsertWithWhereUniqueWithoutDocument_typesInput>
    connectOrCreate?: Enumerable<required_documentsCreateOrConnectWithoutdocument_typesInput>
  }

  export type company_documentsUncheckedUpdateManyWithoutDocument_typesInput = {
    create?: XOR<Enumerable<company_documentsUncheckedCreateWithoutDocument_typesInput>, Enumerable<company_documentsCreateWithoutDocument_typesInput>>
    connect?: Enumerable<company_documentsWhereUniqueInput>
    set?: Enumerable<company_documentsWhereUniqueInput>
    disconnect?: Enumerable<company_documentsWhereUniqueInput>
    delete?: Enumerable<company_documentsWhereUniqueInput>
    update?: Enumerable<company_documentsUpdateWithWhereUniqueWithoutDocument_typesInput>
    updateMany?: Enumerable<company_documentsUpdateManyWithWhereWithoutDocument_typesInput>
    deleteMany?: Enumerable<company_documentsScalarWhereInput>
    upsert?: Enumerable<company_documentsUpsertWithWhereUniqueWithoutDocument_typesInput>
    connectOrCreate?: Enumerable<company_documentsCreateOrConnectWithoutdocument_typesInput>
  }

  export type required_documentsUncheckedUpdateManyWithoutDocument_typesInput = {
    create?: XOR<Enumerable<required_documentsUncheckedCreateWithoutDocument_typesInput>, Enumerable<required_documentsCreateWithoutDocument_typesInput>>
    connect?: Enumerable<required_documentsWhereUniqueInput>
    set?: Enumerable<required_documentsWhereUniqueInput>
    disconnect?: Enumerable<required_documentsWhereUniqueInput>
    delete?: Enumerable<required_documentsWhereUniqueInput>
    update?: Enumerable<required_documentsUpdateWithWhereUniqueWithoutDocument_typesInput>
    updateMany?: Enumerable<required_documentsUpdateManyWithWhereWithoutDocument_typesInput>
    deleteMany?: Enumerable<required_documentsScalarWhereInput>
    upsert?: Enumerable<required_documentsUpsertWithWhereUniqueWithoutDocument_typesInput>
    connectOrCreate?: Enumerable<required_documentsCreateOrConnectWithoutdocument_typesInput>
  }

  export type projectsCreateManyWithoutEligibilitiesInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutEligibilitiesInput>, Enumerable<projectsCreateWithoutEligibilitiesInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithouteligibilitiesInput>
  }

  export type projectsUncheckedCreateManyWithoutEligibilitiesInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutEligibilitiesInput>, Enumerable<projectsCreateWithoutEligibilitiesInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithouteligibilitiesInput>
  }

  export type projectsUpdateManyWithoutEligibilitiesInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutEligibilitiesInput>, Enumerable<projectsCreateWithoutEligibilitiesInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    set?: Enumerable<projectsWhereUniqueInput>
    disconnect?: Enumerable<projectsWhereUniqueInput>
    delete?: Enumerable<projectsWhereUniqueInput>
    update?: Enumerable<projectsUpdateWithWhereUniqueWithoutEligibilitiesInput>
    updateMany?: Enumerable<projectsUpdateManyWithWhereWithoutEligibilitiesInput>
    deleteMany?: Enumerable<projectsScalarWhereInput>
    upsert?: Enumerable<projectsUpsertWithWhereUniqueWithoutEligibilitiesInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithouteligibilitiesInput>
  }

  export type projectsUncheckedUpdateManyWithoutEligibilitiesInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutEligibilitiesInput>, Enumerable<projectsCreateWithoutEligibilitiesInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    set?: Enumerable<projectsWhereUniqueInput>
    disconnect?: Enumerable<projectsWhereUniqueInput>
    delete?: Enumerable<projectsWhereUniqueInput>
    update?: Enumerable<projectsUpdateWithWhereUniqueWithoutEligibilitiesInput>
    updateMany?: Enumerable<projectsUpdateManyWithWhereWithoutEligibilitiesInput>
    deleteMany?: Enumerable<projectsScalarWhereInput>
    upsert?: Enumerable<projectsUpsertWithWhereUniqueWithoutEligibilitiesInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithouteligibilitiesInput>
  }

  export type projectsCreateManyWithoutEligible_sectorsInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutEligible_sectorsInput>, Enumerable<projectsCreateWithoutEligible_sectorsInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithouteligible_sectorsInput>
  }

  export type projectsUncheckedCreateManyWithoutEligible_sectorsInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutEligible_sectorsInput>, Enumerable<projectsCreateWithoutEligible_sectorsInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithouteligible_sectorsInput>
  }

  export type projectsUpdateManyWithoutEligible_sectorsInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutEligible_sectorsInput>, Enumerable<projectsCreateWithoutEligible_sectorsInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    set?: Enumerable<projectsWhereUniqueInput>
    disconnect?: Enumerable<projectsWhereUniqueInput>
    delete?: Enumerable<projectsWhereUniqueInput>
    update?: Enumerable<projectsUpdateWithWhereUniqueWithoutEligible_sectorsInput>
    updateMany?: Enumerable<projectsUpdateManyWithWhereWithoutEligible_sectorsInput>
    deleteMany?: Enumerable<projectsScalarWhereInput>
    upsert?: Enumerable<projectsUpsertWithWhereUniqueWithoutEligible_sectorsInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithouteligible_sectorsInput>
  }

  export type projectsUncheckedUpdateManyWithoutEligible_sectorsInput = {
    create?: XOR<Enumerable<projectsUncheckedCreateWithoutEligible_sectorsInput>, Enumerable<projectsCreateWithoutEligible_sectorsInput>>
    connect?: Enumerable<projectsWhereUniqueInput>
    set?: Enumerable<projectsWhereUniqueInput>
    disconnect?: Enumerable<projectsWhereUniqueInput>
    delete?: Enumerable<projectsWhereUniqueInput>
    update?: Enumerable<projectsUpdateWithWhereUniqueWithoutEligible_sectorsInput>
    updateMany?: Enumerable<projectsUpdateManyWithWhereWithoutEligible_sectorsInput>
    deleteMany?: Enumerable<projectsScalarWhereInput>
    upsert?: Enumerable<projectsUpsertWithWhereUniqueWithoutEligible_sectorsInput>
    connectOrCreate?: Enumerable<projectsCreateOrConnectWithouteligible_sectorsInput>
  }

  export type investment_seriesCreateOneWithoutInvested_fromInput = {
    create?: XOR<investment_seriesUncheckedCreateWithoutInvested_fromInput, investment_seriesCreateWithoutInvested_fromInput>
    connect?: investment_seriesWhereUniqueInput
    connectOrCreate?: investment_seriesCreateOrConnectWithoutinvested_fromInput
  }

  export type investment_fundsCreateOneWithoutInvested_fromInput = {
    create?: XOR<investment_fundsUncheckedCreateWithoutInvested_fromInput, investment_fundsCreateWithoutInvested_fromInput>
    connect?: investment_fundsWhereUniqueInput
    connectOrCreate?: investment_fundsCreateOrConnectWithoutinvested_fromInput
  }

  export type startupsCreateOneWithoutInvested_fromInput = {
    create?: XOR<startupsUncheckedCreateWithoutInvested_fromInput, startupsCreateWithoutInvested_fromInput>
    connect?: startupsWhereUniqueInput
    connectOrCreate?: startupsCreateOrConnectWithoutinvested_fromInput
  }

  export type investment_seriesUpdateOneRequiredWithoutInvested_fromInput = {
    create?: XOR<investment_seriesUncheckedCreateWithoutInvested_fromInput, investment_seriesCreateWithoutInvested_fromInput>
    connect?: investment_seriesWhereUniqueInput
    update?: XOR<investment_seriesUncheckedUpdateWithoutInvested_fromInput, investment_seriesUpdateWithoutInvested_fromInput>
    upsert?: investment_seriesUpsertWithoutInvested_fromInput
    connectOrCreate?: investment_seriesCreateOrConnectWithoutinvested_fromInput
  }

  export type investment_fundsUpdateOneRequiredWithoutInvested_fromInput = {
    create?: XOR<investment_fundsUncheckedCreateWithoutInvested_fromInput, investment_fundsCreateWithoutInvested_fromInput>
    connect?: investment_fundsWhereUniqueInput
    update?: XOR<investment_fundsUncheckedUpdateWithoutInvested_fromInput, investment_fundsUpdateWithoutInvested_fromInput>
    upsert?: investment_fundsUpsertWithoutInvested_fromInput
    connectOrCreate?: investment_fundsCreateOrConnectWithoutinvested_fromInput
  }

  export type startupsUpdateOneRequiredWithoutInvested_fromInput = {
    create?: XOR<startupsUncheckedCreateWithoutInvested_fromInput, startupsCreateWithoutInvested_fromInput>
    connect?: startupsWhereUniqueInput
    update?: XOR<startupsUncheckedUpdateWithoutInvested_fromInput, startupsUpdateWithoutInvested_fromInput>
    upsert?: startupsUpsertWithoutInvested_fromInput
    connectOrCreate?: startupsCreateOrConnectWithoutinvested_fromInput
  }

  export type investment_seriesCreateOneWithoutInvested_toInput = {
    create?: XOR<investment_seriesUncheckedCreateWithoutInvested_toInput, investment_seriesCreateWithoutInvested_toInput>
    connect?: investment_seriesWhereUniqueInput
    connectOrCreate?: investment_seriesCreateOrConnectWithoutinvested_toInput
  }

  export type investment_fundsCreateOneWithoutInvested_toInput = {
    create?: XOR<investment_fundsUncheckedCreateWithoutInvested_toInput, investment_fundsCreateWithoutInvested_toInput>
    connect?: investment_fundsWhereUniqueInput
    connectOrCreate?: investment_fundsCreateOrConnectWithoutinvested_toInput
  }

  export type partnersCreateOneWithoutInvested_toInput = {
    create?: XOR<partnersUncheckedCreateWithoutInvested_toInput, partnersCreateWithoutInvested_toInput>
    connect?: partnersWhereUniqueInput
    connectOrCreate?: partnersCreateOrConnectWithoutinvested_toInput
  }

  export type investment_seriesUpdateOneRequiredWithoutInvested_toInput = {
    create?: XOR<investment_seriesUncheckedCreateWithoutInvested_toInput, investment_seriesCreateWithoutInvested_toInput>
    connect?: investment_seriesWhereUniqueInput
    update?: XOR<investment_seriesUncheckedUpdateWithoutInvested_toInput, investment_seriesUpdateWithoutInvested_toInput>
    upsert?: investment_seriesUpsertWithoutInvested_toInput
    connectOrCreate?: investment_seriesCreateOrConnectWithoutinvested_toInput
  }

  export type investment_fundsUpdateOneRequiredWithoutInvested_toInput = {
    create?: XOR<investment_fundsUncheckedCreateWithoutInvested_toInput, investment_fundsCreateWithoutInvested_toInput>
    connect?: investment_fundsWhereUniqueInput
    update?: XOR<investment_fundsUncheckedUpdateWithoutInvested_toInput, investment_fundsUpdateWithoutInvested_toInput>
    upsert?: investment_fundsUpsertWithoutInvested_toInput
    connectOrCreate?: investment_fundsCreateOrConnectWithoutinvested_toInput
  }

  export type partnersUpdateOneRequiredWithoutInvested_toInput = {
    create?: XOR<partnersUncheckedCreateWithoutInvested_toInput, partnersCreateWithoutInvested_toInput>
    connect?: partnersWhereUniqueInput
    update?: XOR<partnersUncheckedUpdateWithoutInvested_toInput, partnersUpdateWithoutInvested_toInput>
    upsert?: partnersUpsertWithoutInvested_toInput
    connectOrCreate?: partnersCreateOrConnectWithoutinvested_toInput
  }

  export type partnersCreateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<partnersCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type startupsCreateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<startupsCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type invested_fromCreateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<invested_fromCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type invested_toCreateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<invested_toCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type partnersUncheckedCreateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<partnersCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type startupsUncheckedCreateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<startupsCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type invested_fromUncheckedCreateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<invested_fromCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type invested_toUncheckedCreateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<invested_toCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type partnersUpdateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<partnersCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    set?: Enumerable<partnersWhereUniqueInput>
    disconnect?: Enumerable<partnersWhereUniqueInput>
    delete?: Enumerable<partnersWhereUniqueInput>
    update?: Enumerable<partnersUpdateWithWhereUniqueWithoutInvestment_fundsInput>
    updateMany?: Enumerable<partnersUpdateManyWithWhereWithoutInvestment_fundsInput>
    deleteMany?: Enumerable<partnersScalarWhereInput>
    upsert?: Enumerable<partnersUpsertWithWhereUniqueWithoutInvestment_fundsInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type startupsUpdateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<startupsCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutInvestment_fundsInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutInvestment_fundsInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutInvestment_fundsInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type invested_fromUpdateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<invested_fromCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    set?: Enumerable<invested_fromWhereUniqueInput>
    disconnect?: Enumerable<invested_fromWhereUniqueInput>
    delete?: Enumerable<invested_fromWhereUniqueInput>
    update?: Enumerable<invested_fromUpdateWithWhereUniqueWithoutInvestment_fundsInput>
    updateMany?: Enumerable<invested_fromUpdateManyWithWhereWithoutInvestment_fundsInput>
    deleteMany?: Enumerable<invested_fromScalarWhereInput>
    upsert?: Enumerable<invested_fromUpsertWithWhereUniqueWithoutInvestment_fundsInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type invested_toUpdateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<invested_toCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    set?: Enumerable<invested_toWhereUniqueInput>
    disconnect?: Enumerable<invested_toWhereUniqueInput>
    delete?: Enumerable<invested_toWhereUniqueInput>
    update?: Enumerable<invested_toUpdateWithWhereUniqueWithoutInvestment_fundsInput>
    updateMany?: Enumerable<invested_toUpdateManyWithWhereWithoutInvestment_fundsInput>
    deleteMany?: Enumerable<invested_toScalarWhereInput>
    upsert?: Enumerable<invested_toUpsertWithWhereUniqueWithoutInvestment_fundsInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type partnersUncheckedUpdateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<partnersCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    set?: Enumerable<partnersWhereUniqueInput>
    disconnect?: Enumerable<partnersWhereUniqueInput>
    delete?: Enumerable<partnersWhereUniqueInput>
    update?: Enumerable<partnersUpdateWithWhereUniqueWithoutInvestment_fundsInput>
    updateMany?: Enumerable<partnersUpdateManyWithWhereWithoutInvestment_fundsInput>
    deleteMany?: Enumerable<partnersScalarWhereInput>
    upsert?: Enumerable<partnersUpsertWithWhereUniqueWithoutInvestment_fundsInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type startupsUncheckedUpdateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<startupsCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutInvestment_fundsInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutInvestment_fundsInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutInvestment_fundsInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type invested_fromUncheckedUpdateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<invested_fromCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    set?: Enumerable<invested_fromWhereUniqueInput>
    disconnect?: Enumerable<invested_fromWhereUniqueInput>
    delete?: Enumerable<invested_fromWhereUniqueInput>
    update?: Enumerable<invested_fromUpdateWithWhereUniqueWithoutInvestment_fundsInput>
    updateMany?: Enumerable<invested_fromUpdateManyWithWhereWithoutInvestment_fundsInput>
    deleteMany?: Enumerable<invested_fromScalarWhereInput>
    upsert?: Enumerable<invested_fromUpsertWithWhereUniqueWithoutInvestment_fundsInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type invested_toUncheckedUpdateManyWithoutInvestment_fundsInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutInvestment_fundsInput>, Enumerable<invested_toCreateWithoutInvestment_fundsInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    set?: Enumerable<invested_toWhereUniqueInput>
    disconnect?: Enumerable<invested_toWhereUniqueInput>
    delete?: Enumerable<invested_toWhereUniqueInput>
    update?: Enumerable<invested_toUpdateWithWhereUniqueWithoutInvestment_fundsInput>
    updateMany?: Enumerable<invested_toUpdateManyWithWhereWithoutInvestment_fundsInput>
    deleteMany?: Enumerable<invested_toScalarWhereInput>
    upsert?: Enumerable<invested_toUpsertWithWhereUniqueWithoutInvestment_fundsInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutinvestment_fundsInput>
  }

  export type partnersCreateOneWithoutInvestment_portfolioInput = {
    create?: XOR<partnersUncheckedCreateWithoutInvestment_portfolioInput, partnersCreateWithoutInvestment_portfolioInput>
    connect?: partnersWhereUniqueInput
    connectOrCreate?: partnersCreateOrConnectWithoutinvestment_portfolioInput
  }

  export type partnersUpdateOneRequiredWithoutInvestment_portfolioInput = {
    create?: XOR<partnersUncheckedCreateWithoutInvestment_portfolioInput, partnersCreateWithoutInvestment_portfolioInput>
    connect?: partnersWhereUniqueInput
    update?: XOR<partnersUncheckedUpdateWithoutInvestment_portfolioInput, partnersUpdateWithoutInvestment_portfolioInput>
    upsert?: partnersUpsertWithoutInvestment_portfolioInput
    connectOrCreate?: partnersCreateOrConnectWithoutinvestment_portfolioInput
  }

  export type invested_fromCreateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<invested_fromCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type invested_toCreateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<invested_toCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type startupsCreateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<startupsCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type wish_investment_seriesCreateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<wish_investment_seriesUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<wish_investment_seriesCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    connectOrCreate?: Enumerable<wish_investment_seriesCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type invested_fromUncheckedCreateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<invested_fromCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type invested_toUncheckedCreateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<invested_toCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type startupsUncheckedCreateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<startupsCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type wish_investment_seriesUncheckedCreateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<wish_investment_seriesUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<wish_investment_seriesCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    connectOrCreate?: Enumerable<wish_investment_seriesCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type invested_fromUpdateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<invested_fromCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    set?: Enumerable<invested_fromWhereUniqueInput>
    disconnect?: Enumerable<invested_fromWhereUniqueInput>
    delete?: Enumerable<invested_fromWhereUniqueInput>
    update?: Enumerable<invested_fromUpdateWithWhereUniqueWithoutInvestment_seriesInput>
    updateMany?: Enumerable<invested_fromUpdateManyWithWhereWithoutInvestment_seriesInput>
    deleteMany?: Enumerable<invested_fromScalarWhereInput>
    upsert?: Enumerable<invested_fromUpsertWithWhereUniqueWithoutInvestment_seriesInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type invested_toUpdateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<invested_toCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    set?: Enumerable<invested_toWhereUniqueInput>
    disconnect?: Enumerable<invested_toWhereUniqueInput>
    delete?: Enumerable<invested_toWhereUniqueInput>
    update?: Enumerable<invested_toUpdateWithWhereUniqueWithoutInvestment_seriesInput>
    updateMany?: Enumerable<invested_toUpdateManyWithWhereWithoutInvestment_seriesInput>
    deleteMany?: Enumerable<invested_toScalarWhereInput>
    upsert?: Enumerable<invested_toUpsertWithWhereUniqueWithoutInvestment_seriesInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type startupsUpdateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<startupsCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutInvestment_seriesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutInvestment_seriesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutInvestment_seriesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type wish_investment_seriesUpdateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<wish_investment_seriesUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<wish_investment_seriesCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    set?: Enumerable<wish_investment_seriesWhereUniqueInput>
    disconnect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    delete?: Enumerable<wish_investment_seriesWhereUniqueInput>
    update?: Enumerable<wish_investment_seriesUpdateWithWhereUniqueWithoutInvestment_seriesInput>
    updateMany?: Enumerable<wish_investment_seriesUpdateManyWithWhereWithoutInvestment_seriesInput>
    deleteMany?: Enumerable<wish_investment_seriesScalarWhereInput>
    upsert?: Enumerable<wish_investment_seriesUpsertWithWhereUniqueWithoutInvestment_seriesInput>
    connectOrCreate?: Enumerable<wish_investment_seriesCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type invested_fromUncheckedUpdateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<invested_fromCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    set?: Enumerable<invested_fromWhereUniqueInput>
    disconnect?: Enumerable<invested_fromWhereUniqueInput>
    delete?: Enumerable<invested_fromWhereUniqueInput>
    update?: Enumerable<invested_fromUpdateWithWhereUniqueWithoutInvestment_seriesInput>
    updateMany?: Enumerable<invested_fromUpdateManyWithWhereWithoutInvestment_seriesInput>
    deleteMany?: Enumerable<invested_fromScalarWhereInput>
    upsert?: Enumerable<invested_fromUpsertWithWhereUniqueWithoutInvestment_seriesInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type invested_toUncheckedUpdateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<invested_toCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    set?: Enumerable<invested_toWhereUniqueInput>
    disconnect?: Enumerable<invested_toWhereUniqueInput>
    delete?: Enumerable<invested_toWhereUniqueInput>
    update?: Enumerable<invested_toUpdateWithWhereUniqueWithoutInvestment_seriesInput>
    updateMany?: Enumerable<invested_toUpdateManyWithWhereWithoutInvestment_seriesInput>
    deleteMany?: Enumerable<invested_toScalarWhereInput>
    upsert?: Enumerable<invested_toUpsertWithWhereUniqueWithoutInvestment_seriesInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type startupsUncheckedUpdateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<startupsCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutInvestment_seriesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutInvestment_seriesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutInvestment_seriesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type wish_investment_seriesUncheckedUpdateManyWithoutInvestment_seriesInput = {
    create?: XOR<Enumerable<wish_investment_seriesUncheckedCreateWithoutInvestment_seriesInput>, Enumerable<wish_investment_seriesCreateWithoutInvestment_seriesInput>>
    connect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    set?: Enumerable<wish_investment_seriesWhereUniqueInput>
    disconnect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    delete?: Enumerable<wish_investment_seriesWhereUniqueInput>
    update?: Enumerable<wish_investment_seriesUpdateWithWhereUniqueWithoutInvestment_seriesInput>
    updateMany?: Enumerable<wish_investment_seriesUpdateManyWithWhereWithoutInvestment_seriesInput>
    deleteMany?: Enumerable<wish_investment_seriesScalarWhereInput>
    upsert?: Enumerable<wish_investment_seriesUpsertWithWhereUniqueWithoutInvestment_seriesInput>
    connectOrCreate?: Enumerable<wish_investment_seriesCreateOrConnectWithoutinvestment_seriesInput>
  }

  export type company_documentsCreateOneWithoutIR_requestsInput = {
    create?: XOR<company_documentsUncheckedCreateWithoutIR_requestsInput, company_documentsCreateWithoutIR_requestsInput>
    connect?: company_documentsWhereUniqueInput
    connectOrCreate?: company_documentsCreateOrConnectWithoutIR_requestsInput
  }

  export type partnersCreateOneWithoutIR_requestsInput = {
    create?: XOR<partnersUncheckedCreateWithoutIR_requestsInput, partnersCreateWithoutIR_requestsInput>
    connect?: partnersWhereUniqueInput
    connectOrCreate?: partnersCreateOrConnectWithoutIR_requestsInput
  }

  export type startupsCreateOneWithoutIR_requestsInput = {
    create?: XOR<startupsUncheckedCreateWithoutIR_requestsInput, startupsCreateWithoutIR_requestsInput>
    connect?: startupsWhereUniqueInput
    connectOrCreate?: startupsCreateOrConnectWithoutIR_requestsInput
  }

  export type companiesCreateOneWithoutIR_requestsInput = {
    create?: XOR<companiesUncheckedCreateWithoutIR_requestsInput, companiesCreateWithoutIR_requestsInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutIR_requestsInput
  }

  export type company_documentsUpdateOneWithoutIR_requestsInput = {
    create?: XOR<company_documentsUncheckedCreateWithoutIR_requestsInput, company_documentsCreateWithoutIR_requestsInput>
    connect?: company_documentsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<company_documentsUncheckedUpdateWithoutIR_requestsInput, company_documentsUpdateWithoutIR_requestsInput>
    upsert?: company_documentsUpsertWithoutIR_requestsInput
    connectOrCreate?: company_documentsCreateOrConnectWithoutIR_requestsInput
  }

  export type partnersUpdateOneRequiredWithoutIR_requestsInput = {
    create?: XOR<partnersUncheckedCreateWithoutIR_requestsInput, partnersCreateWithoutIR_requestsInput>
    connect?: partnersWhereUniqueInput
    update?: XOR<partnersUncheckedUpdateWithoutIR_requestsInput, partnersUpdateWithoutIR_requestsInput>
    upsert?: partnersUpsertWithoutIR_requestsInput
    connectOrCreate?: partnersCreateOrConnectWithoutIR_requestsInput
  }

  export type startupsUpdateOneRequiredWithoutIR_requestsInput = {
    create?: XOR<startupsUncheckedCreateWithoutIR_requestsInput, startupsCreateWithoutIR_requestsInput>
    connect?: startupsWhereUniqueInput
    update?: XOR<startupsUncheckedUpdateWithoutIR_requestsInput, startupsUpdateWithoutIR_requestsInput>
    upsert?: startupsUpsertWithoutIR_requestsInput
    connectOrCreate?: startupsCreateOrConnectWithoutIR_requestsInput
  }

  export type companiesUpdateOneWithoutIR_requestsInput = {
    create?: XOR<companiesUncheckedCreateWithoutIR_requestsInput, companiesCreateWithoutIR_requestsInput>
    connect?: companiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<companiesUncheckedUpdateWithoutIR_requestsInput, companiesUpdateWithoutIR_requestsInput>
    upsert?: companiesUpsertWithoutIR_requestsInput
    connectOrCreate?: companiesCreateOrConnectWithoutIR_requestsInput
  }

  export type companiesCreateOneWithoutParticipantsInput = {
    create?: XOR<companiesUncheckedCreateWithoutParticipantsInput, companiesCreateWithoutParticipantsInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutparticipantsInput
  }

  export type demodaysCreateOneWithoutParticipantsInput = {
    create?: XOR<demodaysUncheckedCreateWithoutParticipantsInput, demodaysCreateWithoutParticipantsInput>
    connect?: demodaysWhereUniqueInput
    connectOrCreate?: demodaysCreateOrConnectWithoutparticipantsInput
  }

  export type votesCreateManyWithoutParticipantsInput = {
    create?: XOR<Enumerable<votesUncheckedCreateWithoutParticipantsInput>, Enumerable<votesCreateWithoutParticipantsInput>>
    connect?: Enumerable<votesWhereUniqueInput>
    connectOrCreate?: Enumerable<votesCreateOrConnectWithoutparticipantsInput>
  }

  export type votesUncheckedCreateManyWithoutParticipantsInput = {
    create?: XOR<Enumerable<votesUncheckedCreateWithoutParticipantsInput>, Enumerable<votesCreateWithoutParticipantsInput>>
    connect?: Enumerable<votesWhereUniqueInput>
    connectOrCreate?: Enumerable<votesCreateOrConnectWithoutparticipantsInput>
  }

  export type companiesUpdateOneRequiredWithoutParticipantsInput = {
    create?: XOR<companiesUncheckedCreateWithoutParticipantsInput, companiesCreateWithoutParticipantsInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutParticipantsInput, companiesUpdateWithoutParticipantsInput>
    upsert?: companiesUpsertWithoutParticipantsInput
    connectOrCreate?: companiesCreateOrConnectWithoutparticipantsInput
  }

  export type demodaysUpdateOneRequiredWithoutParticipantsInput = {
    create?: XOR<demodaysUncheckedCreateWithoutParticipantsInput, demodaysCreateWithoutParticipantsInput>
    connect?: demodaysWhereUniqueInput
    update?: XOR<demodaysUncheckedUpdateWithoutParticipantsInput, demodaysUpdateWithoutParticipantsInput>
    upsert?: demodaysUpsertWithoutParticipantsInput
    connectOrCreate?: demodaysCreateOrConnectWithoutparticipantsInput
  }

  export type votesUpdateManyWithoutParticipantsInput = {
    create?: XOR<Enumerable<votesUncheckedCreateWithoutParticipantsInput>, Enumerable<votesCreateWithoutParticipantsInput>>
    connect?: Enumerable<votesWhereUniqueInput>
    set?: Enumerable<votesWhereUniqueInput>
    disconnect?: Enumerable<votesWhereUniqueInput>
    delete?: Enumerable<votesWhereUniqueInput>
    update?: Enumerable<votesUpdateWithWhereUniqueWithoutParticipantsInput>
    updateMany?: Enumerable<votesUpdateManyWithWhereWithoutParticipantsInput>
    deleteMany?: Enumerable<votesScalarWhereInput>
    upsert?: Enumerable<votesUpsertWithWhereUniqueWithoutParticipantsInput>
    connectOrCreate?: Enumerable<votesCreateOrConnectWithoutparticipantsInput>
  }

  export type votesUncheckedUpdateManyWithoutParticipantsInput = {
    create?: XOR<Enumerable<votesUncheckedCreateWithoutParticipantsInput>, Enumerable<votesCreateWithoutParticipantsInput>>
    connect?: Enumerable<votesWhereUniqueInput>
    set?: Enumerable<votesWhereUniqueInput>
    disconnect?: Enumerable<votesWhereUniqueInput>
    delete?: Enumerable<votesWhereUniqueInput>
    update?: Enumerable<votesUpdateWithWhereUniqueWithoutParticipantsInput>
    updateMany?: Enumerable<votesUpdateManyWithWhereWithoutParticipantsInput>
    deleteMany?: Enumerable<votesScalarWhereInput>
    upsert?: Enumerable<votesUpsertWithWhereUniqueWithoutParticipantsInput>
    connectOrCreate?: Enumerable<votesCreateOrConnectWithoutparticipantsInput>
  }

  export type companiesCreateOneWithoutPartnersInput = {
    create?: XOR<companiesUncheckedCreateWithoutPartnersInput, companiesCreateWithoutPartnersInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutpartnersInput
  }

  export type technologiesCreateOneWithoutPartnersInput = {
    create?: XOR<technologiesUncheckedCreateWithoutPartnersInput, technologiesCreateWithoutPartnersInput>
    connect?: technologiesWhereUniqueInput
    connectOrCreate?: technologiesCreateOrConnectWithoutpartnersInput
  }

  export type investment_fundsCreateOneWithoutPartnersInput = {
    create?: XOR<investment_fundsUncheckedCreateWithoutPartnersInput, investment_fundsCreateWithoutPartnersInput>
    connect?: investment_fundsWhereUniqueInput
    connectOrCreate?: investment_fundsCreateOrConnectWithoutpartnersInput
  }

  export type investment_portfolioCreateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<investment_portfolioUncheckedCreateWithoutPartnersInput>, Enumerable<investment_portfolioCreateWithoutPartnersInput>>
    connect?: Enumerable<investment_portfolioWhereUniqueInput>
    connectOrCreate?: Enumerable<investment_portfolioCreateOrConnectWithoutpartnersInput>
  }

  export type IR_requestsCreateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutPartnersInput>, Enumerable<IR_requestsCreateWithoutPartnersInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutpartnersInput>
  }

  export type invested_toCreateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutPartnersInput>, Enumerable<invested_toCreateWithoutPartnersInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutpartnersInput>
  }

  export type investment_portfolioUncheckedCreateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<investment_portfolioUncheckedCreateWithoutPartnersInput>, Enumerable<investment_portfolioCreateWithoutPartnersInput>>
    connect?: Enumerable<investment_portfolioWhereUniqueInput>
    connectOrCreate?: Enumerable<investment_portfolioCreateOrConnectWithoutpartnersInput>
  }

  export type IR_requestsUncheckedCreateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutPartnersInput>, Enumerable<IR_requestsCreateWithoutPartnersInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutpartnersInput>
  }

  export type invested_toUncheckedCreateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutPartnersInput>, Enumerable<invested_toCreateWithoutPartnersInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutpartnersInput>
  }

  export type companiesUpdateOneRequiredWithoutPartnersInput = {
    create?: XOR<companiesUncheckedCreateWithoutPartnersInput, companiesCreateWithoutPartnersInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutPartnersInput, companiesUpdateWithoutPartnersInput>
    upsert?: companiesUpsertWithoutPartnersInput
    connectOrCreate?: companiesCreateOrConnectWithoutpartnersInput
  }

  export type technologiesUpdateOneWithoutPartnersInput = {
    create?: XOR<technologiesUncheckedCreateWithoutPartnersInput, technologiesCreateWithoutPartnersInput>
    connect?: technologiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<technologiesUncheckedUpdateWithoutPartnersInput, technologiesUpdateWithoutPartnersInput>
    upsert?: technologiesUpsertWithoutPartnersInput
    connectOrCreate?: technologiesCreateOrConnectWithoutpartnersInput
  }

  export type investment_fundsUpdateOneWithoutPartnersInput = {
    create?: XOR<investment_fundsUncheckedCreateWithoutPartnersInput, investment_fundsCreateWithoutPartnersInput>
    connect?: investment_fundsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<investment_fundsUncheckedUpdateWithoutPartnersInput, investment_fundsUpdateWithoutPartnersInput>
    upsert?: investment_fundsUpsertWithoutPartnersInput
    connectOrCreate?: investment_fundsCreateOrConnectWithoutpartnersInput
  }

  export type investment_portfolioUpdateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<investment_portfolioUncheckedCreateWithoutPartnersInput>, Enumerable<investment_portfolioCreateWithoutPartnersInput>>
    connect?: Enumerable<investment_portfolioWhereUniqueInput>
    set?: Enumerable<investment_portfolioWhereUniqueInput>
    disconnect?: Enumerable<investment_portfolioWhereUniqueInput>
    delete?: Enumerable<investment_portfolioWhereUniqueInput>
    update?: Enumerable<investment_portfolioUpdateWithWhereUniqueWithoutPartnersInput>
    updateMany?: Enumerable<investment_portfolioUpdateManyWithWhereWithoutPartnersInput>
    deleteMany?: Enumerable<investment_portfolioScalarWhereInput>
    upsert?: Enumerable<investment_portfolioUpsertWithWhereUniqueWithoutPartnersInput>
    connectOrCreate?: Enumerable<investment_portfolioCreateOrConnectWithoutpartnersInput>
  }

  export type IR_requestsUpdateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutPartnersInput>, Enumerable<IR_requestsCreateWithoutPartnersInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    set?: Enumerable<IR_requestsWhereUniqueInput>
    disconnect?: Enumerable<IR_requestsWhereUniqueInput>
    delete?: Enumerable<IR_requestsWhereUniqueInput>
    update?: Enumerable<IR_requestsUpdateWithWhereUniqueWithoutPartnersInput>
    updateMany?: Enumerable<IR_requestsUpdateManyWithWhereWithoutPartnersInput>
    deleteMany?: Enumerable<IR_requestsScalarWhereInput>
    upsert?: Enumerable<IR_requestsUpsertWithWhereUniqueWithoutPartnersInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutpartnersInput>
  }

  export type invested_toUpdateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutPartnersInput>, Enumerable<invested_toCreateWithoutPartnersInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    set?: Enumerable<invested_toWhereUniqueInput>
    disconnect?: Enumerable<invested_toWhereUniqueInput>
    delete?: Enumerable<invested_toWhereUniqueInput>
    update?: Enumerable<invested_toUpdateWithWhereUniqueWithoutPartnersInput>
    updateMany?: Enumerable<invested_toUpdateManyWithWhereWithoutPartnersInput>
    deleteMany?: Enumerable<invested_toScalarWhereInput>
    upsert?: Enumerable<invested_toUpsertWithWhereUniqueWithoutPartnersInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutpartnersInput>
  }

  export type investment_portfolioUncheckedUpdateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<investment_portfolioUncheckedCreateWithoutPartnersInput>, Enumerable<investment_portfolioCreateWithoutPartnersInput>>
    connect?: Enumerable<investment_portfolioWhereUniqueInput>
    set?: Enumerable<investment_portfolioWhereUniqueInput>
    disconnect?: Enumerable<investment_portfolioWhereUniqueInput>
    delete?: Enumerable<investment_portfolioWhereUniqueInput>
    update?: Enumerable<investment_portfolioUpdateWithWhereUniqueWithoutPartnersInput>
    updateMany?: Enumerable<investment_portfolioUpdateManyWithWhereWithoutPartnersInput>
    deleteMany?: Enumerable<investment_portfolioScalarWhereInput>
    upsert?: Enumerable<investment_portfolioUpsertWithWhereUniqueWithoutPartnersInput>
    connectOrCreate?: Enumerable<investment_portfolioCreateOrConnectWithoutpartnersInput>
  }

  export type IR_requestsUncheckedUpdateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutPartnersInput>, Enumerable<IR_requestsCreateWithoutPartnersInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    set?: Enumerable<IR_requestsWhereUniqueInput>
    disconnect?: Enumerable<IR_requestsWhereUniqueInput>
    delete?: Enumerable<IR_requestsWhereUniqueInput>
    update?: Enumerable<IR_requestsUpdateWithWhereUniqueWithoutPartnersInput>
    updateMany?: Enumerable<IR_requestsUpdateManyWithWhereWithoutPartnersInput>
    deleteMany?: Enumerable<IR_requestsScalarWhereInput>
    upsert?: Enumerable<IR_requestsUpsertWithWhereUniqueWithoutPartnersInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutpartnersInput>
  }

  export type invested_toUncheckedUpdateManyWithoutPartnersInput = {
    create?: XOR<Enumerable<invested_toUncheckedCreateWithoutPartnersInput>, Enumerable<invested_toCreateWithoutPartnersInput>>
    connect?: Enumerable<invested_toWhereUniqueInput>
    set?: Enumerable<invested_toWhereUniqueInput>
    disconnect?: Enumerable<invested_toWhereUniqueInput>
    delete?: Enumerable<invested_toWhereUniqueInput>
    update?: Enumerable<invested_toUpdateWithWhereUniqueWithoutPartnersInput>
    updateMany?: Enumerable<invested_toUpdateManyWithWhereWithoutPartnersInput>
    deleteMany?: Enumerable<invested_toScalarWhereInput>
    upsert?: Enumerable<invested_toUpsertWithWhereUniqueWithoutPartnersInput>
    connectOrCreate?: Enumerable<invested_toCreateOrConnectWithoutpartnersInput>
  }

  export type usersCreateOneWithoutPartner_likesInput = {
    create?: XOR<usersUncheckedCreateWithoutPartner_likesInput, usersCreateWithoutPartner_likesInput>
    connect?: usersWhereUniqueInput
    connectOrCreate?: usersCreateOrConnectWithoutpartner_likesInput
  }

  export type companiesCreateOneWithoutPartner_likesInput = {
    create?: XOR<companiesUncheckedCreateWithoutPartner_likesInput, companiesCreateWithoutPartner_likesInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutpartner_likesInput
  }

  export type usersUpdateOneRequiredWithoutPartner_likesInput = {
    create?: XOR<usersUncheckedCreateWithoutPartner_likesInput, usersCreateWithoutPartner_likesInput>
    connect?: usersWhereUniqueInput
    update?: XOR<usersUncheckedUpdateWithoutPartner_likesInput, usersUpdateWithoutPartner_likesInput>
    upsert?: usersUpsertWithoutPartner_likesInput
    connectOrCreate?: usersCreateOrConnectWithoutpartner_likesInput
  }

  export type companiesUpdateOneRequiredWithoutPartner_likesInput = {
    create?: XOR<companiesUncheckedCreateWithoutPartner_likesInput, companiesCreateWithoutPartner_likesInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutPartner_likesInput, companiesUpdateWithoutPartner_likesInput>
    upsert?: companiesUpsertWithoutPartner_likesInput
    connectOrCreate?: companiesCreateOrConnectWithoutpartner_likesInput
  }

  export type projectsCreateOneWithoutProject_imagesInput = {
    create?: XOR<projectsUncheckedCreateWithoutProject_imagesInput, projectsCreateWithoutProject_imagesInput>
    connect?: projectsWhereUniqueInput
    connectOrCreate?: projectsCreateOrConnectWithoutproject_imagesInput
  }

  export type projectsUpdateOneRequiredWithoutProject_imagesInput = {
    create?: XOR<projectsUncheckedCreateWithoutProject_imagesInput, projectsCreateWithoutProject_imagesInput>
    connect?: projectsWhereUniqueInput
    update?: XOR<projectsUncheckedUpdateWithoutProject_imagesInput, projectsUpdateWithoutProject_imagesInput>
    upsert?: projectsUpsertWithoutProject_imagesInput
    connectOrCreate?: projectsCreateOrConnectWithoutproject_imagesInput
  }

  export type usersCreateOneWithoutProject_likesInput = {
    create?: XOR<usersUncheckedCreateWithoutProject_likesInput, usersCreateWithoutProject_likesInput>
    connect?: usersWhereUniqueInput
    connectOrCreate?: usersCreateOrConnectWithoutproject_likesInput
  }

  export type projectsCreateOneWithoutProject_likesInput = {
    create?: XOR<projectsUncheckedCreateWithoutProject_likesInput, projectsCreateWithoutProject_likesInput>
    connect?: projectsWhereUniqueInput
    connectOrCreate?: projectsCreateOrConnectWithoutproject_likesInput
  }

  export type companiesCreateOneWithoutProject_likesInput = {
    create?: XOR<companiesUncheckedCreateWithoutProject_likesInput, companiesCreateWithoutProject_likesInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutproject_likesInput
  }

  export type usersUpdateOneRequiredWithoutProject_likesInput = {
    create?: XOR<usersUncheckedCreateWithoutProject_likesInput, usersCreateWithoutProject_likesInput>
    connect?: usersWhereUniqueInput
    update?: XOR<usersUncheckedUpdateWithoutProject_likesInput, usersUpdateWithoutProject_likesInput>
    upsert?: usersUpsertWithoutProject_likesInput
    connectOrCreate?: usersCreateOrConnectWithoutproject_likesInput
  }

  export type projectsUpdateOneRequiredWithoutProject_likesInput = {
    create?: XOR<projectsUncheckedCreateWithoutProject_likesInput, projectsCreateWithoutProject_likesInput>
    connect?: projectsWhereUniqueInput
    update?: XOR<projectsUncheckedUpdateWithoutProject_likesInput, projectsUpdateWithoutProject_likesInput>
    upsert?: projectsUpsertWithoutProject_likesInput
    connectOrCreate?: projectsCreateOrConnectWithoutproject_likesInput
  }

  export type companiesUpdateOneWithoutProject_likesInput = {
    create?: XOR<companiesUncheckedCreateWithoutProject_likesInput, companiesCreateWithoutProject_likesInput>
    connect?: companiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<companiesUncheckedUpdateWithoutProject_likesInput, companiesUpdateWithoutProject_likesInput>
    upsert?: companiesUpsertWithoutProject_likesInput
    connectOrCreate?: companiesCreateOrConnectWithoutproject_likesInput
  }

  export type eligible_sectorsCreateOneWithoutProjectsInput = {
    create?: XOR<eligible_sectorsUncheckedCreateWithoutProjectsInput, eligible_sectorsCreateWithoutProjectsInput>
    connect?: eligible_sectorsWhereUniqueInput
    connectOrCreate?: eligible_sectorsCreateOrConnectWithoutprojectsInput
  }

  export type eligibilitiesCreateOneWithoutProjectsInput = {
    create?: XOR<eligibilitiesUncheckedCreateWithoutProjectsInput, eligibilitiesCreateWithoutProjectsInput>
    connect?: eligibilitiesWhereUniqueInput
    connectOrCreate?: eligibilitiesCreateOrConnectWithoutprojectsInput
  }

  export type companiesCreateOneWithoutProjectsInput = {
    create?: XOR<companiesUncheckedCreateWithoutProjectsInput, companiesCreateWithoutProjectsInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutprojectsInput
  }

  export type applicantsCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<applicantsUncheckedCreateWithoutProjectsInput>, Enumerable<applicantsCreateWithoutProjectsInput>>
    connect?: Enumerable<applicantsWhereUniqueInput>
    connectOrCreate?: Enumerable<applicantsCreateOrConnectWithoutprojectsInput>
  }

  export type project_imagesCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<project_imagesUncheckedCreateWithoutProjectsInput>, Enumerable<project_imagesCreateWithoutProjectsInput>>
    connect?: Enumerable<project_imagesWhereUniqueInput>
    connectOrCreate?: Enumerable<project_imagesCreateOrConnectWithoutprojectsInput>
  }

  export type project_likesCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutProjectsInput>, Enumerable<project_likesCreateWithoutProjectsInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutprojectsInput>
  }

  export type recent_views_projectCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<recent_views_projectUncheckedCreateWithoutProjectsInput>, Enumerable<recent_views_projectCreateWithoutProjectsInput>>
    connect?: Enumerable<recent_views_projectWhereUniqueInput>
    connectOrCreate?: Enumerable<recent_views_projectCreateOrConnectWithoutprojectsInput>
  }

  export type required_documentsCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<required_documentsUncheckedCreateWithoutProjectsInput>, Enumerable<required_documentsCreateWithoutProjectsInput>>
    connect?: Enumerable<required_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<required_documentsCreateOrConnectWithoutprojectsInput>
  }

  export type applicantsUncheckedCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<applicantsUncheckedCreateWithoutProjectsInput>, Enumerable<applicantsCreateWithoutProjectsInput>>
    connect?: Enumerable<applicantsWhereUniqueInput>
    connectOrCreate?: Enumerable<applicantsCreateOrConnectWithoutprojectsInput>
  }

  export type project_imagesUncheckedCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<project_imagesUncheckedCreateWithoutProjectsInput>, Enumerable<project_imagesCreateWithoutProjectsInput>>
    connect?: Enumerable<project_imagesWhereUniqueInput>
    connectOrCreate?: Enumerable<project_imagesCreateOrConnectWithoutprojectsInput>
  }

  export type project_likesUncheckedCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutProjectsInput>, Enumerable<project_likesCreateWithoutProjectsInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutprojectsInput>
  }

  export type recent_views_projectUncheckedCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<recent_views_projectUncheckedCreateWithoutProjectsInput>, Enumerable<recent_views_projectCreateWithoutProjectsInput>>
    connect?: Enumerable<recent_views_projectWhereUniqueInput>
    connectOrCreate?: Enumerable<recent_views_projectCreateOrConnectWithoutprojectsInput>
  }

  export type required_documentsUncheckedCreateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<required_documentsUncheckedCreateWithoutProjectsInput>, Enumerable<required_documentsCreateWithoutProjectsInput>>
    connect?: Enumerable<required_documentsWhereUniqueInput>
    connectOrCreate?: Enumerable<required_documentsCreateOrConnectWithoutprojectsInput>
  }

  export type eligible_sectorsUpdateOneWithoutProjectsInput = {
    create?: XOR<eligible_sectorsUncheckedCreateWithoutProjectsInput, eligible_sectorsCreateWithoutProjectsInput>
    connect?: eligible_sectorsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<eligible_sectorsUncheckedUpdateWithoutProjectsInput, eligible_sectorsUpdateWithoutProjectsInput>
    upsert?: eligible_sectorsUpsertWithoutProjectsInput
    connectOrCreate?: eligible_sectorsCreateOrConnectWithoutprojectsInput
  }

  export type eligibilitiesUpdateOneWithoutProjectsInput = {
    create?: XOR<eligibilitiesUncheckedCreateWithoutProjectsInput, eligibilitiesCreateWithoutProjectsInput>
    connect?: eligibilitiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<eligibilitiesUncheckedUpdateWithoutProjectsInput, eligibilitiesUpdateWithoutProjectsInput>
    upsert?: eligibilitiesUpsertWithoutProjectsInput
    connectOrCreate?: eligibilitiesCreateOrConnectWithoutprojectsInput
  }

  export type companiesUpdateOneWithoutProjectsInput = {
    create?: XOR<companiesUncheckedCreateWithoutProjectsInput, companiesCreateWithoutProjectsInput>
    connect?: companiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<companiesUncheckedUpdateWithoutProjectsInput, companiesUpdateWithoutProjectsInput>
    upsert?: companiesUpsertWithoutProjectsInput
    connectOrCreate?: companiesCreateOrConnectWithoutprojectsInput
  }

  export type applicantsUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<applicantsUncheckedCreateWithoutProjectsInput>, Enumerable<applicantsCreateWithoutProjectsInput>>
    connect?: Enumerable<applicantsWhereUniqueInput>
    set?: Enumerable<applicantsWhereUniqueInput>
    disconnect?: Enumerable<applicantsWhereUniqueInput>
    delete?: Enumerable<applicantsWhereUniqueInput>
    update?: Enumerable<applicantsUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<applicantsUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<applicantsScalarWhereInput>
    upsert?: Enumerable<applicantsUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<applicantsCreateOrConnectWithoutprojectsInput>
  }

  export type project_imagesUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<project_imagesUncheckedCreateWithoutProjectsInput>, Enumerable<project_imagesCreateWithoutProjectsInput>>
    connect?: Enumerable<project_imagesWhereUniqueInput>
    set?: Enumerable<project_imagesWhereUniqueInput>
    disconnect?: Enumerable<project_imagesWhereUniqueInput>
    delete?: Enumerable<project_imagesWhereUniqueInput>
    update?: Enumerable<project_imagesUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<project_imagesUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<project_imagesScalarWhereInput>
    upsert?: Enumerable<project_imagesUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<project_imagesCreateOrConnectWithoutprojectsInput>
  }

  export type project_likesUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutProjectsInput>, Enumerable<project_likesCreateWithoutProjectsInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    set?: Enumerable<project_likesWhereUniqueInput>
    disconnect?: Enumerable<project_likesWhereUniqueInput>
    delete?: Enumerable<project_likesWhereUniqueInput>
    update?: Enumerable<project_likesUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<project_likesUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<project_likesScalarWhereInput>
    upsert?: Enumerable<project_likesUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutprojectsInput>
  }

  export type recent_views_projectUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<recent_views_projectUncheckedCreateWithoutProjectsInput>, Enumerable<recent_views_projectCreateWithoutProjectsInput>>
    connect?: Enumerable<recent_views_projectWhereUniqueInput>
    set?: Enumerable<recent_views_projectWhereUniqueInput>
    disconnect?: Enumerable<recent_views_projectWhereUniqueInput>
    delete?: Enumerable<recent_views_projectWhereUniqueInput>
    update?: Enumerable<recent_views_projectUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<recent_views_projectUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<recent_views_projectScalarWhereInput>
    upsert?: Enumerable<recent_views_projectUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<recent_views_projectCreateOrConnectWithoutprojectsInput>
  }

  export type required_documentsUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<required_documentsUncheckedCreateWithoutProjectsInput>, Enumerable<required_documentsCreateWithoutProjectsInput>>
    connect?: Enumerable<required_documentsWhereUniqueInput>
    set?: Enumerable<required_documentsWhereUniqueInput>
    disconnect?: Enumerable<required_documentsWhereUniqueInput>
    delete?: Enumerable<required_documentsWhereUniqueInput>
    update?: Enumerable<required_documentsUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<required_documentsUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<required_documentsScalarWhereInput>
    upsert?: Enumerable<required_documentsUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<required_documentsCreateOrConnectWithoutprojectsInput>
  }

  export type applicantsUncheckedUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<applicantsUncheckedCreateWithoutProjectsInput>, Enumerable<applicantsCreateWithoutProjectsInput>>
    connect?: Enumerable<applicantsWhereUniqueInput>
    set?: Enumerable<applicantsWhereUniqueInput>
    disconnect?: Enumerable<applicantsWhereUniqueInput>
    delete?: Enumerable<applicantsWhereUniqueInput>
    update?: Enumerable<applicantsUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<applicantsUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<applicantsScalarWhereInput>
    upsert?: Enumerable<applicantsUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<applicantsCreateOrConnectWithoutprojectsInput>
  }

  export type project_imagesUncheckedUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<project_imagesUncheckedCreateWithoutProjectsInput>, Enumerable<project_imagesCreateWithoutProjectsInput>>
    connect?: Enumerable<project_imagesWhereUniqueInput>
    set?: Enumerable<project_imagesWhereUniqueInput>
    disconnect?: Enumerable<project_imagesWhereUniqueInput>
    delete?: Enumerable<project_imagesWhereUniqueInput>
    update?: Enumerable<project_imagesUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<project_imagesUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<project_imagesScalarWhereInput>
    upsert?: Enumerable<project_imagesUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<project_imagesCreateOrConnectWithoutprojectsInput>
  }

  export type project_likesUncheckedUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutProjectsInput>, Enumerable<project_likesCreateWithoutProjectsInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    set?: Enumerable<project_likesWhereUniqueInput>
    disconnect?: Enumerable<project_likesWhereUniqueInput>
    delete?: Enumerable<project_likesWhereUniqueInput>
    update?: Enumerable<project_likesUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<project_likesUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<project_likesScalarWhereInput>
    upsert?: Enumerable<project_likesUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutprojectsInput>
  }

  export type recent_views_projectUncheckedUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<recent_views_projectUncheckedCreateWithoutProjectsInput>, Enumerable<recent_views_projectCreateWithoutProjectsInput>>
    connect?: Enumerable<recent_views_projectWhereUniqueInput>
    set?: Enumerable<recent_views_projectWhereUniqueInput>
    disconnect?: Enumerable<recent_views_projectWhereUniqueInput>
    delete?: Enumerable<recent_views_projectWhereUniqueInput>
    update?: Enumerable<recent_views_projectUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<recent_views_projectUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<recent_views_projectScalarWhereInput>
    upsert?: Enumerable<recent_views_projectUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<recent_views_projectCreateOrConnectWithoutprojectsInput>
  }

  export type required_documentsUncheckedUpdateManyWithoutProjectsInput = {
    create?: XOR<Enumerable<required_documentsUncheckedCreateWithoutProjectsInput>, Enumerable<required_documentsCreateWithoutProjectsInput>>
    connect?: Enumerable<required_documentsWhereUniqueInput>
    set?: Enumerable<required_documentsWhereUniqueInput>
    disconnect?: Enumerable<required_documentsWhereUniqueInput>
    delete?: Enumerable<required_documentsWhereUniqueInput>
    update?: Enumerable<required_documentsUpdateWithWhereUniqueWithoutProjectsInput>
    updateMany?: Enumerable<required_documentsUpdateManyWithWhereWithoutProjectsInput>
    deleteMany?: Enumerable<required_documentsScalarWhereInput>
    upsert?: Enumerable<required_documentsUpsertWithWhereUniqueWithoutProjectsInput>
    connectOrCreate?: Enumerable<required_documentsCreateOrConnectWithoutprojectsInput>
  }

  export type companiesCreateOneWithoutQuestionsInput = {
    create?: XOR<companiesUncheckedCreateWithoutQuestionsInput, companiesCreateWithoutQuestionsInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutquestionsInput
  }

  export type demodaysCreateOneWithoutQuestionsInput = {
    create?: XOR<demodaysUncheckedCreateWithoutQuestionsInput, demodaysCreateWithoutQuestionsInput>
    connect?: demodaysWhereUniqueInput
    connectOrCreate?: demodaysCreateOrConnectWithoutquestionsInput
  }

  export type usersCreateOneWithoutQuestionsInput = {
    create?: XOR<usersUncheckedCreateWithoutQuestionsInput, usersCreateWithoutQuestionsInput>
    connect?: usersWhereUniqueInput
    connectOrCreate?: usersCreateOrConnectWithoutquestionsInput
  }

  export type answersCreateManyWithoutQuestionsInput = {
    create?: XOR<Enumerable<answersUncheckedCreateWithoutQuestionsInput>, Enumerable<answersCreateWithoutQuestionsInput>>
    connect?: Enumerable<answersWhereUniqueInput>
    connectOrCreate?: Enumerable<answersCreateOrConnectWithoutquestionsInput>
  }

  export type answersUncheckedCreateManyWithoutQuestionsInput = {
    create?: XOR<Enumerable<answersUncheckedCreateWithoutQuestionsInput>, Enumerable<answersCreateWithoutQuestionsInput>>
    connect?: Enumerable<answersWhereUniqueInput>
    connectOrCreate?: Enumerable<answersCreateOrConnectWithoutquestionsInput>
  }

  export type companiesUpdateOneRequiredWithoutQuestionsInput = {
    create?: XOR<companiesUncheckedCreateWithoutQuestionsInput, companiesCreateWithoutQuestionsInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutQuestionsInput, companiesUpdateWithoutQuestionsInput>
    upsert?: companiesUpsertWithoutQuestionsInput
    connectOrCreate?: companiesCreateOrConnectWithoutquestionsInput
  }

  export type demodaysUpdateOneRequiredWithoutQuestionsInput = {
    create?: XOR<demodaysUncheckedCreateWithoutQuestionsInput, demodaysCreateWithoutQuestionsInput>
    connect?: demodaysWhereUniqueInput
    update?: XOR<demodaysUncheckedUpdateWithoutQuestionsInput, demodaysUpdateWithoutQuestionsInput>
    upsert?: demodaysUpsertWithoutQuestionsInput
    connectOrCreate?: demodaysCreateOrConnectWithoutquestionsInput
  }

  export type usersUpdateOneRequiredWithoutQuestionsInput = {
    create?: XOR<usersUncheckedCreateWithoutQuestionsInput, usersCreateWithoutQuestionsInput>
    connect?: usersWhereUniqueInput
    update?: XOR<usersUncheckedUpdateWithoutQuestionsInput, usersUpdateWithoutQuestionsInput>
    upsert?: usersUpsertWithoutQuestionsInput
    connectOrCreate?: usersCreateOrConnectWithoutquestionsInput
  }

  export type answersUpdateManyWithoutQuestionsInput = {
    create?: XOR<Enumerable<answersUncheckedCreateWithoutQuestionsInput>, Enumerable<answersCreateWithoutQuestionsInput>>
    connect?: Enumerable<answersWhereUniqueInput>
    set?: Enumerable<answersWhereUniqueInput>
    disconnect?: Enumerable<answersWhereUniqueInput>
    delete?: Enumerable<answersWhereUniqueInput>
    update?: Enumerable<answersUpdateWithWhereUniqueWithoutQuestionsInput>
    updateMany?: Enumerable<answersUpdateManyWithWhereWithoutQuestionsInput>
    deleteMany?: Enumerable<answersScalarWhereInput>
    upsert?: Enumerable<answersUpsertWithWhereUniqueWithoutQuestionsInput>
    connectOrCreate?: Enumerable<answersCreateOrConnectWithoutquestionsInput>
  }

  export type answersUncheckedUpdateManyWithoutQuestionsInput = {
    create?: XOR<Enumerable<answersUncheckedCreateWithoutQuestionsInput>, Enumerable<answersCreateWithoutQuestionsInput>>
    connect?: Enumerable<answersWhereUniqueInput>
    set?: Enumerable<answersWhereUniqueInput>
    disconnect?: Enumerable<answersWhereUniqueInput>
    delete?: Enumerable<answersWhereUniqueInput>
    update?: Enumerable<answersUpdateWithWhereUniqueWithoutQuestionsInput>
    updateMany?: Enumerable<answersUpdateManyWithWhereWithoutQuestionsInput>
    deleteMany?: Enumerable<answersScalarWhereInput>
    upsert?: Enumerable<answersUpsertWithWhereUniqueWithoutQuestionsInput>
    connectOrCreate?: Enumerable<answersCreateOrConnectWithoutquestionsInput>
  }

  export type companiesCreateOneWithoutRecent_views_projectInput = {
    create?: XOR<companiesUncheckedCreateWithoutRecent_views_projectInput, companiesCreateWithoutRecent_views_projectInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutrecent_views_projectInput
  }

  export type projectsCreateOneWithoutRecent_views_projectInput = {
    create?: XOR<projectsUncheckedCreateWithoutRecent_views_projectInput, projectsCreateWithoutRecent_views_projectInput>
    connect?: projectsWhereUniqueInput
    connectOrCreate?: projectsCreateOrConnectWithoutrecent_views_projectInput
  }

  export type companiesUpdateOneRequiredWithoutRecent_views_projectInput = {
    create?: XOR<companiesUncheckedCreateWithoutRecent_views_projectInput, companiesCreateWithoutRecent_views_projectInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutRecent_views_projectInput, companiesUpdateWithoutRecent_views_projectInput>
    upsert?: companiesUpsertWithoutRecent_views_projectInput
    connectOrCreate?: companiesCreateOrConnectWithoutrecent_views_projectInput
  }

  export type projectsUpdateOneRequiredWithoutRecent_views_projectInput = {
    create?: XOR<projectsUncheckedCreateWithoutRecent_views_projectInput, projectsCreateWithoutRecent_views_projectInput>
    connect?: projectsWhereUniqueInput
    update?: XOR<projectsUncheckedUpdateWithoutRecent_views_projectInput, projectsUpdateWithoutRecent_views_projectInput>
    upsert?: projectsUpsertWithoutRecent_views_projectInput
    connectOrCreate?: projectsCreateOrConnectWithoutrecent_views_projectInput
  }

  export type document_typesCreateOneWithoutRequired_documentsInput = {
    create?: XOR<document_typesUncheckedCreateWithoutRequired_documentsInput, document_typesCreateWithoutRequired_documentsInput>
    connect?: document_typesWhereUniqueInput
    connectOrCreate?: document_typesCreateOrConnectWithoutrequired_documentsInput
  }

  export type projectsCreateOneWithoutRequired_documentsInput = {
    create?: XOR<projectsUncheckedCreateWithoutRequired_documentsInput, projectsCreateWithoutRequired_documentsInput>
    connect?: projectsWhereUniqueInput
    connectOrCreate?: projectsCreateOrConnectWithoutrequired_documentsInput
  }

  export type document_typesUpdateOneRequiredWithoutRequired_documentsInput = {
    create?: XOR<document_typesUncheckedCreateWithoutRequired_documentsInput, document_typesCreateWithoutRequired_documentsInput>
    connect?: document_typesWhereUniqueInput
    update?: XOR<document_typesUncheckedUpdateWithoutRequired_documentsInput, document_typesUpdateWithoutRequired_documentsInput>
    upsert?: document_typesUpsertWithoutRequired_documentsInput
    connectOrCreate?: document_typesCreateOrConnectWithoutrequired_documentsInput
  }

  export type projectsUpdateOneRequiredWithoutRequired_documentsInput = {
    create?: XOR<projectsUncheckedCreateWithoutRequired_documentsInput, projectsCreateWithoutRequired_documentsInput>
    connect?: projectsWhereUniqueInput
    update?: XOR<projectsUncheckedUpdateWithoutRequired_documentsInput, projectsUpdateWithoutRequired_documentsInput>
    upsert?: projectsUpsertWithoutRequired_documentsInput
    connectOrCreate?: projectsCreateOrConnectWithoutrequired_documentsInput
  }

  export type startupsCreateManyWithoutSectorsInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutSectorsInput>, Enumerable<startupsCreateWithoutSectorsInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutsectorsInput>
  }

  export type startupsUncheckedCreateManyWithoutSectorsInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutSectorsInput>, Enumerable<startupsCreateWithoutSectorsInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutsectorsInput>
  }

  export type startupsUpdateManyWithoutSectorsInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutSectorsInput>, Enumerable<startupsCreateWithoutSectorsInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutSectorsInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutSectorsInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutSectorsInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutsectorsInput>
  }

  export type startupsUncheckedUpdateManyWithoutSectorsInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutSectorsInput>, Enumerable<startupsCreateWithoutSectorsInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutSectorsInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutSectorsInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutSectorsInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutsectorsInput>
  }

  export type startupsCreateManyWithoutService_typesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutService_typesInput>, Enumerable<startupsCreateWithoutService_typesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutservice_typesInput>
  }

  export type startupsUncheckedCreateManyWithoutService_typesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutService_typesInput>, Enumerable<startupsCreateWithoutService_typesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutservice_typesInput>
  }

  export type startupsUpdateManyWithoutService_typesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutService_typesInput>, Enumerable<startupsCreateWithoutService_typesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutService_typesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutService_typesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutService_typesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutservice_typesInput>
  }

  export type startupsUncheckedUpdateManyWithoutService_typesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutService_typesInput>, Enumerable<startupsCreateWithoutService_typesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutService_typesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutService_typesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutService_typesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithoutservice_typesInput>
  }

  export type usersCreateManyWithoutSignup_methodsInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutSignup_methodsInput>, Enumerable<usersCreateWithoutSignup_methodsInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutsignup_methodsInput>
  }

  export type usersUncheckedCreateManyWithoutSignup_methodsInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutSignup_methodsInput>, Enumerable<usersCreateWithoutSignup_methodsInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutsignup_methodsInput>
  }

  export type usersUpdateManyWithoutSignup_methodsInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutSignup_methodsInput>, Enumerable<usersCreateWithoutSignup_methodsInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutSignup_methodsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutSignup_methodsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutSignup_methodsInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutsignup_methodsInput>
  }

  export type usersUncheckedUpdateManyWithoutSignup_methodsInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutSignup_methodsInput>, Enumerable<usersCreateWithoutSignup_methodsInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutSignup_methodsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutSignup_methodsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutSignup_methodsInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutsignup_methodsInput>
  }

  export type startupsCreateOneWithoutStartup_imagesInput = {
    create?: XOR<startupsUncheckedCreateWithoutStartup_imagesInput, startupsCreateWithoutStartup_imagesInput>
    connect?: startupsWhereUniqueInput
    connectOrCreate?: startupsCreateOrConnectWithoutstartup_imagesInput
  }

  export type startupsUpdateOneRequiredWithoutStartup_imagesInput = {
    create?: XOR<startupsUncheckedCreateWithoutStartup_imagesInput, startupsCreateWithoutStartup_imagesInput>
    connect?: startupsWhereUniqueInput
    update?: XOR<startupsUncheckedUpdateWithoutStartup_imagesInput, startupsUpdateWithoutStartup_imagesInput>
    upsert?: startupsUpsertWithoutStartup_imagesInput
    connectOrCreate?: startupsCreateOrConnectWithoutstartup_imagesInput
  }

  export type business_typesCreateOneWithoutStartupsInput = {
    create?: XOR<business_typesUncheckedCreateWithoutStartupsInput, business_typesCreateWithoutStartupsInput>
    connect?: business_typesWhereUniqueInput
    connectOrCreate?: business_typesCreateOrConnectWithoutstartupsInput
  }

  export type companiesCreateOneWithoutStartupsInput = {
    create?: XOR<companiesUncheckedCreateWithoutStartupsInput, companiesCreateWithoutStartupsInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutstartupsInput
  }

  export type technologiesCreateOneWithoutStartupsInput = {
    create?: XOR<technologiesUncheckedCreateWithoutStartupsInput, technologiesCreateWithoutStartupsInput>
    connect?: technologiesWhereUniqueInput
    connectOrCreate?: technologiesCreateOrConnectWithoutstartupsInput
  }

  export type sectorsCreateOneWithoutStartupsInput = {
    create?: XOR<sectorsUncheckedCreateWithoutStartupsInput, sectorsCreateWithoutStartupsInput>
    connect?: sectorsWhereUniqueInput
    connectOrCreate?: sectorsCreateOrConnectWithoutstartupsInput
  }

  export type service_typesCreateOneWithoutStartupsInput = {
    create?: XOR<service_typesUncheckedCreateWithoutStartupsInput, service_typesCreateWithoutStartupsInput>
    connect?: service_typesWhereUniqueInput
    connectOrCreate?: service_typesCreateOrConnectWithoutstartupsInput
  }

  export type investment_seriesCreateOneWithoutStartupsInput = {
    create?: XOR<investment_seriesUncheckedCreateWithoutStartupsInput, investment_seriesCreateWithoutStartupsInput>
    connect?: investment_seriesWhereUniqueInput
    connectOrCreate?: investment_seriesCreateOrConnectWithoutstartupsInput
  }

  export type investment_fundsCreateOneWithoutStartupsInput = {
    create?: XOR<investment_fundsUncheckedCreateWithoutStartupsInput, investment_fundsCreateWithoutStartupsInput>
    connect?: investment_fundsWhereUniqueInput
    connectOrCreate?: investment_fundsCreateOrConnectWithoutstartupsInput
  }

  export type invested_fromCreateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutStartupsInput>, Enumerable<invested_fromCreateWithoutStartupsInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutstartupsInput>
  }

  export type startup_imagesCreateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<startup_imagesUncheckedCreateWithoutStartupsInput>, Enumerable<startup_imagesCreateWithoutStartupsInput>>
    connect?: Enumerable<startup_imagesWhereUniqueInput>
    connectOrCreate?: Enumerable<startup_imagesCreateOrConnectWithoutstartupsInput>
  }

  export type wish_investment_seriesCreateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<wish_investment_seriesUncheckedCreateWithoutStartupsInput>, Enumerable<wish_investment_seriesCreateWithoutStartupsInput>>
    connect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    connectOrCreate?: Enumerable<wish_investment_seriesCreateOrConnectWithoutstartupsInput>
  }

  export type IR_requestsCreateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutStartupsInput>, Enumerable<IR_requestsCreateWithoutStartupsInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutstartupsInput>
  }

  export type invested_fromUncheckedCreateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutStartupsInput>, Enumerable<invested_fromCreateWithoutStartupsInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutstartupsInput>
  }

  export type startup_imagesUncheckedCreateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<startup_imagesUncheckedCreateWithoutStartupsInput>, Enumerable<startup_imagesCreateWithoutStartupsInput>>
    connect?: Enumerable<startup_imagesWhereUniqueInput>
    connectOrCreate?: Enumerable<startup_imagesCreateOrConnectWithoutstartupsInput>
  }

  export type wish_investment_seriesUncheckedCreateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<wish_investment_seriesUncheckedCreateWithoutStartupsInput>, Enumerable<wish_investment_seriesCreateWithoutStartupsInput>>
    connect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    connectOrCreate?: Enumerable<wish_investment_seriesCreateOrConnectWithoutstartupsInput>
  }

  export type IR_requestsUncheckedCreateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutStartupsInput>, Enumerable<IR_requestsCreateWithoutStartupsInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutstartupsInput>
  }

  export type business_typesUpdateOneWithoutStartupsInput = {
    create?: XOR<business_typesUncheckedCreateWithoutStartupsInput, business_typesCreateWithoutStartupsInput>
    connect?: business_typesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<business_typesUncheckedUpdateWithoutStartupsInput, business_typesUpdateWithoutStartupsInput>
    upsert?: business_typesUpsertWithoutStartupsInput
    connectOrCreate?: business_typesCreateOrConnectWithoutstartupsInput
  }

  export type companiesUpdateOneRequiredWithoutStartupsInput = {
    create?: XOR<companiesUncheckedCreateWithoutStartupsInput, companiesCreateWithoutStartupsInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutStartupsInput, companiesUpdateWithoutStartupsInput>
    upsert?: companiesUpsertWithoutStartupsInput
    connectOrCreate?: companiesCreateOrConnectWithoutstartupsInput
  }

  export type technologiesUpdateOneWithoutStartupsInput = {
    create?: XOR<technologiesUncheckedCreateWithoutStartupsInput, technologiesCreateWithoutStartupsInput>
    connect?: technologiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<technologiesUncheckedUpdateWithoutStartupsInput, technologiesUpdateWithoutStartupsInput>
    upsert?: technologiesUpsertWithoutStartupsInput
    connectOrCreate?: technologiesCreateOrConnectWithoutstartupsInput
  }

  export type sectorsUpdateOneWithoutStartupsInput = {
    create?: XOR<sectorsUncheckedCreateWithoutStartupsInput, sectorsCreateWithoutStartupsInput>
    connect?: sectorsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<sectorsUncheckedUpdateWithoutStartupsInput, sectorsUpdateWithoutStartupsInput>
    upsert?: sectorsUpsertWithoutStartupsInput
    connectOrCreate?: sectorsCreateOrConnectWithoutstartupsInput
  }

  export type service_typesUpdateOneWithoutStartupsInput = {
    create?: XOR<service_typesUncheckedCreateWithoutStartupsInput, service_typesCreateWithoutStartupsInput>
    connect?: service_typesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<service_typesUncheckedUpdateWithoutStartupsInput, service_typesUpdateWithoutStartupsInput>
    upsert?: service_typesUpsertWithoutStartupsInput
    connectOrCreate?: service_typesCreateOrConnectWithoutstartupsInput
  }

  export type investment_seriesUpdateOneWithoutStartupsInput = {
    create?: XOR<investment_seriesUncheckedCreateWithoutStartupsInput, investment_seriesCreateWithoutStartupsInput>
    connect?: investment_seriesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<investment_seriesUncheckedUpdateWithoutStartupsInput, investment_seriesUpdateWithoutStartupsInput>
    upsert?: investment_seriesUpsertWithoutStartupsInput
    connectOrCreate?: investment_seriesCreateOrConnectWithoutstartupsInput
  }

  export type investment_fundsUpdateOneWithoutStartupsInput = {
    create?: XOR<investment_fundsUncheckedCreateWithoutStartupsInput, investment_fundsCreateWithoutStartupsInput>
    connect?: investment_fundsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<investment_fundsUncheckedUpdateWithoutStartupsInput, investment_fundsUpdateWithoutStartupsInput>
    upsert?: investment_fundsUpsertWithoutStartupsInput
    connectOrCreate?: investment_fundsCreateOrConnectWithoutstartupsInput
  }

  export type invested_fromUpdateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutStartupsInput>, Enumerable<invested_fromCreateWithoutStartupsInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    set?: Enumerable<invested_fromWhereUniqueInput>
    disconnect?: Enumerable<invested_fromWhereUniqueInput>
    delete?: Enumerable<invested_fromWhereUniqueInput>
    update?: Enumerable<invested_fromUpdateWithWhereUniqueWithoutStartupsInput>
    updateMany?: Enumerable<invested_fromUpdateManyWithWhereWithoutStartupsInput>
    deleteMany?: Enumerable<invested_fromScalarWhereInput>
    upsert?: Enumerable<invested_fromUpsertWithWhereUniqueWithoutStartupsInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutstartupsInput>
  }

  export type startup_imagesUpdateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<startup_imagesUncheckedCreateWithoutStartupsInput>, Enumerable<startup_imagesCreateWithoutStartupsInput>>
    connect?: Enumerable<startup_imagesWhereUniqueInput>
    set?: Enumerable<startup_imagesWhereUniqueInput>
    disconnect?: Enumerable<startup_imagesWhereUniqueInput>
    delete?: Enumerable<startup_imagesWhereUniqueInput>
    update?: Enumerable<startup_imagesUpdateWithWhereUniqueWithoutStartupsInput>
    updateMany?: Enumerable<startup_imagesUpdateManyWithWhereWithoutStartupsInput>
    deleteMany?: Enumerable<startup_imagesScalarWhereInput>
    upsert?: Enumerable<startup_imagesUpsertWithWhereUniqueWithoutStartupsInput>
    connectOrCreate?: Enumerable<startup_imagesCreateOrConnectWithoutstartupsInput>
  }

  export type wish_investment_seriesUpdateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<wish_investment_seriesUncheckedCreateWithoutStartupsInput>, Enumerable<wish_investment_seriesCreateWithoutStartupsInput>>
    connect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    set?: Enumerable<wish_investment_seriesWhereUniqueInput>
    disconnect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    delete?: Enumerable<wish_investment_seriesWhereUniqueInput>
    update?: Enumerable<wish_investment_seriesUpdateWithWhereUniqueWithoutStartupsInput>
    updateMany?: Enumerable<wish_investment_seriesUpdateManyWithWhereWithoutStartupsInput>
    deleteMany?: Enumerable<wish_investment_seriesScalarWhereInput>
    upsert?: Enumerable<wish_investment_seriesUpsertWithWhereUniqueWithoutStartupsInput>
    connectOrCreate?: Enumerable<wish_investment_seriesCreateOrConnectWithoutstartupsInput>
  }

  export type IR_requestsUpdateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutStartupsInput>, Enumerable<IR_requestsCreateWithoutStartupsInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    set?: Enumerable<IR_requestsWhereUniqueInput>
    disconnect?: Enumerable<IR_requestsWhereUniqueInput>
    delete?: Enumerable<IR_requestsWhereUniqueInput>
    update?: Enumerable<IR_requestsUpdateWithWhereUniqueWithoutStartupsInput>
    updateMany?: Enumerable<IR_requestsUpdateManyWithWhereWithoutStartupsInput>
    deleteMany?: Enumerable<IR_requestsScalarWhereInput>
    upsert?: Enumerable<IR_requestsUpsertWithWhereUniqueWithoutStartupsInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutstartupsInput>
  }

  export type invested_fromUncheckedUpdateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<invested_fromUncheckedCreateWithoutStartupsInput>, Enumerable<invested_fromCreateWithoutStartupsInput>>
    connect?: Enumerable<invested_fromWhereUniqueInput>
    set?: Enumerable<invested_fromWhereUniqueInput>
    disconnect?: Enumerable<invested_fromWhereUniqueInput>
    delete?: Enumerable<invested_fromWhereUniqueInput>
    update?: Enumerable<invested_fromUpdateWithWhereUniqueWithoutStartupsInput>
    updateMany?: Enumerable<invested_fromUpdateManyWithWhereWithoutStartupsInput>
    deleteMany?: Enumerable<invested_fromScalarWhereInput>
    upsert?: Enumerable<invested_fromUpsertWithWhereUniqueWithoutStartupsInput>
    connectOrCreate?: Enumerable<invested_fromCreateOrConnectWithoutstartupsInput>
  }

  export type startup_imagesUncheckedUpdateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<startup_imagesUncheckedCreateWithoutStartupsInput>, Enumerable<startup_imagesCreateWithoutStartupsInput>>
    connect?: Enumerable<startup_imagesWhereUniqueInput>
    set?: Enumerable<startup_imagesWhereUniqueInput>
    disconnect?: Enumerable<startup_imagesWhereUniqueInput>
    delete?: Enumerable<startup_imagesWhereUniqueInput>
    update?: Enumerable<startup_imagesUpdateWithWhereUniqueWithoutStartupsInput>
    updateMany?: Enumerable<startup_imagesUpdateManyWithWhereWithoutStartupsInput>
    deleteMany?: Enumerable<startup_imagesScalarWhereInput>
    upsert?: Enumerable<startup_imagesUpsertWithWhereUniqueWithoutStartupsInput>
    connectOrCreate?: Enumerable<startup_imagesCreateOrConnectWithoutstartupsInput>
  }

  export type wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<wish_investment_seriesUncheckedCreateWithoutStartupsInput>, Enumerable<wish_investment_seriesCreateWithoutStartupsInput>>
    connect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    set?: Enumerable<wish_investment_seriesWhereUniqueInput>
    disconnect?: Enumerable<wish_investment_seriesWhereUniqueInput>
    delete?: Enumerable<wish_investment_seriesWhereUniqueInput>
    update?: Enumerable<wish_investment_seriesUpdateWithWhereUniqueWithoutStartupsInput>
    updateMany?: Enumerable<wish_investment_seriesUpdateManyWithWhereWithoutStartupsInput>
    deleteMany?: Enumerable<wish_investment_seriesScalarWhereInput>
    upsert?: Enumerable<wish_investment_seriesUpsertWithWhereUniqueWithoutStartupsInput>
    connectOrCreate?: Enumerable<wish_investment_seriesCreateOrConnectWithoutstartupsInput>
  }

  export type IR_requestsUncheckedUpdateManyWithoutStartupsInput = {
    create?: XOR<Enumerable<IR_requestsUncheckedCreateWithoutStartupsInput>, Enumerable<IR_requestsCreateWithoutStartupsInput>>
    connect?: Enumerable<IR_requestsWhereUniqueInput>
    set?: Enumerable<IR_requestsWhereUniqueInput>
    disconnect?: Enumerable<IR_requestsWhereUniqueInput>
    delete?: Enumerable<IR_requestsWhereUniqueInput>
    update?: Enumerable<IR_requestsUpdateWithWhereUniqueWithoutStartupsInput>
    updateMany?: Enumerable<IR_requestsUpdateManyWithWhereWithoutStartupsInput>
    deleteMany?: Enumerable<IR_requestsScalarWhereInput>
    upsert?: Enumerable<IR_requestsUpsertWithWhereUniqueWithoutStartupsInput>
    connectOrCreate?: Enumerable<IR_requestsCreateOrConnectWithoutstartupsInput>
  }

  export type startupsCreateOneWithoutWish_investment_seriesInput = {
    create?: XOR<startupsUncheckedCreateWithoutWish_investment_seriesInput, startupsCreateWithoutWish_investment_seriesInput>
    connect?: startupsWhereUniqueInput
    connectOrCreate?: startupsCreateOrConnectWithoutwish_investment_seriesInput
  }

  export type investment_seriesCreateOneWithoutWish_investment_seriesInput = {
    create?: XOR<investment_seriesUncheckedCreateWithoutWish_investment_seriesInput, investment_seriesCreateWithoutWish_investment_seriesInput>
    connect?: investment_seriesWhereUniqueInput
    connectOrCreate?: investment_seriesCreateOrConnectWithoutwish_investment_seriesInput
  }

  export type startupsUpdateOneRequiredWithoutWish_investment_seriesInput = {
    create?: XOR<startupsUncheckedCreateWithoutWish_investment_seriesInput, startupsCreateWithoutWish_investment_seriesInput>
    connect?: startupsWhereUniqueInput
    update?: XOR<startupsUncheckedUpdateWithoutWish_investment_seriesInput, startupsUpdateWithoutWish_investment_seriesInput>
    upsert?: startupsUpsertWithoutWish_investment_seriesInput
    connectOrCreate?: startupsCreateOrConnectWithoutwish_investment_seriesInput
  }

  export type investment_seriesUpdateOneRequiredWithoutWish_investment_seriesInput = {
    create?: XOR<investment_seriesUncheckedCreateWithoutWish_investment_seriesInput, investment_seriesCreateWithoutWish_investment_seriesInput>
    connect?: investment_seriesWhereUniqueInput
    update?: XOR<investment_seriesUncheckedUpdateWithoutWish_investment_seriesInput, investment_seriesUpdateWithoutWish_investment_seriesInput>
    upsert?: investment_seriesUpsertWithoutWish_investment_seriesInput
    connectOrCreate?: investment_seriesCreateOrConnectWithoutwish_investment_seriesInput
  }

  export type companiesCreateOneWithoutStartup_likesInput = {
    create?: XOR<companiesUncheckedCreateWithoutStartup_likesInput, companiesCreateWithoutStartup_likesInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutstartup_likesInput
  }

  export type usersCreateOneWithoutStartup_likesInput = {
    create?: XOR<usersUncheckedCreateWithoutStartup_likesInput, usersCreateWithoutStartup_likesInput>
    connect?: usersWhereUniqueInput
    connectOrCreate?: usersCreateOrConnectWithoutstartup_likesInput
  }

  export type companiesUpdateOneRequiredWithoutStartup_likesInput = {
    create?: XOR<companiesUncheckedCreateWithoutStartup_likesInput, companiesCreateWithoutStartup_likesInput>
    connect?: companiesWhereUniqueInput
    update?: XOR<companiesUncheckedUpdateWithoutStartup_likesInput, companiesUpdateWithoutStartup_likesInput>
    upsert?: companiesUpsertWithoutStartup_likesInput
    connectOrCreate?: companiesCreateOrConnectWithoutstartup_likesInput
  }

  export type usersUpdateOneRequiredWithoutStartup_likesInput = {
    create?: XOR<usersUncheckedCreateWithoutStartup_likesInput, usersCreateWithoutStartup_likesInput>
    connect?: usersWhereUniqueInput
    update?: XOR<usersUncheckedUpdateWithoutStartup_likesInput, usersUpdateWithoutStartup_likesInput>
    upsert?: usersUpsertWithoutStartup_likesInput
    connectOrCreate?: usersCreateOrConnectWithoutstartup_likesInput
  }

  export type partnersCreateManyWithoutTechnologiesInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutTechnologiesInput>, Enumerable<partnersCreateWithoutTechnologiesInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithouttechnologiesInput>
  }

  export type startupsCreateManyWithoutTechnologiesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutTechnologiesInput>, Enumerable<startupsCreateWithoutTechnologiesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithouttechnologiesInput>
  }

  export type partnersUncheckedCreateManyWithoutTechnologiesInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutTechnologiesInput>, Enumerable<partnersCreateWithoutTechnologiesInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithouttechnologiesInput>
  }

  export type startupsUncheckedCreateManyWithoutTechnologiesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutTechnologiesInput>, Enumerable<startupsCreateWithoutTechnologiesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithouttechnologiesInput>
  }

  export type partnersUpdateManyWithoutTechnologiesInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutTechnologiesInput>, Enumerable<partnersCreateWithoutTechnologiesInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    set?: Enumerable<partnersWhereUniqueInput>
    disconnect?: Enumerable<partnersWhereUniqueInput>
    delete?: Enumerable<partnersWhereUniqueInput>
    update?: Enumerable<partnersUpdateWithWhereUniqueWithoutTechnologiesInput>
    updateMany?: Enumerable<partnersUpdateManyWithWhereWithoutTechnologiesInput>
    deleteMany?: Enumerable<partnersScalarWhereInput>
    upsert?: Enumerable<partnersUpsertWithWhereUniqueWithoutTechnologiesInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithouttechnologiesInput>
  }

  export type startupsUpdateManyWithoutTechnologiesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutTechnologiesInput>, Enumerable<startupsCreateWithoutTechnologiesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutTechnologiesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutTechnologiesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutTechnologiesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithouttechnologiesInput>
  }

  export type partnersUncheckedUpdateManyWithoutTechnologiesInput = {
    create?: XOR<Enumerable<partnersUncheckedCreateWithoutTechnologiesInput>, Enumerable<partnersCreateWithoutTechnologiesInput>>
    connect?: Enumerable<partnersWhereUniqueInput>
    set?: Enumerable<partnersWhereUniqueInput>
    disconnect?: Enumerable<partnersWhereUniqueInput>
    delete?: Enumerable<partnersWhereUniqueInput>
    update?: Enumerable<partnersUpdateWithWhereUniqueWithoutTechnologiesInput>
    updateMany?: Enumerable<partnersUpdateManyWithWhereWithoutTechnologiesInput>
    deleteMany?: Enumerable<partnersScalarWhereInput>
    upsert?: Enumerable<partnersUpsertWithWhereUniqueWithoutTechnologiesInput>
    connectOrCreate?: Enumerable<partnersCreateOrConnectWithouttechnologiesInput>
  }

  export type startupsUncheckedUpdateManyWithoutTechnologiesInput = {
    create?: XOR<Enumerable<startupsUncheckedCreateWithoutTechnologiesInput>, Enumerable<startupsCreateWithoutTechnologiesInput>>
    connect?: Enumerable<startupsWhereUniqueInput>
    set?: Enumerable<startupsWhereUniqueInput>
    disconnect?: Enumerable<startupsWhereUniqueInput>
    delete?: Enumerable<startupsWhereUniqueInput>
    update?: Enumerable<startupsUpdateWithWhereUniqueWithoutTechnologiesInput>
    updateMany?: Enumerable<startupsUpdateManyWithWhereWithoutTechnologiesInput>
    deleteMany?: Enumerable<startupsScalarWhereInput>
    upsert?: Enumerable<startupsUpsertWithWhereUniqueWithoutTechnologiesInput>
    connectOrCreate?: Enumerable<startupsCreateOrConnectWithouttechnologiesInput>
  }

  export type user_agreementsCreateManyWithoutTermsInput = {
    create?: XOR<Enumerable<user_agreementsUncheckedCreateWithoutTermsInput>, Enumerable<user_agreementsCreateWithoutTermsInput>>
    connect?: Enumerable<user_agreementsWhereUniqueInput>
    connectOrCreate?: Enumerable<user_agreementsCreateOrConnectWithouttermsInput>
  }

  export type user_agreementsUncheckedCreateManyWithoutTermsInput = {
    create?: XOR<Enumerable<user_agreementsUncheckedCreateWithoutTermsInput>, Enumerable<user_agreementsCreateWithoutTermsInput>>
    connect?: Enumerable<user_agreementsWhereUniqueInput>
    connectOrCreate?: Enumerable<user_agreementsCreateOrConnectWithouttermsInput>
  }

  export type user_agreementsUpdateManyWithoutTermsInput = {
    create?: XOR<Enumerable<user_agreementsUncheckedCreateWithoutTermsInput>, Enumerable<user_agreementsCreateWithoutTermsInput>>
    connect?: Enumerable<user_agreementsWhereUniqueInput>
    set?: Enumerable<user_agreementsWhereUniqueInput>
    disconnect?: Enumerable<user_agreementsWhereUniqueInput>
    delete?: Enumerable<user_agreementsWhereUniqueInput>
    update?: Enumerable<user_agreementsUpdateWithWhereUniqueWithoutTermsInput>
    updateMany?: Enumerable<user_agreementsUpdateManyWithWhereWithoutTermsInput>
    deleteMany?: Enumerable<user_agreementsScalarWhereInput>
    upsert?: Enumerable<user_agreementsUpsertWithWhereUniqueWithoutTermsInput>
    connectOrCreate?: Enumerable<user_agreementsCreateOrConnectWithouttermsInput>
  }

  export type user_agreementsUncheckedUpdateManyWithoutTermsInput = {
    create?: XOR<Enumerable<user_agreementsUncheckedCreateWithoutTermsInput>, Enumerable<user_agreementsCreateWithoutTermsInput>>
    connect?: Enumerable<user_agreementsWhereUniqueInput>
    set?: Enumerable<user_agreementsWhereUniqueInput>
    disconnect?: Enumerable<user_agreementsWhereUniqueInput>
    delete?: Enumerable<user_agreementsWhereUniqueInput>
    update?: Enumerable<user_agreementsUpdateWithWhereUniqueWithoutTermsInput>
    updateMany?: Enumerable<user_agreementsUpdateManyWithWhereWithoutTermsInput>
    deleteMany?: Enumerable<user_agreementsScalarWhereInput>
    upsert?: Enumerable<user_agreementsUpsertWithWhereUniqueWithoutTermsInput>
    connectOrCreate?: Enumerable<user_agreementsCreateOrConnectWithouttermsInput>
  }

  export type termsCreateOneWithoutUser_agreementsInput = {
    create?: XOR<termsUncheckedCreateWithoutUser_agreementsInput, termsCreateWithoutUser_agreementsInput>
    connect?: termsWhereUniqueInput
    connectOrCreate?: termsCreateOrConnectWithoutuser_agreementsInput
  }

  export type usersCreateOneWithoutUser_agreementsInput = {
    create?: XOR<usersUncheckedCreateWithoutUser_agreementsInput, usersCreateWithoutUser_agreementsInput>
    connect?: usersWhereUniqueInput
    connectOrCreate?: usersCreateOrConnectWithoutuser_agreementsInput
  }

  export type termsUpdateOneRequiredWithoutUser_agreementsInput = {
    create?: XOR<termsUncheckedCreateWithoutUser_agreementsInput, termsCreateWithoutUser_agreementsInput>
    connect?: termsWhereUniqueInput
    update?: XOR<termsUncheckedUpdateWithoutUser_agreementsInput, termsUpdateWithoutUser_agreementsInput>
    upsert?: termsUpsertWithoutUser_agreementsInput
    connectOrCreate?: termsCreateOrConnectWithoutuser_agreementsInput
  }

  export type usersUpdateOneRequiredWithoutUser_agreementsInput = {
    create?: XOR<usersUncheckedCreateWithoutUser_agreementsInput, usersCreateWithoutUser_agreementsInput>
    connect?: usersWhereUniqueInput
    update?: XOR<usersUncheckedUpdateWithoutUser_agreementsInput, usersUpdateWithoutUser_agreementsInput>
    upsert?: usersUpsertWithoutUser_agreementsInput
    connectOrCreate?: usersCreateOrConnectWithoutuser_agreementsInput
  }

  export type usersCreateManyWithoutUser_typesInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutUser_typesInput>, Enumerable<usersCreateWithoutUser_typesInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutuser_typesInput>
  }

  export type usersUncheckedCreateManyWithoutUser_typesInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutUser_typesInput>, Enumerable<usersCreateWithoutUser_typesInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutuser_typesInput>
  }

  export type usersUpdateManyWithoutUser_typesInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutUser_typesInput>, Enumerable<usersCreateWithoutUser_typesInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutUser_typesInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutUser_typesInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutUser_typesInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutuser_typesInput>
  }

  export type usersUncheckedUpdateManyWithoutUser_typesInput = {
    create?: XOR<Enumerable<usersUncheckedCreateWithoutUser_typesInput>, Enumerable<usersCreateWithoutUser_typesInput>>
    connect?: Enumerable<usersWhereUniqueInput>
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutUser_typesInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutUser_typesInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutUser_typesInput>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutuser_typesInput>
  }

  export type companiesCreateOneWithoutUsersInput = {
    create?: XOR<companiesUncheckedCreateWithoutUsersInput, companiesCreateWithoutUsersInput>
    connect?: companiesWhereUniqueInput
    connectOrCreate?: companiesCreateOrConnectWithoutusersInput
  }

  export type signup_methodsCreateOneWithoutUsersInput = {
    create?: XOR<signup_methodsUncheckedCreateWithoutUsersInput, signup_methodsCreateWithoutUsersInput>
    connect?: signup_methodsWhereUniqueInput
    connectOrCreate?: signup_methodsCreateOrConnectWithoutusersInput
  }

  export type user_typesCreateOneWithoutUsersInput = {
    create?: XOR<user_typesUncheckedCreateWithoutUsersInput, user_typesCreateWithoutUsersInput>
    connect?: user_typesWhereUniqueInput
    connectOrCreate?: user_typesCreateOrConnectWithoutusersInput
  }

  export type questionsCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutUsersInput>, Enumerable<questionsCreateWithoutUsersInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutusersInput>
  }

  export type startup_likesCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<startup_likesUncheckedCreateWithoutUsersInput>, Enumerable<startup_likesCreateWithoutUsersInput>>
    connect?: Enumerable<startup_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<startup_likesCreateOrConnectWithoutusersInput>
  }

  export type user_agreementsCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<user_agreementsUncheckedCreateWithoutUsersInput>, Enumerable<user_agreementsCreateWithoutUsersInput>>
    connect?: Enumerable<user_agreementsWhereUniqueInput>
    connectOrCreate?: Enumerable<user_agreementsCreateOrConnectWithoutusersInput>
  }

  export type votesCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<votesUncheckedCreateWithoutUsersInput>, Enumerable<votesCreateWithoutUsersInput>>
    connect?: Enumerable<votesWhereUniqueInput>
    connectOrCreate?: Enumerable<votesCreateOrConnectWithoutusersInput>
  }

  export type partner_likesCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<partner_likesUncheckedCreateWithoutUsersInput>, Enumerable<partner_likesCreateWithoutUsersInput>>
    connect?: Enumerable<partner_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<partner_likesCreateOrConnectWithoutusersInput>
  }

  export type project_likesCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutUsersInput>, Enumerable<project_likesCreateWithoutUsersInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutusersInput>
  }

  export type questionsUncheckedCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutUsersInput>, Enumerable<questionsCreateWithoutUsersInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutusersInput>
  }

  export type startup_likesUncheckedCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<startup_likesUncheckedCreateWithoutUsersInput>, Enumerable<startup_likesCreateWithoutUsersInput>>
    connect?: Enumerable<startup_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<startup_likesCreateOrConnectWithoutusersInput>
  }

  export type user_agreementsUncheckedCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<user_agreementsUncheckedCreateWithoutUsersInput>, Enumerable<user_agreementsCreateWithoutUsersInput>>
    connect?: Enumerable<user_agreementsWhereUniqueInput>
    connectOrCreate?: Enumerable<user_agreementsCreateOrConnectWithoutusersInput>
  }

  export type votesUncheckedCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<votesUncheckedCreateWithoutUsersInput>, Enumerable<votesCreateWithoutUsersInput>>
    connect?: Enumerable<votesWhereUniqueInput>
    connectOrCreate?: Enumerable<votesCreateOrConnectWithoutusersInput>
  }

  export type partner_likesUncheckedCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<partner_likesUncheckedCreateWithoutUsersInput>, Enumerable<partner_likesCreateWithoutUsersInput>>
    connect?: Enumerable<partner_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<partner_likesCreateOrConnectWithoutusersInput>
  }

  export type project_likesUncheckedCreateManyWithoutUsersInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutUsersInput>, Enumerable<project_likesCreateWithoutUsersInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutusersInput>
  }

  export type companiesUpdateOneWithoutUsersInput = {
    create?: XOR<companiesUncheckedCreateWithoutUsersInput, companiesCreateWithoutUsersInput>
    connect?: companiesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<companiesUncheckedUpdateWithoutUsersInput, companiesUpdateWithoutUsersInput>
    upsert?: companiesUpsertWithoutUsersInput
    connectOrCreate?: companiesCreateOrConnectWithoutusersInput
  }

  export type signup_methodsUpdateOneRequiredWithoutUsersInput = {
    create?: XOR<signup_methodsUncheckedCreateWithoutUsersInput, signup_methodsCreateWithoutUsersInput>
    connect?: signup_methodsWhereUniqueInput
    update?: XOR<signup_methodsUncheckedUpdateWithoutUsersInput, signup_methodsUpdateWithoutUsersInput>
    upsert?: signup_methodsUpsertWithoutUsersInput
    connectOrCreate?: signup_methodsCreateOrConnectWithoutusersInput
  }

  export type user_typesUpdateOneWithoutUsersInput = {
    create?: XOR<user_typesUncheckedCreateWithoutUsersInput, user_typesCreateWithoutUsersInput>
    connect?: user_typesWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<user_typesUncheckedUpdateWithoutUsersInput, user_typesUpdateWithoutUsersInput>
    upsert?: user_typesUpsertWithoutUsersInput
    connectOrCreate?: user_typesCreateOrConnectWithoutusersInput
  }

  export type questionsUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutUsersInput>, Enumerable<questionsCreateWithoutUsersInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    set?: Enumerable<questionsWhereUniqueInput>
    disconnect?: Enumerable<questionsWhereUniqueInput>
    delete?: Enumerable<questionsWhereUniqueInput>
    update?: Enumerable<questionsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<questionsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<questionsScalarWhereInput>
    upsert?: Enumerable<questionsUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutusersInput>
  }

  export type startup_likesUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<startup_likesUncheckedCreateWithoutUsersInput>, Enumerable<startup_likesCreateWithoutUsersInput>>
    connect?: Enumerable<startup_likesWhereUniqueInput>
    set?: Enumerable<startup_likesWhereUniqueInput>
    disconnect?: Enumerable<startup_likesWhereUniqueInput>
    delete?: Enumerable<startup_likesWhereUniqueInput>
    update?: Enumerable<startup_likesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<startup_likesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<startup_likesScalarWhereInput>
    upsert?: Enumerable<startup_likesUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<startup_likesCreateOrConnectWithoutusersInput>
  }

  export type user_agreementsUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<user_agreementsUncheckedCreateWithoutUsersInput>, Enumerable<user_agreementsCreateWithoutUsersInput>>
    connect?: Enumerable<user_agreementsWhereUniqueInput>
    set?: Enumerable<user_agreementsWhereUniqueInput>
    disconnect?: Enumerable<user_agreementsWhereUniqueInput>
    delete?: Enumerable<user_agreementsWhereUniqueInput>
    update?: Enumerable<user_agreementsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<user_agreementsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<user_agreementsScalarWhereInput>
    upsert?: Enumerable<user_agreementsUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<user_agreementsCreateOrConnectWithoutusersInput>
  }

  export type votesUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<votesUncheckedCreateWithoutUsersInput>, Enumerable<votesCreateWithoutUsersInput>>
    connect?: Enumerable<votesWhereUniqueInput>
    set?: Enumerable<votesWhereUniqueInput>
    disconnect?: Enumerable<votesWhereUniqueInput>
    delete?: Enumerable<votesWhereUniqueInput>
    update?: Enumerable<votesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<votesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<votesScalarWhereInput>
    upsert?: Enumerable<votesUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<votesCreateOrConnectWithoutusersInput>
  }

  export type partner_likesUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<partner_likesUncheckedCreateWithoutUsersInput>, Enumerable<partner_likesCreateWithoutUsersInput>>
    connect?: Enumerable<partner_likesWhereUniqueInput>
    set?: Enumerable<partner_likesWhereUniqueInput>
    disconnect?: Enumerable<partner_likesWhereUniqueInput>
    delete?: Enumerable<partner_likesWhereUniqueInput>
    update?: Enumerable<partner_likesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<partner_likesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<partner_likesScalarWhereInput>
    upsert?: Enumerable<partner_likesUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<partner_likesCreateOrConnectWithoutusersInput>
  }

  export type project_likesUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutUsersInput>, Enumerable<project_likesCreateWithoutUsersInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    set?: Enumerable<project_likesWhereUniqueInput>
    disconnect?: Enumerable<project_likesWhereUniqueInput>
    delete?: Enumerable<project_likesWhereUniqueInput>
    update?: Enumerable<project_likesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<project_likesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<project_likesScalarWhereInput>
    upsert?: Enumerable<project_likesUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutusersInput>
  }

  export type questionsUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<questionsUncheckedCreateWithoutUsersInput>, Enumerable<questionsCreateWithoutUsersInput>>
    connect?: Enumerable<questionsWhereUniqueInput>
    set?: Enumerable<questionsWhereUniqueInput>
    disconnect?: Enumerable<questionsWhereUniqueInput>
    delete?: Enumerable<questionsWhereUniqueInput>
    update?: Enumerable<questionsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<questionsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<questionsScalarWhereInput>
    upsert?: Enumerable<questionsUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<questionsCreateOrConnectWithoutusersInput>
  }

  export type startup_likesUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<startup_likesUncheckedCreateWithoutUsersInput>, Enumerable<startup_likesCreateWithoutUsersInput>>
    connect?: Enumerable<startup_likesWhereUniqueInput>
    set?: Enumerable<startup_likesWhereUniqueInput>
    disconnect?: Enumerable<startup_likesWhereUniqueInput>
    delete?: Enumerable<startup_likesWhereUniqueInput>
    update?: Enumerable<startup_likesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<startup_likesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<startup_likesScalarWhereInput>
    upsert?: Enumerable<startup_likesUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<startup_likesCreateOrConnectWithoutusersInput>
  }

  export type user_agreementsUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<user_agreementsUncheckedCreateWithoutUsersInput>, Enumerable<user_agreementsCreateWithoutUsersInput>>
    connect?: Enumerable<user_agreementsWhereUniqueInput>
    set?: Enumerable<user_agreementsWhereUniqueInput>
    disconnect?: Enumerable<user_agreementsWhereUniqueInput>
    delete?: Enumerable<user_agreementsWhereUniqueInput>
    update?: Enumerable<user_agreementsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<user_agreementsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<user_agreementsScalarWhereInput>
    upsert?: Enumerable<user_agreementsUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<user_agreementsCreateOrConnectWithoutusersInput>
  }

  export type votesUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<votesUncheckedCreateWithoutUsersInput>, Enumerable<votesCreateWithoutUsersInput>>
    connect?: Enumerable<votesWhereUniqueInput>
    set?: Enumerable<votesWhereUniqueInput>
    disconnect?: Enumerable<votesWhereUniqueInput>
    delete?: Enumerable<votesWhereUniqueInput>
    update?: Enumerable<votesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<votesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<votesScalarWhereInput>
    upsert?: Enumerable<votesUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<votesCreateOrConnectWithoutusersInput>
  }

  export type partner_likesUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<partner_likesUncheckedCreateWithoutUsersInput>, Enumerable<partner_likesCreateWithoutUsersInput>>
    connect?: Enumerable<partner_likesWhereUniqueInput>
    set?: Enumerable<partner_likesWhereUniqueInput>
    disconnect?: Enumerable<partner_likesWhereUniqueInput>
    delete?: Enumerable<partner_likesWhereUniqueInput>
    update?: Enumerable<partner_likesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<partner_likesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<partner_likesScalarWhereInput>
    upsert?: Enumerable<partner_likesUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<partner_likesCreateOrConnectWithoutusersInput>
  }

  export type project_likesUncheckedUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<project_likesUncheckedCreateWithoutUsersInput>, Enumerable<project_likesCreateWithoutUsersInput>>
    connect?: Enumerable<project_likesWhereUniqueInput>
    set?: Enumerable<project_likesWhereUniqueInput>
    disconnect?: Enumerable<project_likesWhereUniqueInput>
    delete?: Enumerable<project_likesWhereUniqueInput>
    update?: Enumerable<project_likesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<project_likesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<project_likesScalarWhereInput>
    upsert?: Enumerable<project_likesUpsertWithWhereUniqueWithoutUsersInput>
    connectOrCreate?: Enumerable<project_likesCreateOrConnectWithoutusersInput>
  }

  export type participantsCreateOneWithoutVotesInput = {
    create?: XOR<participantsUncheckedCreateWithoutVotesInput, participantsCreateWithoutVotesInput>
    connect?: participantsWhereUniqueInput
    connectOrCreate?: participantsCreateOrConnectWithoutvotesInput
  }

  export type usersCreateOneWithoutVotesInput = {
    create?: XOR<usersUncheckedCreateWithoutVotesInput, usersCreateWithoutVotesInput>
    connect?: usersWhereUniqueInput
    connectOrCreate?: usersCreateOrConnectWithoutvotesInput
  }

  export type participantsUpdateOneRequiredWithoutVotesInput = {
    create?: XOR<participantsUncheckedCreateWithoutVotesInput, participantsCreateWithoutVotesInput>
    connect?: participantsWhereUniqueInput
    update?: XOR<participantsUncheckedUpdateWithoutVotesInput, participantsUpdateWithoutVotesInput>
    upsert?: participantsUpsertWithoutVotesInput
    connectOrCreate?: participantsCreateOrConnectWithoutvotesInput
  }

  export type usersUpdateOneRequiredWithoutVotesInput = {
    create?: XOR<usersUncheckedCreateWithoutVotesInput, usersCreateWithoutVotesInput>
    connect?: usersWhereUniqueInput
    update?: XOR<usersUncheckedUpdateWithoutVotesInput, usersUpdateWithoutVotesInput>
    upsert?: usersUpsertWithoutVotesInput
    connectOrCreate?: usersCreateOrConnectWithoutvotesInput
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type questionsCreateWithoutAnswersInput = {
    content: string
    created_at: Date | string
    updated_at: Date | string
    companies: companiesCreateOneWithoutQuestionsInput
    demodays: demodaysCreateOneWithoutQuestionsInput
    users: usersCreateOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutAnswersInput = {
    id?: number
    content: string
    company_id: number
    user_id: number
    created_at: Date | string
    updated_at: Date | string
    demoday_id: number
  }

  export type questionsCreateOrConnectWithoutanswersInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsUncheckedCreateWithoutAnswersInput, questionsCreateWithoutAnswersInput>
  }

  export type questionsUpdateWithoutAnswersInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutQuestionsInput
    demodays?: demodaysUpdateOneRequiredWithoutQuestionsInput
    users?: usersUpdateOneRequiredWithoutQuestionsInput
  }

  export type questionsUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demoday_id?: IntFieldUpdateOperationsInput | number
  }

  export type questionsUpsertWithoutAnswersInput = {
    update: XOR<questionsUncheckedUpdateWithoutAnswersInput, questionsUpdateWithoutAnswersInput>
    create: XOR<questionsUncheckedCreateWithoutAnswersInput, questionsCreateWithoutAnswersInput>
  }

  export type companiesCreateWithoutApplicantsInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutApplicantsInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutapplicantsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutApplicantsInput, companiesCreateWithoutApplicantsInput>
  }

  export type projectsCreateWithoutApplicantsInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligible_sectors?: eligible_sectorsCreateOneWithoutProjectsInput
    eligibilities?: eligibilitiesCreateOneWithoutProjectsInput
    companies?: companiesCreateOneWithoutProjectsInput
    project_images?: project_imagesCreateManyWithoutProjectsInput
    project_likes?: project_likesCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectCreateManyWithoutProjectsInput
    required_documents?: required_documentsCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutApplicantsInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    company_id?: number | null
    host?: string | null
    due_date?: Date | string | null
    eligible_sector?: number | null
    eligibility?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    project_images?: project_imagesUncheckedCreateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutapplicantsInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsUncheckedCreateWithoutApplicantsInput, projectsCreateWithoutApplicantsInput>
  }

  export type applicant_documentsCreateWithoutApplicantsInput = {
    company_documents: company_documentsCreateOneWithoutApplicant_documentsInput
  }

  export type applicant_documentsUncheckedCreateWithoutApplicantsInput = {
    id?: number
    document_id: number
  }

  export type applicant_documentsCreateOrConnectWithoutapplicantsInput = {
    where: applicant_documentsWhereUniqueInput
    create: XOR<applicant_documentsUncheckedCreateWithoutApplicantsInput, applicant_documentsCreateWithoutApplicantsInput>
  }

  export type companiesUpdateWithoutApplicantsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutApplicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutApplicantsInput = {
    update: XOR<companiesUncheckedUpdateWithoutApplicantsInput, companiesUpdateWithoutApplicantsInput>
    create: XOR<companiesUncheckedCreateWithoutApplicantsInput, companiesCreateWithoutApplicantsInput>
  }

  export type projectsUpdateWithoutApplicantsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sectors?: eligible_sectorsUpdateOneWithoutProjectsInput
    eligibilities?: eligibilitiesUpdateOneWithoutProjectsInput
    companies?: companiesUpdateOneWithoutProjectsInput
    project_images?: project_imagesUpdateManyWithoutProjectsInput
    project_likes?: project_likesUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateWithoutApplicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project_images?: project_imagesUncheckedUpdateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutProjectsInput
  }

  export type projectsUpsertWithoutApplicantsInput = {
    update: XOR<projectsUncheckedUpdateWithoutApplicantsInput, projectsUpdateWithoutApplicantsInput>
    create: XOR<projectsUncheckedCreateWithoutApplicantsInput, projectsCreateWithoutApplicantsInput>
  }

  export type applicant_documentsUpdateWithWhereUniqueWithoutApplicantsInput = {
    where: applicant_documentsWhereUniqueInput
    data: XOR<applicant_documentsUncheckedUpdateWithoutApplicantsInput, applicant_documentsUpdateWithoutApplicantsInput>
  }

  export type applicant_documentsUpdateManyWithWhereWithoutApplicantsInput = {
    where: applicant_documentsScalarWhereInput
    data: XOR<applicant_documentsUncheckedUpdateManyWithoutApplicant_documentsInput, applicant_documentsUpdateManyMutationInput>
  }

  export type applicant_documentsScalarWhereInput = {
    AND?: Enumerable<applicant_documentsScalarWhereInput>
    OR?: Enumerable<applicant_documentsScalarWhereInput>
    NOT?: Enumerable<applicant_documentsScalarWhereInput>
    id?: IntFilter | number
    applicant_id?: IntFilter | number
    document_id?: IntFilter | number
  }

  export type applicant_documentsUpsertWithWhereUniqueWithoutApplicantsInput = {
    where: applicant_documentsWhereUniqueInput
    update: XOR<applicant_documentsUncheckedUpdateWithoutApplicantsInput, applicant_documentsUpdateWithoutApplicantsInput>
    create: XOR<applicant_documentsUncheckedCreateWithoutApplicantsInput, applicant_documentsCreateWithoutApplicantsInput>
  }

  export type applicantsCreateWithoutApplicant_documentsInput = {
    business_brief?: string | null
    business_model?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutApplicantsInput
    projects: projectsCreateOneWithoutApplicantsInput
  }

  export type applicantsUncheckedCreateWithoutApplicant_documentsInput = {
    id?: number
    company_id: number
    project_id: number
    business_brief?: string | null
    business_model?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type applicantsCreateOrConnectWithoutapplicant_documentsInput = {
    where: applicantsWhereUniqueInput
    create: XOR<applicantsUncheckedCreateWithoutApplicant_documentsInput, applicantsCreateWithoutApplicant_documentsInput>
  }

  export type company_documentsCreateWithoutApplicant_documentsInput = {
    doc_url: string
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutCompany_documentsInput
    document_types: document_typesCreateOneWithoutCompany_documentsInput
    IR_requests?: IR_requestsCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedCreateWithoutApplicant_documentsInput = {
    id?: number
    company_id: number
    doc_url: string
    type_id: number
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsCreateOrConnectWithoutapplicant_documentsInput = {
    where: company_documentsWhereUniqueInput
    create: XOR<company_documentsUncheckedCreateWithoutApplicant_documentsInput, company_documentsCreateWithoutApplicant_documentsInput>
  }

  export type applicantsUpdateWithoutApplicant_documentsInput = {
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutApplicantsInput
    projects?: projectsUpdateOneRequiredWithoutApplicantsInput
  }

  export type applicantsUncheckedUpdateWithoutApplicant_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicantsUpsertWithoutApplicant_documentsInput = {
    update: XOR<applicantsUncheckedUpdateWithoutApplicant_documentsInput, applicantsUpdateWithoutApplicant_documentsInput>
    create: XOR<applicantsUncheckedCreateWithoutApplicant_documentsInput, applicantsCreateWithoutApplicant_documentsInput>
  }

  export type company_documentsUpdateWithoutApplicant_documentsInput = {
    doc_url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_documentsInput
    document_types?: document_typesUpdateOneRequiredWithoutCompany_documentsInput
    IR_requests?: IR_requestsUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedUpdateWithoutApplicant_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    doc_url?: StringFieldUpdateOperationsInput | string
    type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUpsertWithoutApplicant_documentsInput = {
    update: XOR<company_documentsUncheckedUpdateWithoutApplicant_documentsInput, company_documentsUpdateWithoutApplicant_documentsInput>
    create: XOR<company_documentsUncheckedCreateWithoutApplicant_documentsInput, company_documentsCreateWithoutApplicant_documentsInput>
  }

  export type startupsCreateWithoutBusiness_typesInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutBusiness_typesInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutbusiness_typesInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutBusiness_typesInput, startupsCreateWithoutBusiness_typesInput>
  }

  export type startupsUpdateWithWhereUniqueWithoutBusiness_typesInput = {
    where: startupsWhereUniqueInput
    data: XOR<startupsUncheckedUpdateWithoutBusiness_typesInput, startupsUpdateWithoutBusiness_typesInput>
  }

  export type startupsUpdateManyWithWhereWithoutBusiness_typesInput = {
    where: startupsScalarWhereInput
    data: XOR<startupsUncheckedUpdateManyWithoutStartupsInput, startupsUpdateManyMutationInput>
  }

  export type startupsScalarWhereInput = {
    AND?: Enumerable<startupsScalarWhereInput>
    OR?: Enumerable<startupsScalarWhereInput>
    NOT?: Enumerable<startupsScalarWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    rep?: StringNullableFilter | string | null
    sector_id?: IntNullableFilter | number | null
    core_technology_id?: IntNullableFilter | number | null
    item_description?: StringNullableFilter | string | null
    contact?: StringNullableFilter | string | null
    investment_series_id?: IntNullableFilter | number | null
    investment_fund_id?: IntNullableFilter | number | null
    address_road?: StringNullableFilter | string | null
    address_detail?: StringNullableFilter | string | null
    service_type_id?: IntNullableFilter | number | null
    business_type_id?: IntNullableFilter | number | null
    business_license_number?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    instagram_url?: StringNullableFilter | string | null
    facebook_url?: StringNullableFilter | string | null
    thumbnail?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type startupsUpsertWithWhereUniqueWithoutBusiness_typesInput = {
    where: startupsWhereUniqueInput
    update: XOR<startupsUncheckedUpdateWithoutBusiness_typesInput, startupsUpdateWithoutBusiness_typesInput>
    create: XOR<startupsUncheckedCreateWithoutBusiness_typesInput, startupsCreateWithoutBusiness_typesInput>
  }

  export type company_typesCreateWithoutCompaniesInput = {
    name: string
  }

  export type company_typesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    name: string
  }

  export type company_typesCreateOrConnectWithoutcompaniesInput = {
    where: company_typesWhereUniqueInput
    create: XOR<company_typesUncheckedCreateWithoutCompaniesInput, company_typesCreateWithoutCompaniesInput>
  }

  export type applicantsCreateWithoutCompaniesInput = {
    business_brief?: string | null
    business_model?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    projects: projectsCreateOneWithoutApplicantsInput
    applicant_documents?: applicant_documentsCreateManyWithoutApplicantsInput
  }

  export type applicantsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    project_id: number
    business_brief?: string | null
    business_model?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicant_documents?: applicant_documentsUncheckedCreateManyWithoutApplicantsInput
  }

  export type applicantsCreateOrConnectWithoutcompaniesInput = {
    where: applicantsWhereUniqueInput
    create: XOR<applicantsUncheckedCreateWithoutCompaniesInput, applicantsCreateWithoutCompaniesInput>
  }

  export type company_documentsCreateWithoutCompaniesInput = {
    doc_url: string
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    document_types: document_typesCreateOneWithoutCompany_documentsInput
    IR_requests?: IR_requestsCreateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    doc_url: string
    type_id: number
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUncheckedCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsCreateOrConnectWithoutcompaniesInput = {
    where: company_documentsWhereUniqueInput
    create: XOR<company_documentsUncheckedCreateWithoutCompaniesInput, company_documentsCreateWithoutCompaniesInput>
  }

  export type company_membersCreateWithoutCompaniesInput = {
    name?: string | null
    img?: string | null
    position?: string | null
  }

  export type company_membersUncheckedCreateWithoutCompaniesInput = {
    id?: number
    name?: string | null
    img?: string | null
    position?: string | null
  }

  export type company_membersCreateOrConnectWithoutcompaniesInput = {
    where: company_membersWhereUniqueInput
    create: XOR<company_membersUncheckedCreateWithoutCompaniesInput, company_membersCreateWithoutCompaniesInput>
  }

  export type company_newsCreateWithoutCompaniesInput = {
    URL: string
  }

  export type company_newsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    URL: string
  }

  export type company_newsCreateOrConnectWithoutcompaniesInput = {
    where: company_newsWhereUniqueInput
    create: XOR<company_newsUncheckedCreateWithoutCompaniesInput, company_newsCreateWithoutCompaniesInput>
  }

  export type demodaysCreateWithoutCompaniesInput = {
    name?: string | null
    streaming_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    participants?: participantsCreateManyWithoutDemodaysInput
    questions?: questionsCreateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedCreateWithoutCompaniesInput = {
    id?: number
    name?: string | null
    streaming_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    participants?: participantsUncheckedCreateManyWithoutDemodaysInput
    questions?: questionsUncheckedCreateManyWithoutDemodaysInput
  }

  export type demodaysCreateOrConnectWithoutcompaniesInput = {
    where: demodaysWhereUniqueInput
    create: XOR<demodaysUncheckedCreateWithoutCompaniesInput, demodaysCreateWithoutCompaniesInput>
  }

  export type IR_requestsCreateWithoutCompaniesInput = {
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    company_documents?: company_documentsCreateOneWithoutIR_requestsInput
    partners: partnersCreateOneWithoutIR_requestsInput
    startups: startupsCreateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    startup_id: number
    partner_id: number
    document_id?: number | null
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type IR_requestsCreateOrConnectWithoutcompaniesInput = {
    where: IR_requestsWhereUniqueInput
    create: XOR<IR_requestsUncheckedCreateWithoutCompaniesInput, IR_requestsCreateWithoutCompaniesInput>
  }

  export type participantsCreateWithoutCompaniesInput = {
    order: number
    demodays: demodaysCreateOneWithoutParticipantsInput
    votes?: votesCreateManyWithoutParticipantsInput
  }

  export type participantsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    demoday_id: number
    order: number
    votes?: votesUncheckedCreateManyWithoutParticipantsInput
  }

  export type participantsCreateOrConnectWithoutcompaniesInput = {
    where: participantsWhereUniqueInput
    create: XOR<participantsUncheckedCreateWithoutCompaniesInput, participantsCreateWithoutCompaniesInput>
  }

  export type partnersCreateWithoutCompaniesInput = {
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    technologies?: technologiesCreateOneWithoutPartnersInput
    investment_funds?: investment_fundsCreateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsCreateManyWithoutPartnersInput
    invested_to?: invested_toCreateManyWithoutPartnersInput
  }

  export type partnersUncheckedCreateWithoutCompaniesInput = {
    id?: number
    interst_technology_id?: number | null
    invested_total_id?: number | null
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    investment_portfolio?: investment_portfolioUncheckedCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedCreateManyWithoutPartnersInput
  }

  export type partnersCreateOrConnectWithoutcompaniesInput = {
    where: partnersWhereUniqueInput
    create: XOR<partnersUncheckedCreateWithoutCompaniesInput, partnersCreateWithoutCompaniesInput>
  }

  export type partner_likesCreateWithoutCompaniesInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateOneWithoutPartner_likesInput
  }

  export type partner_likesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    user_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type partner_likesCreateOrConnectWithoutcompaniesInput = {
    where: partner_likesWhereUniqueInput
    create: XOR<partner_likesUncheckedCreateWithoutCompaniesInput, partner_likesCreateWithoutCompaniesInput>
  }

  export type project_likesCreateWithoutCompaniesInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateOneWithoutProject_likesInput
    projects: projectsCreateOneWithoutProject_likesInput
  }

  export type project_likesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    user_id: number
    project_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type project_likesCreateOrConnectWithoutcompaniesInput = {
    where: project_likesWhereUniqueInput
    create: XOR<project_likesUncheckedCreateWithoutCompaniesInput, project_likesCreateWithoutCompaniesInput>
  }

  export type projectsCreateWithoutCompaniesInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligible_sectors?: eligible_sectorsCreateOneWithoutProjectsInput
    eligibilities?: eligibilitiesCreateOneWithoutProjectsInput
    applicants?: applicantsCreateManyWithoutProjectsInput
    project_images?: project_imagesCreateManyWithoutProjectsInput
    project_likes?: project_likesCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectCreateManyWithoutProjectsInput
    required_documents?: required_documentsCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    eligible_sector?: number | null
    eligibility?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedCreateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutcompaniesInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsUncheckedCreateWithoutCompaniesInput, projectsCreateWithoutCompaniesInput>
  }

  export type questionsCreateWithoutCompaniesInput = {
    content: string
    created_at: Date | string
    updated_at: Date | string
    demodays: demodaysCreateOneWithoutQuestionsInput
    users: usersCreateOneWithoutQuestionsInput
    answers?: answersCreateManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    content: string
    user_id: number
    created_at: Date | string
    updated_at: Date | string
    demoday_id: number
    answers?: answersUncheckedCreateManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutcompaniesInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsUncheckedCreateWithoutCompaniesInput, questionsCreateWithoutCompaniesInput>
  }

  export type recent_views_projectCreateWithoutCompaniesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    projects: projectsCreateOneWithoutRecent_views_projectInput
  }

  export type recent_views_projectUncheckedCreateWithoutCompaniesInput = {
    id?: number
    project_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type recent_views_projectCreateOrConnectWithoutcompaniesInput = {
    where: recent_views_projectWhereUniqueInput
    create: XOR<recent_views_projectUncheckedCreateWithoutCompaniesInput, recent_views_projectCreateWithoutCompaniesInput>
  }

  export type startupsCreateWithoutCompaniesInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutcompaniesInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutCompaniesInput, startupsCreateWithoutCompaniesInput>
  }

  export type startup_likesCreateWithoutCompaniesInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateOneWithoutStartup_likesInput
  }

  export type startup_likesUncheckedCreateWithoutCompaniesInput = {
    id?: number
    user_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type startup_likesCreateOrConnectWithoutcompaniesInput = {
    where: startup_likesWhereUniqueInput
    create: XOR<startup_likesUncheckedCreateWithoutCompaniesInput, startup_likesCreateWithoutCompaniesInput>
  }

  export type usersCreateWithoutCompaniesInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCompaniesInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutcompaniesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutCompaniesInput, usersCreateWithoutCompaniesInput>
  }

  export type company_typesUpdateWithoutCompaniesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type company_typesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type company_typesUpsertWithoutCompaniesInput = {
    update: XOR<company_typesUncheckedUpdateWithoutCompaniesInput, company_typesUpdateWithoutCompaniesInput>
    create: XOR<company_typesUncheckedCreateWithoutCompaniesInput, company_typesCreateWithoutCompaniesInput>
  }

  export type applicantsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: applicantsWhereUniqueInput
    data: XOR<applicantsUncheckedUpdateWithoutCompaniesInput, applicantsUpdateWithoutCompaniesInput>
  }

  export type applicantsUpdateManyWithWhereWithoutCompaniesInput = {
    where: applicantsScalarWhereInput
    data: XOR<applicantsUncheckedUpdateManyWithoutApplicantsInput, applicantsUpdateManyMutationInput>
  }

  export type applicantsScalarWhereInput = {
    AND?: Enumerable<applicantsScalarWhereInput>
    OR?: Enumerable<applicantsScalarWhereInput>
    NOT?: Enumerable<applicantsScalarWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    project_id?: IntFilter | number
    business_brief?: StringNullableFilter | string | null
    business_model?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type applicantsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: applicantsWhereUniqueInput
    update: XOR<applicantsUncheckedUpdateWithoutCompaniesInput, applicantsUpdateWithoutCompaniesInput>
    create: XOR<applicantsUncheckedCreateWithoutCompaniesInput, applicantsCreateWithoutCompaniesInput>
  }

  export type company_documentsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_documentsWhereUniqueInput
    data: XOR<company_documentsUncheckedUpdateWithoutCompaniesInput, company_documentsUpdateWithoutCompaniesInput>
  }

  export type company_documentsUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_documentsScalarWhereInput
    data: XOR<company_documentsUncheckedUpdateManyWithoutCompany_documentsInput, company_documentsUpdateManyMutationInput>
  }

  export type company_documentsScalarWhereInput = {
    AND?: Enumerable<company_documentsScalarWhereInput>
    OR?: Enumerable<company_documentsScalarWhereInput>
    NOT?: Enumerable<company_documentsScalarWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    doc_url?: StringFilter | string
    type_id?: IntFilter | number
    name?: StringFilter | string
    file_type?: StringFilter | string
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type company_documentsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_documentsWhereUniqueInput
    update: XOR<company_documentsUncheckedUpdateWithoutCompaniesInput, company_documentsUpdateWithoutCompaniesInput>
    create: XOR<company_documentsUncheckedCreateWithoutCompaniesInput, company_documentsCreateWithoutCompaniesInput>
  }

  export type company_membersUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_membersWhereUniqueInput
    data: XOR<company_membersUncheckedUpdateWithoutCompaniesInput, company_membersUpdateWithoutCompaniesInput>
  }

  export type company_membersUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_membersScalarWhereInput
    data: XOR<company_membersUncheckedUpdateManyWithoutCompany_membersInput, company_membersUpdateManyMutationInput>
  }

  export type company_membersScalarWhereInput = {
    AND?: Enumerable<company_membersScalarWhereInput>
    OR?: Enumerable<company_membersScalarWhereInput>
    NOT?: Enumerable<company_membersScalarWhereInput>
    id?: IntFilter | number
    company_id?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    img?: StringNullableFilter | string | null
    position?: StringNullableFilter | string | null
  }

  export type company_membersUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_membersWhereUniqueInput
    update: XOR<company_membersUncheckedUpdateWithoutCompaniesInput, company_membersUpdateWithoutCompaniesInput>
    create: XOR<company_membersUncheckedCreateWithoutCompaniesInput, company_membersCreateWithoutCompaniesInput>
  }

  export type company_newsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_newsWhereUniqueInput
    data: XOR<company_newsUncheckedUpdateWithoutCompaniesInput, company_newsUpdateWithoutCompaniesInput>
  }

  export type company_newsUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_newsScalarWhereInput
    data: XOR<company_newsUncheckedUpdateManyWithoutCompany_newsInput, company_newsUpdateManyMutationInput>
  }

  export type company_newsScalarWhereInput = {
    AND?: Enumerable<company_newsScalarWhereInput>
    OR?: Enumerable<company_newsScalarWhereInput>
    NOT?: Enumerable<company_newsScalarWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    URL?: StringFilter | string
  }

  export type company_newsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_newsWhereUniqueInput
    update: XOR<company_newsUncheckedUpdateWithoutCompaniesInput, company_newsUpdateWithoutCompaniesInput>
    create: XOR<company_newsUncheckedCreateWithoutCompaniesInput, company_newsCreateWithoutCompaniesInput>
  }

  export type demodaysUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: demodaysWhereUniqueInput
    data: XOR<demodaysUncheckedUpdateWithoutCompaniesInput, demodaysUpdateWithoutCompaniesInput>
  }

  export type demodaysUpdateManyWithWhereWithoutCompaniesInput = {
    where: demodaysScalarWhereInput
    data: XOR<demodaysUncheckedUpdateManyWithoutDemodaysInput, demodaysUpdateManyMutationInput>
  }

  export type demodaysScalarWhereInput = {
    AND?: Enumerable<demodaysScalarWhereInput>
    OR?: Enumerable<demodaysScalarWhereInput>
    NOT?: Enumerable<demodaysScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    company_id?: IntNullableFilter | number | null
    streaming_url?: StringNullableFilter | string | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type demodaysUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: demodaysWhereUniqueInput
    update: XOR<demodaysUncheckedUpdateWithoutCompaniesInput, demodaysUpdateWithoutCompaniesInput>
    create: XOR<demodaysUncheckedCreateWithoutCompaniesInput, demodaysCreateWithoutCompaniesInput>
  }

  export type IR_requestsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: IR_requestsWhereUniqueInput
    data: XOR<IR_requestsUncheckedUpdateWithoutCompaniesInput, IR_requestsUpdateWithoutCompaniesInput>
  }

  export type IR_requestsUpdateManyWithWhereWithoutCompaniesInput = {
    where: IR_requestsScalarWhereInput
    data: XOR<IR_requestsUncheckedUpdateManyWithoutIR_requestsInput, IR_requestsUpdateManyMutationInput>
  }

  export type IR_requestsScalarWhereInput = {
    AND?: Enumerable<IR_requestsScalarWhereInput>
    OR?: Enumerable<IR_requestsScalarWhereInput>
    NOT?: Enumerable<IR_requestsScalarWhereInput>
    id?: IntFilter | number
    startup_id?: IntFilter | number
    partner_id?: IntFilter | number
    document_id?: IntNullableFilter | number | null
    is_checked?: IntFilter | number
    from_partner?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    companiesId?: IntNullableFilter | number | null
  }

  export type IR_requestsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: IR_requestsWhereUniqueInput
    update: XOR<IR_requestsUncheckedUpdateWithoutCompaniesInput, IR_requestsUpdateWithoutCompaniesInput>
    create: XOR<IR_requestsUncheckedCreateWithoutCompaniesInput, IR_requestsCreateWithoutCompaniesInput>
  }

  export type participantsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: participantsWhereUniqueInput
    data: XOR<participantsUncheckedUpdateWithoutCompaniesInput, participantsUpdateWithoutCompaniesInput>
  }

  export type participantsUpdateManyWithWhereWithoutCompaniesInput = {
    where: participantsScalarWhereInput
    data: XOR<participantsUncheckedUpdateManyWithoutParticipantsInput, participantsUpdateManyMutationInput>
  }

  export type participantsScalarWhereInput = {
    AND?: Enumerable<participantsScalarWhereInput>
    OR?: Enumerable<participantsScalarWhereInput>
    NOT?: Enumerable<participantsScalarWhereInput>
    id?: IntFilter | number
    demoday_id?: IntFilter | number
    order?: IntFilter | number
    company_id?: IntFilter | number
  }

  export type participantsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: participantsWhereUniqueInput
    update: XOR<participantsUncheckedUpdateWithoutCompaniesInput, participantsUpdateWithoutCompaniesInput>
    create: XOR<participantsUncheckedCreateWithoutCompaniesInput, participantsCreateWithoutCompaniesInput>
  }

  export type partnersUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: partnersWhereUniqueInput
    data: XOR<partnersUncheckedUpdateWithoutCompaniesInput, partnersUpdateWithoutCompaniesInput>
  }

  export type partnersUpdateManyWithWhereWithoutCompaniesInput = {
    where: partnersScalarWhereInput
    data: XOR<partnersUncheckedUpdateManyWithoutPartnersInput, partnersUpdateManyMutationInput>
  }

  export type partnersScalarWhereInput = {
    AND?: Enumerable<partnersScalarWhereInput>
    OR?: Enumerable<partnersScalarWhereInput>
    NOT?: Enumerable<partnersScalarWhereInput>
    id?: IntFilter | number
    company_id?: IntFilter | number
    interst_technology_id?: IntNullableFilter | number | null
    invested_total_id?: IntNullableFilter | number | null
    invested_counts?: IntNullableFilter | number | null
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type partnersUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: partnersWhereUniqueInput
    update: XOR<partnersUncheckedUpdateWithoutCompaniesInput, partnersUpdateWithoutCompaniesInput>
    create: XOR<partnersUncheckedCreateWithoutCompaniesInput, partnersCreateWithoutCompaniesInput>
  }

  export type partner_likesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: partner_likesWhereUniqueInput
    data: XOR<partner_likesUncheckedUpdateWithoutCompaniesInput, partner_likesUpdateWithoutCompaniesInput>
  }

  export type partner_likesUpdateManyWithWhereWithoutCompaniesInput = {
    where: partner_likesScalarWhereInput
    data: XOR<partner_likesUncheckedUpdateManyWithoutPartner_likesInput, partner_likesUpdateManyMutationInput>
  }

  export type partner_likesScalarWhereInput = {
    AND?: Enumerable<partner_likesScalarWhereInput>
    OR?: Enumerable<partner_likesScalarWhereInput>
    NOT?: Enumerable<partner_likesScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    company_id?: IntFilter | number
    is_liked?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type partner_likesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: partner_likesWhereUniqueInput
    update: XOR<partner_likesUncheckedUpdateWithoutCompaniesInput, partner_likesUpdateWithoutCompaniesInput>
    create: XOR<partner_likesUncheckedCreateWithoutCompaniesInput, partner_likesCreateWithoutCompaniesInput>
  }

  export type project_likesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: project_likesWhereUniqueInput
    data: XOR<project_likesUncheckedUpdateWithoutCompaniesInput, project_likesUpdateWithoutCompaniesInput>
  }

  export type project_likesUpdateManyWithWhereWithoutCompaniesInput = {
    where: project_likesScalarWhereInput
    data: XOR<project_likesUncheckedUpdateManyWithoutProject_likesInput, project_likesUpdateManyMutationInput>
  }

  export type project_likesScalarWhereInput = {
    AND?: Enumerable<project_likesScalarWhereInput>
    OR?: Enumerable<project_likesScalarWhereInput>
    NOT?: Enumerable<project_likesScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    project_id?: IntFilter | number
    is_liked?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    companiesId?: IntNullableFilter | number | null
  }

  export type project_likesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: project_likesWhereUniqueInput
    update: XOR<project_likesUncheckedUpdateWithoutCompaniesInput, project_likesUpdateWithoutCompaniesInput>
    create: XOR<project_likesUncheckedCreateWithoutCompaniesInput, project_likesCreateWithoutCompaniesInput>
  }

  export type projectsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: projectsWhereUniqueInput
    data: XOR<projectsUncheckedUpdateWithoutCompaniesInput, projectsUpdateWithoutCompaniesInput>
  }

  export type projectsUpdateManyWithWhereWithoutCompaniesInput = {
    where: projectsScalarWhereInput
    data: XOR<projectsUncheckedUpdateManyWithoutProjectsInput, projectsUpdateManyMutationInput>
  }

  export type projectsScalarWhereInput = {
    AND?: Enumerable<projectsScalarWhereInput>
    OR?: Enumerable<projectsScalarWhereInput>
    NOT?: Enumerable<projectsScalarWhereInput>
    id?: IntFilter | number
    name?: StringNullableFilter | string | null
    introduction?: StringNullableFilter | string | null
    company_id?: IntNullableFilter | number | null
    host?: StringNullableFilter | string | null
    due_date?: DateTimeNullableFilter | Date | string | null
    eligible_sector?: IntNullableFilter | number | null
    eligibility?: IntNullableFilter | number | null
    outline?: StringNullableFilter | string | null
    detail?: StringNullableFilter | string | null
    application_method?: StringNullableFilter | string | null
    caution?: StringNullableFilter | string | null
    contact?: StringNullableFilter | string | null
    is_opened?: BoolFilter | boolean
    hit?: IntFilter | number
    application_url?: StringNullableFilter | string | null
    is_saved?: BoolFilter | boolean
    request_open?: BoolFilter | boolean
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type projectsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: projectsWhereUniqueInput
    update: XOR<projectsUncheckedUpdateWithoutCompaniesInput, projectsUpdateWithoutCompaniesInput>
    create: XOR<projectsUncheckedCreateWithoutCompaniesInput, projectsCreateWithoutCompaniesInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUncheckedUpdateWithoutCompaniesInput, questionsUpdateWithoutCompaniesInput>
  }

  export type questionsUpdateManyWithWhereWithoutCompaniesInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUncheckedUpdateManyWithoutQuestionsInput, questionsUpdateManyMutationInput>
  }

  export type questionsScalarWhereInput = {
    AND?: Enumerable<questionsScalarWhereInput>
    OR?: Enumerable<questionsScalarWhereInput>
    NOT?: Enumerable<questionsScalarWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    company_id?: IntFilter | number
    user_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    demoday_id?: IntFilter | number
  }

  export type questionsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUncheckedUpdateWithoutCompaniesInput, questionsUpdateWithoutCompaniesInput>
    create: XOR<questionsUncheckedCreateWithoutCompaniesInput, questionsCreateWithoutCompaniesInput>
  }

  export type recent_views_projectUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: recent_views_projectWhereUniqueInput
    data: XOR<recent_views_projectUncheckedUpdateWithoutCompaniesInput, recent_views_projectUpdateWithoutCompaniesInput>
  }

  export type recent_views_projectUpdateManyWithWhereWithoutCompaniesInput = {
    where: recent_views_projectScalarWhereInput
    data: XOR<recent_views_projectUncheckedUpdateManyWithoutRecent_views_projectInput, recent_views_projectUpdateManyMutationInput>
  }

  export type recent_views_projectScalarWhereInput = {
    AND?: Enumerable<recent_views_projectScalarWhereInput>
    OR?: Enumerable<recent_views_projectScalarWhereInput>
    NOT?: Enumerable<recent_views_projectScalarWhereInput>
    id?: IntFilter | number
    project_id?: IntFilter | number
    company_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type recent_views_projectUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: recent_views_projectWhereUniqueInput
    update: XOR<recent_views_projectUncheckedUpdateWithoutCompaniesInput, recent_views_projectUpdateWithoutCompaniesInput>
    create: XOR<recent_views_projectUncheckedCreateWithoutCompaniesInput, recent_views_projectCreateWithoutCompaniesInput>
  }

  export type startupsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: startupsWhereUniqueInput
    data: XOR<startupsUncheckedUpdateWithoutCompaniesInput, startupsUpdateWithoutCompaniesInput>
  }

  export type startupsUpdateManyWithWhereWithoutCompaniesInput = {
    where: startupsScalarWhereInput
    data: XOR<startupsUncheckedUpdateManyWithoutStartupsInput, startupsUpdateManyMutationInput>
  }

  export type startupsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: startupsWhereUniqueInput
    update: XOR<startupsUncheckedUpdateWithoutCompaniesInput, startupsUpdateWithoutCompaniesInput>
    create: XOR<startupsUncheckedCreateWithoutCompaniesInput, startupsCreateWithoutCompaniesInput>
  }

  export type startup_likesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: startup_likesWhereUniqueInput
    data: XOR<startup_likesUncheckedUpdateWithoutCompaniesInput, startup_likesUpdateWithoutCompaniesInput>
  }

  export type startup_likesUpdateManyWithWhereWithoutCompaniesInput = {
    where: startup_likesScalarWhereInput
    data: XOR<startup_likesUncheckedUpdateManyWithoutStartup_likesInput, startup_likesUpdateManyMutationInput>
  }

  export type startup_likesScalarWhereInput = {
    AND?: Enumerable<startup_likesScalarWhereInput>
    OR?: Enumerable<startup_likesScalarWhereInput>
    NOT?: Enumerable<startup_likesScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    company_id?: IntFilter | number
    is_liked?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type startup_likesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: startup_likesWhereUniqueInput
    update: XOR<startup_likesUncheckedUpdateWithoutCompaniesInput, startup_likesUpdateWithoutCompaniesInput>
    create: XOR<startup_likesUncheckedCreateWithoutCompaniesInput, startup_likesCreateWithoutCompaniesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUncheckedUpdateWithoutCompaniesInput, usersUpdateWithoutCompaniesInput>
  }

  export type usersUpdateManyWithWhereWithoutCompaniesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUncheckedUpdateManyWithoutUsersInput, usersUpdateManyMutationInput>
  }

  export type usersScalarWhereInput = {
    AND?: Enumerable<usersScalarWhereInput>
    OR?: Enumerable<usersScalarWhereInput>
    NOT?: Enumerable<usersScalarWhereInput>
    id?: IntFilter | number
    sns_id?: StringNullableFilter | string | null
    name?: StringFilter | string
    type_id?: IntNullableFilter | number | null
    profile_picture?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringNullableFilter | string | null
    signup_method_id?: IntFilter | number
    company_id?: IntNullableFilter | number | null
    phone_number?: StringNullableFilter | string | null
    is_verified?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUncheckedUpdateWithoutCompaniesInput, usersUpdateWithoutCompaniesInput>
    create: XOR<usersUncheckedCreateWithoutCompaniesInput, usersCreateWithoutCompaniesInput>
  }

  export type companiesCreateWithoutCompany_documentsInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_documentsInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutcompany_documentsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutCompany_documentsInput, companiesCreateWithoutCompany_documentsInput>
  }

  export type document_typesCreateWithoutCompany_documentsInput = {
    name: string
    required_documents?: required_documentsCreateManyWithoutDocument_typesInput
  }

  export type document_typesUncheckedCreateWithoutCompany_documentsInput = {
    id?: number
    name: string
    required_documents?: required_documentsUncheckedCreateManyWithoutDocument_typesInput
  }

  export type document_typesCreateOrConnectWithoutcompany_documentsInput = {
    where: document_typesWhereUniqueInput
    create: XOR<document_typesUncheckedCreateWithoutCompany_documentsInput, document_typesCreateWithoutCompany_documentsInput>
  }

  export type IR_requestsCreateWithoutCompany_documentsInput = {
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    partners: partnersCreateOneWithoutIR_requestsInput
    startups: startupsCreateOneWithoutIR_requestsInput
    companies?: companiesCreateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedCreateWithoutCompany_documentsInput = {
    id?: number
    startup_id: number
    partner_id: number
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    companiesId?: number | null
  }

  export type IR_requestsCreateOrConnectWithoutcompany_documentsInput = {
    where: IR_requestsWhereUniqueInput
    create: XOR<IR_requestsUncheckedCreateWithoutCompany_documentsInput, IR_requestsCreateWithoutCompany_documentsInput>
  }

  export type applicant_documentsCreateWithoutCompany_documentsInput = {
    applicants: applicantsCreateOneWithoutApplicant_documentsInput
  }

  export type applicant_documentsUncheckedCreateWithoutCompany_documentsInput = {
    id?: number
    applicant_id: number
  }

  export type applicant_documentsCreateOrConnectWithoutcompany_documentsInput = {
    where: applicant_documentsWhereUniqueInput
    create: XOR<applicant_documentsUncheckedCreateWithoutCompany_documentsInput, applicant_documentsCreateWithoutCompany_documentsInput>
  }

  export type companiesUpdateWithoutCompany_documentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutCompany_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutCompany_documentsInput = {
    update: XOR<companiesUncheckedUpdateWithoutCompany_documentsInput, companiesUpdateWithoutCompany_documentsInput>
    create: XOR<companiesUncheckedCreateWithoutCompany_documentsInput, companiesCreateWithoutCompany_documentsInput>
  }

  export type document_typesUpdateWithoutCompany_documentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    required_documents?: required_documentsUpdateManyWithoutDocument_typesInput
  }

  export type document_typesUncheckedUpdateWithoutCompany_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    required_documents?: required_documentsUncheckedUpdateManyWithoutDocument_typesInput
  }

  export type document_typesUpsertWithoutCompany_documentsInput = {
    update: XOR<document_typesUncheckedUpdateWithoutCompany_documentsInput, document_typesUpdateWithoutCompany_documentsInput>
    create: XOR<document_typesUncheckedCreateWithoutCompany_documentsInput, document_typesCreateWithoutCompany_documentsInput>
  }

  export type IR_requestsUpdateWithWhereUniqueWithoutCompany_documentsInput = {
    where: IR_requestsWhereUniqueInput
    data: XOR<IR_requestsUncheckedUpdateWithoutCompany_documentsInput, IR_requestsUpdateWithoutCompany_documentsInput>
  }

  export type IR_requestsUpdateManyWithWhereWithoutCompany_documentsInput = {
    where: IR_requestsScalarWhereInput
    data: XOR<IR_requestsUncheckedUpdateManyWithoutIR_requestsInput, IR_requestsUpdateManyMutationInput>
  }

  export type IR_requestsUpsertWithWhereUniqueWithoutCompany_documentsInput = {
    where: IR_requestsWhereUniqueInput
    update: XOR<IR_requestsUncheckedUpdateWithoutCompany_documentsInput, IR_requestsUpdateWithoutCompany_documentsInput>
    create: XOR<IR_requestsUncheckedCreateWithoutCompany_documentsInput, IR_requestsCreateWithoutCompany_documentsInput>
  }

  export type applicant_documentsUpdateWithWhereUniqueWithoutCompany_documentsInput = {
    where: applicant_documentsWhereUniqueInput
    data: XOR<applicant_documentsUncheckedUpdateWithoutCompany_documentsInput, applicant_documentsUpdateWithoutCompany_documentsInput>
  }

  export type applicant_documentsUpdateManyWithWhereWithoutCompany_documentsInput = {
    where: applicant_documentsScalarWhereInput
    data: XOR<applicant_documentsUncheckedUpdateManyWithoutApplicant_documentsInput, applicant_documentsUpdateManyMutationInput>
  }

  export type applicant_documentsUpsertWithWhereUniqueWithoutCompany_documentsInput = {
    where: applicant_documentsWhereUniqueInput
    update: XOR<applicant_documentsUncheckedUpdateWithoutCompany_documentsInput, applicant_documentsUpdateWithoutCompany_documentsInput>
    create: XOR<applicant_documentsUncheckedCreateWithoutCompany_documentsInput, applicant_documentsCreateWithoutCompany_documentsInput>
  }

  export type companiesCreateWithoutCompany_membersInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_membersInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutcompany_membersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutCompany_membersInput, companiesCreateWithoutCompany_membersInput>
  }

  export type companiesUpdateWithoutCompany_membersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutCompany_membersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutCompany_membersInput = {
    update: XOR<companiesUncheckedUpdateWithoutCompany_membersInput, companiesUpdateWithoutCompany_membersInput>
    create: XOR<companiesUncheckedCreateWithoutCompany_membersInput, companiesCreateWithoutCompany_membersInput>
  }

  export type companiesCreateWithoutCompany_newsInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_newsInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutcompany_newsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutCompany_newsInput, companiesCreateWithoutCompany_newsInput>
  }

  export type companiesUpdateWithoutCompany_newsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutCompany_newsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutCompany_newsInput = {
    update: XOR<companiesUncheckedUpdateWithoutCompany_newsInput, companiesUpdateWithoutCompany_newsInput>
    create: XOR<companiesUncheckedCreateWithoutCompany_newsInput, companiesCreateWithoutCompany_newsInput>
  }

  export type companiesCreateWithoutCompany_typesInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_typesInput = {
    id?: number
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutcompany_typesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutCompany_typesInput, companiesCreateWithoutCompany_typesInput>
  }

  export type companiesUpdateWithWhereUniqueWithoutCompany_typesInput = {
    where: companiesWhereUniqueInput
    data: XOR<companiesUncheckedUpdateWithoutCompany_typesInput, companiesUpdateWithoutCompany_typesInput>
  }

  export type companiesUpdateManyWithWhereWithoutCompany_typesInput = {
    where: companiesScalarWhereInput
    data: XOR<companiesUncheckedUpdateManyWithoutCompaniesInput, companiesUpdateManyMutationInput>
  }

  export type companiesScalarWhereInput = {
    AND?: Enumerable<companiesScalarWhereInput>
    OR?: Enumerable<companiesScalarWhereInput>
    NOT?: Enumerable<companiesScalarWhereInput>
    id?: IntFilter | number
    type_id?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    logo_img?: StringNullableFilter | string | null
    established_date?: DateTimeNullableFilter | Date | string | null
    homepage?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    team_intro?: StringNullableFilter | string | null
    member_count?: IntNullableFilter | number | null
    is_saved?: BoolFilter | boolean
    created_at?: DateTimeNullableFilter | Date | string | null
    updated_at?: DateTimeNullableFilter | Date | string | null
    deleted_at?: DateTimeNullableFilter | Date | string | null
  }

  export type companiesUpsertWithWhereUniqueWithoutCompany_typesInput = {
    where: companiesWhereUniqueInput
    update: XOR<companiesUncheckedUpdateWithoutCompany_typesInput, companiesUpdateWithoutCompany_typesInput>
    create: XOR<companiesUncheckedCreateWithoutCompany_typesInput, companiesCreateWithoutCompany_typesInput>
  }

  export type companiesCreateWithoutDemodaysInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutDemodaysInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutdemodaysInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutDemodaysInput, companiesCreateWithoutDemodaysInput>
  }

  export type participantsCreateWithoutDemodaysInput = {
    order: number
    companies: companiesCreateOneWithoutParticipantsInput
    votes?: votesCreateManyWithoutParticipantsInput
  }

  export type participantsUncheckedCreateWithoutDemodaysInput = {
    id?: number
    order: number
    company_id: number
    votes?: votesUncheckedCreateManyWithoutParticipantsInput
  }

  export type participantsCreateOrConnectWithoutdemodaysInput = {
    where: participantsWhereUniqueInput
    create: XOR<participantsUncheckedCreateWithoutDemodaysInput, participantsCreateWithoutDemodaysInput>
  }

  export type questionsCreateWithoutDemodaysInput = {
    content: string
    created_at: Date | string
    updated_at: Date | string
    companies: companiesCreateOneWithoutQuestionsInput
    users: usersCreateOneWithoutQuestionsInput
    answers?: answersCreateManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutDemodaysInput = {
    id?: number
    content: string
    company_id: number
    user_id: number
    created_at: Date | string
    updated_at: Date | string
    answers?: answersUncheckedCreateManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutdemodaysInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsUncheckedCreateWithoutDemodaysInput, questionsCreateWithoutDemodaysInput>
  }

  export type companiesUpdateWithoutDemodaysInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutDemodaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutDemodaysInput = {
    update: XOR<companiesUncheckedUpdateWithoutDemodaysInput, companiesUpdateWithoutDemodaysInput>
    create: XOR<companiesUncheckedCreateWithoutDemodaysInput, companiesCreateWithoutDemodaysInput>
  }

  export type participantsUpdateWithWhereUniqueWithoutDemodaysInput = {
    where: participantsWhereUniqueInput
    data: XOR<participantsUncheckedUpdateWithoutDemodaysInput, participantsUpdateWithoutDemodaysInput>
  }

  export type participantsUpdateManyWithWhereWithoutDemodaysInput = {
    where: participantsScalarWhereInput
    data: XOR<participantsUncheckedUpdateManyWithoutParticipantsInput, participantsUpdateManyMutationInput>
  }

  export type participantsUpsertWithWhereUniqueWithoutDemodaysInput = {
    where: participantsWhereUniqueInput
    update: XOR<participantsUncheckedUpdateWithoutDemodaysInput, participantsUpdateWithoutDemodaysInput>
    create: XOR<participantsUncheckedCreateWithoutDemodaysInput, participantsCreateWithoutDemodaysInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutDemodaysInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUncheckedUpdateWithoutDemodaysInput, questionsUpdateWithoutDemodaysInput>
  }

  export type questionsUpdateManyWithWhereWithoutDemodaysInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUncheckedUpdateManyWithoutQuestionsInput, questionsUpdateManyMutationInput>
  }

  export type questionsUpsertWithWhereUniqueWithoutDemodaysInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUncheckedUpdateWithoutDemodaysInput, questionsUpdateWithoutDemodaysInput>
    create: XOR<questionsUncheckedCreateWithoutDemodaysInput, questionsCreateWithoutDemodaysInput>
  }

  export type company_documentsCreateWithoutDocument_typesInput = {
    doc_url: string
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutCompany_documentsInput
    IR_requests?: IR_requestsCreateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedCreateWithoutDocument_typesInput = {
    id?: number
    company_id: number
    doc_url: string
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUncheckedCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsCreateOrConnectWithoutdocument_typesInput = {
    where: company_documentsWhereUniqueInput
    create: XOR<company_documentsUncheckedCreateWithoutDocument_typesInput, company_documentsCreateWithoutDocument_typesInput>
  }

  export type required_documentsCreateWithoutDocument_typesInput = {
    projects: projectsCreateOneWithoutRequired_documentsInput
  }

  export type required_documentsUncheckedCreateWithoutDocument_typesInput = {
    id?: number
    project_id: number
  }

  export type required_documentsCreateOrConnectWithoutdocument_typesInput = {
    where: required_documentsWhereUniqueInput
    create: XOR<required_documentsUncheckedCreateWithoutDocument_typesInput, required_documentsCreateWithoutDocument_typesInput>
  }

  export type company_documentsUpdateWithWhereUniqueWithoutDocument_typesInput = {
    where: company_documentsWhereUniqueInput
    data: XOR<company_documentsUncheckedUpdateWithoutDocument_typesInput, company_documentsUpdateWithoutDocument_typesInput>
  }

  export type company_documentsUpdateManyWithWhereWithoutDocument_typesInput = {
    where: company_documentsScalarWhereInput
    data: XOR<company_documentsUncheckedUpdateManyWithoutCompany_documentsInput, company_documentsUpdateManyMutationInput>
  }

  export type company_documentsUpsertWithWhereUniqueWithoutDocument_typesInput = {
    where: company_documentsWhereUniqueInput
    update: XOR<company_documentsUncheckedUpdateWithoutDocument_typesInput, company_documentsUpdateWithoutDocument_typesInput>
    create: XOR<company_documentsUncheckedCreateWithoutDocument_typesInput, company_documentsCreateWithoutDocument_typesInput>
  }

  export type required_documentsUpdateWithWhereUniqueWithoutDocument_typesInput = {
    where: required_documentsWhereUniqueInput
    data: XOR<required_documentsUncheckedUpdateWithoutDocument_typesInput, required_documentsUpdateWithoutDocument_typesInput>
  }

  export type required_documentsUpdateManyWithWhereWithoutDocument_typesInput = {
    where: required_documentsScalarWhereInput
    data: XOR<required_documentsUncheckedUpdateManyWithoutRequired_documentsInput, required_documentsUpdateManyMutationInput>
  }

  export type required_documentsScalarWhereInput = {
    AND?: Enumerable<required_documentsScalarWhereInput>
    OR?: Enumerable<required_documentsScalarWhereInput>
    NOT?: Enumerable<required_documentsScalarWhereInput>
    id?: IntFilter | number
    project_id?: IntFilter | number
    document_id?: IntFilter | number
  }

  export type required_documentsUpsertWithWhereUniqueWithoutDocument_typesInput = {
    where: required_documentsWhereUniqueInput
    update: XOR<required_documentsUncheckedUpdateWithoutDocument_typesInput, required_documentsUpdateWithoutDocument_typesInput>
    create: XOR<required_documentsUncheckedCreateWithoutDocument_typesInput, required_documentsCreateWithoutDocument_typesInput>
  }

  export type projectsCreateWithoutEligibilitiesInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligible_sectors?: eligible_sectorsCreateOneWithoutProjectsInput
    companies?: companiesCreateOneWithoutProjectsInput
    applicants?: applicantsCreateManyWithoutProjectsInput
    project_images?: project_imagesCreateManyWithoutProjectsInput
    project_likes?: project_likesCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectCreateManyWithoutProjectsInput
    required_documents?: required_documentsCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutEligibilitiesInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    company_id?: number | null
    host?: string | null
    due_date?: Date | string | null
    eligible_sector?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedCreateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithouteligibilitiesInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsUncheckedCreateWithoutEligibilitiesInput, projectsCreateWithoutEligibilitiesInput>
  }

  export type projectsUpdateWithWhereUniqueWithoutEligibilitiesInput = {
    where: projectsWhereUniqueInput
    data: XOR<projectsUncheckedUpdateWithoutEligibilitiesInput, projectsUpdateWithoutEligibilitiesInput>
  }

  export type projectsUpdateManyWithWhereWithoutEligibilitiesInput = {
    where: projectsScalarWhereInput
    data: XOR<projectsUncheckedUpdateManyWithoutProjectsInput, projectsUpdateManyMutationInput>
  }

  export type projectsUpsertWithWhereUniqueWithoutEligibilitiesInput = {
    where: projectsWhereUniqueInput
    update: XOR<projectsUncheckedUpdateWithoutEligibilitiesInput, projectsUpdateWithoutEligibilitiesInput>
    create: XOR<projectsUncheckedCreateWithoutEligibilitiesInput, projectsCreateWithoutEligibilitiesInput>
  }

  export type projectsCreateWithoutEligible_sectorsInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligibilities?: eligibilitiesCreateOneWithoutProjectsInput
    companies?: companiesCreateOneWithoutProjectsInput
    applicants?: applicantsCreateManyWithoutProjectsInput
    project_images?: project_imagesCreateManyWithoutProjectsInput
    project_likes?: project_likesCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectCreateManyWithoutProjectsInput
    required_documents?: required_documentsCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutEligible_sectorsInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    company_id?: number | null
    host?: string | null
    due_date?: Date | string | null
    eligibility?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedCreateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithouteligible_sectorsInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsUncheckedCreateWithoutEligible_sectorsInput, projectsCreateWithoutEligible_sectorsInput>
  }

  export type projectsUpdateWithWhereUniqueWithoutEligible_sectorsInput = {
    where: projectsWhereUniqueInput
    data: XOR<projectsUncheckedUpdateWithoutEligible_sectorsInput, projectsUpdateWithoutEligible_sectorsInput>
  }

  export type projectsUpdateManyWithWhereWithoutEligible_sectorsInput = {
    where: projectsScalarWhereInput
    data: XOR<projectsUncheckedUpdateManyWithoutProjectsInput, projectsUpdateManyMutationInput>
  }

  export type projectsUpsertWithWhereUniqueWithoutEligible_sectorsInput = {
    where: projectsWhereUniqueInput
    update: XOR<projectsUncheckedUpdateWithoutEligible_sectorsInput, projectsUpdateWithoutEligible_sectorsInput>
    create: XOR<projectsUncheckedCreateWithoutEligible_sectorsInput, projectsCreateWithoutEligible_sectorsInput>
  }

  export type investment_seriesCreateWithoutInvested_fromInput = {
    name: string
    invested_to?: invested_toCreateManyWithoutInvestment_seriesInput
    startups?: startupsCreateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedCreateWithoutInvested_fromInput = {
    id?: number
    name: string
    invested_to?: invested_toUncheckedCreateManyWithoutInvestment_seriesInput
    startups?: startupsUncheckedCreateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesCreateOrConnectWithoutinvested_fromInput = {
    where: investment_seriesWhereUniqueInput
    create: XOR<investment_seriesUncheckedCreateWithoutInvested_fromInput, investment_seriesCreateWithoutInvested_fromInput>
  }

  export type investment_fundsCreateWithoutInvested_fromInput = {
    name: string
    partners?: partnersCreateManyWithoutInvestment_fundsInput
    startups?: startupsCreateManyWithoutInvestment_fundsInput
    invested_to?: invested_toCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedCreateWithoutInvested_fromInput = {
    id?: number
    name: string
    partners?: partnersUncheckedCreateManyWithoutInvestment_fundsInput
    startups?: startupsUncheckedCreateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUncheckedCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsCreateOrConnectWithoutinvested_fromInput = {
    where: investment_fundsWhereUniqueInput
    create: XOR<investment_fundsUncheckedCreateWithoutInvested_fromInput, investment_fundsCreateWithoutInvested_fromInput>
  }

  export type startupsCreateWithoutInvested_fromInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutInvested_fromInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutinvested_fromInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutInvested_fromInput, startupsCreateWithoutInvested_fromInput>
  }

  export type investment_seriesUpdateWithoutInvested_fromInput = {
    name?: StringFieldUpdateOperationsInput | string
    invested_to?: invested_toUpdateManyWithoutInvestment_seriesInput
    startups?: startupsUpdateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedUpdateWithoutInvested_fromInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    invested_to?: invested_toUncheckedUpdateManyWithoutInvestment_seriesInput
    startups?: startupsUncheckedUpdateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUpsertWithoutInvested_fromInput = {
    update: XOR<investment_seriesUncheckedUpdateWithoutInvested_fromInput, investment_seriesUpdateWithoutInvested_fromInput>
    create: XOR<investment_seriesUncheckedCreateWithoutInvested_fromInput, investment_seriesCreateWithoutInvested_fromInput>
  }

  export type investment_fundsUpdateWithoutInvested_fromInput = {
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUpdateManyWithoutInvestment_fundsInput
    startups?: startupsUpdateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedUpdateWithoutInvested_fromInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUncheckedUpdateManyWithoutInvestment_fundsInput
    startups?: startupsUncheckedUpdateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUncheckedUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUpsertWithoutInvested_fromInput = {
    update: XOR<investment_fundsUncheckedUpdateWithoutInvested_fromInput, investment_fundsUpdateWithoutInvested_fromInput>
    create: XOR<investment_fundsUncheckedCreateWithoutInvested_fromInput, investment_fundsCreateWithoutInvested_fromInput>
  }

  export type startupsUpdateWithoutInvested_fromInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutInvested_fromInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type startupsUpsertWithoutInvested_fromInput = {
    update: XOR<startupsUncheckedUpdateWithoutInvested_fromInput, startupsUpdateWithoutInvested_fromInput>
    create: XOR<startupsUncheckedCreateWithoutInvested_fromInput, startupsCreateWithoutInvested_fromInput>
  }

  export type investment_seriesCreateWithoutInvested_toInput = {
    name: string
    invested_from?: invested_fromCreateManyWithoutInvestment_seriesInput
    startups?: startupsCreateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedCreateWithoutInvested_toInput = {
    id?: number
    name: string
    invested_from?: invested_fromUncheckedCreateManyWithoutInvestment_seriesInput
    startups?: startupsUncheckedCreateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesCreateOrConnectWithoutinvested_toInput = {
    where: investment_seriesWhereUniqueInput
    create: XOR<investment_seriesUncheckedCreateWithoutInvested_toInput, investment_seriesCreateWithoutInvested_toInput>
  }

  export type investment_fundsCreateWithoutInvested_toInput = {
    name: string
    partners?: partnersCreateManyWithoutInvestment_fundsInput
    startups?: startupsCreateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedCreateWithoutInvested_toInput = {
    id?: number
    name: string
    partners?: partnersUncheckedCreateManyWithoutInvestment_fundsInput
    startups?: startupsUncheckedCreateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUncheckedCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsCreateOrConnectWithoutinvested_toInput = {
    where: investment_fundsWhereUniqueInput
    create: XOR<investment_fundsUncheckedCreateWithoutInvested_toInput, investment_fundsCreateWithoutInvested_toInput>
  }

  export type partnersCreateWithoutInvested_toInput = {
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutPartnersInput
    technologies?: technologiesCreateOneWithoutPartnersInput
    investment_funds?: investment_fundsCreateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsCreateManyWithoutPartnersInput
  }

  export type partnersUncheckedCreateWithoutInvested_toInput = {
    id?: number
    company_id: number
    interst_technology_id?: number | null
    invested_total_id?: number | null
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    investment_portfolio?: investment_portfolioUncheckedCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutPartnersInput
  }

  export type partnersCreateOrConnectWithoutinvested_toInput = {
    where: partnersWhereUniqueInput
    create: XOR<partnersUncheckedCreateWithoutInvested_toInput, partnersCreateWithoutInvested_toInput>
  }

  export type investment_seriesUpdateWithoutInvested_toInput = {
    name?: StringFieldUpdateOperationsInput | string
    invested_from?: invested_fromUpdateManyWithoutInvestment_seriesInput
    startups?: startupsUpdateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedUpdateWithoutInvested_toInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    invested_from?: invested_fromUncheckedUpdateManyWithoutInvestment_seriesInput
    startups?: startupsUncheckedUpdateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUpsertWithoutInvested_toInput = {
    update: XOR<investment_seriesUncheckedUpdateWithoutInvested_toInput, investment_seriesUpdateWithoutInvested_toInput>
    create: XOR<investment_seriesUncheckedCreateWithoutInvested_toInput, investment_seriesCreateWithoutInvested_toInput>
  }

  export type investment_fundsUpdateWithoutInvested_toInput = {
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUpdateManyWithoutInvestment_fundsInput
    startups?: startupsUpdateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedUpdateWithoutInvested_toInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUncheckedUpdateManyWithoutInvestment_fundsInput
    startups?: startupsUncheckedUpdateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUncheckedUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUpsertWithoutInvested_toInput = {
    update: XOR<investment_fundsUncheckedUpdateWithoutInvested_toInput, investment_fundsUpdateWithoutInvested_toInput>
    create: XOR<investment_fundsUncheckedCreateWithoutInvested_toInput, investment_fundsCreateWithoutInvested_toInput>
  }

  export type partnersUpdateWithoutInvested_toInput = {
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutPartnersInput
    technologies?: technologiesUpdateOneWithoutPartnersInput
    investment_funds?: investment_fundsUpdateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUpdateManyWithoutPartnersInput
  }

  export type partnersUncheckedUpdateWithoutInvested_toInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    interst_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_total_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    investment_portfolio?: investment_portfolioUncheckedUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutPartnersInput
  }

  export type partnersUpsertWithoutInvested_toInput = {
    update: XOR<partnersUncheckedUpdateWithoutInvested_toInput, partnersUpdateWithoutInvested_toInput>
    create: XOR<partnersUncheckedCreateWithoutInvested_toInput, partnersCreateWithoutInvested_toInput>
  }

  export type partnersCreateWithoutInvestment_fundsInput = {
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutPartnersInput
    technologies?: technologiesCreateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsCreateManyWithoutPartnersInput
    invested_to?: invested_toCreateManyWithoutPartnersInput
  }

  export type partnersUncheckedCreateWithoutInvestment_fundsInput = {
    id?: number
    company_id: number
    interst_technology_id?: number | null
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    investment_portfolio?: investment_portfolioUncheckedCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedCreateManyWithoutPartnersInput
  }

  export type partnersCreateOrConnectWithoutinvestment_fundsInput = {
    where: partnersWhereUniqueInput
    create: XOR<partnersUncheckedCreateWithoutInvestment_fundsInput, partnersCreateWithoutInvestment_fundsInput>
  }

  export type startupsCreateWithoutInvestment_fundsInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutInvestment_fundsInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutinvestment_fundsInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutInvestment_fundsInput, startupsCreateWithoutInvestment_fundsInput>
  }

  export type invested_fromCreateWithoutInvestment_fundsInput = {
    date: Date | string
    invested_institution: string
    corporate_value: number
    investment_series: investment_seriesCreateOneWithoutInvested_fromInput
    startups: startupsCreateOneWithoutInvested_fromInput
  }

  export type invested_fromUncheckedCreateWithoutInvestment_fundsInput = {
    id?: number
    startup_id: number
    date: Date | string
    invested_institution: string
    corporate_value: number
    series_id: number
  }

  export type invested_fromCreateOrConnectWithoutinvestment_fundsInput = {
    where: invested_fromWhereUniqueInput
    create: XOR<invested_fromUncheckedCreateWithoutInvestment_fundsInput, invested_fromCreateWithoutInvestment_fundsInput>
  }

  export type invested_toCreateWithoutInvestment_fundsInput = {
    date: Date | string
    invested_startup: string
    corporate_value: number
    investment_series: investment_seriesCreateOneWithoutInvested_toInput
    partners: partnersCreateOneWithoutInvested_toInput
  }

  export type invested_toUncheckedCreateWithoutInvestment_fundsInput = {
    id?: number
    partner_id: number
    date: Date | string
    invested_startup: string
    corporate_value: number
    series_id: number
  }

  export type invested_toCreateOrConnectWithoutinvestment_fundsInput = {
    where: invested_toWhereUniqueInput
    create: XOR<invested_toUncheckedCreateWithoutInvestment_fundsInput, invested_toCreateWithoutInvestment_fundsInput>
  }

  export type partnersUpdateWithWhereUniqueWithoutInvestment_fundsInput = {
    where: partnersWhereUniqueInput
    data: XOR<partnersUncheckedUpdateWithoutInvestment_fundsInput, partnersUpdateWithoutInvestment_fundsInput>
  }

  export type partnersUpdateManyWithWhereWithoutInvestment_fundsInput = {
    where: partnersScalarWhereInput
    data: XOR<partnersUncheckedUpdateManyWithoutPartnersInput, partnersUpdateManyMutationInput>
  }

  export type partnersUpsertWithWhereUniqueWithoutInvestment_fundsInput = {
    where: partnersWhereUniqueInput
    update: XOR<partnersUncheckedUpdateWithoutInvestment_fundsInput, partnersUpdateWithoutInvestment_fundsInput>
    create: XOR<partnersUncheckedCreateWithoutInvestment_fundsInput, partnersCreateWithoutInvestment_fundsInput>
  }

  export type startupsUpdateWithWhereUniqueWithoutInvestment_fundsInput = {
    where: startupsWhereUniqueInput
    data: XOR<startupsUncheckedUpdateWithoutInvestment_fundsInput, startupsUpdateWithoutInvestment_fundsInput>
  }

  export type startupsUpdateManyWithWhereWithoutInvestment_fundsInput = {
    where: startupsScalarWhereInput
    data: XOR<startupsUncheckedUpdateManyWithoutStartupsInput, startupsUpdateManyMutationInput>
  }

  export type startupsUpsertWithWhereUniqueWithoutInvestment_fundsInput = {
    where: startupsWhereUniqueInput
    update: XOR<startupsUncheckedUpdateWithoutInvestment_fundsInput, startupsUpdateWithoutInvestment_fundsInput>
    create: XOR<startupsUncheckedCreateWithoutInvestment_fundsInput, startupsCreateWithoutInvestment_fundsInput>
  }

  export type invested_fromUpdateWithWhereUniqueWithoutInvestment_fundsInput = {
    where: invested_fromWhereUniqueInput
    data: XOR<invested_fromUncheckedUpdateWithoutInvestment_fundsInput, invested_fromUpdateWithoutInvestment_fundsInput>
  }

  export type invested_fromUpdateManyWithWhereWithoutInvestment_fundsInput = {
    where: invested_fromScalarWhereInput
    data: XOR<invested_fromUncheckedUpdateManyWithoutInvested_fromInput, invested_fromUpdateManyMutationInput>
  }

  export type invested_fromScalarWhereInput = {
    AND?: Enumerable<invested_fromScalarWhereInput>
    OR?: Enumerable<invested_fromScalarWhereInput>
    NOT?: Enumerable<invested_fromScalarWhereInput>
    id?: IntFilter | number
    startup_id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    invested_institution?: StringFilter | string
    invested_fund_id?: IntFilter | number
    corporate_value?: IntFilter | number
    series_id?: IntFilter | number
  }

  export type invested_fromUpsertWithWhereUniqueWithoutInvestment_fundsInput = {
    where: invested_fromWhereUniqueInput
    update: XOR<invested_fromUncheckedUpdateWithoutInvestment_fundsInput, invested_fromUpdateWithoutInvestment_fundsInput>
    create: XOR<invested_fromUncheckedCreateWithoutInvestment_fundsInput, invested_fromCreateWithoutInvestment_fundsInput>
  }

  export type invested_toUpdateWithWhereUniqueWithoutInvestment_fundsInput = {
    where: invested_toWhereUniqueInput
    data: XOR<invested_toUncheckedUpdateWithoutInvestment_fundsInput, invested_toUpdateWithoutInvestment_fundsInput>
  }

  export type invested_toUpdateManyWithWhereWithoutInvestment_fundsInput = {
    where: invested_toScalarWhereInput
    data: XOR<invested_toUncheckedUpdateManyWithoutInvested_toInput, invested_toUpdateManyMutationInput>
  }

  export type invested_toScalarWhereInput = {
    AND?: Enumerable<invested_toScalarWhereInput>
    OR?: Enumerable<invested_toScalarWhereInput>
    NOT?: Enumerable<invested_toScalarWhereInput>
    id?: IntFilter | number
    partner_id?: IntFilter | number
    date?: DateTimeFilter | Date | string
    invested_startup?: StringFilter | string
    invested_fund_id?: IntFilter | number
    corporate_value?: IntFilter | number
    series_id?: IntFilter | number
  }

  export type invested_toUpsertWithWhereUniqueWithoutInvestment_fundsInput = {
    where: invested_toWhereUniqueInput
    update: XOR<invested_toUncheckedUpdateWithoutInvestment_fundsInput, invested_toUpdateWithoutInvestment_fundsInput>
    create: XOR<invested_toUncheckedCreateWithoutInvestment_fundsInput, invested_toCreateWithoutInvestment_fundsInput>
  }

  export type partnersCreateWithoutInvestment_portfolioInput = {
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutPartnersInput
    technologies?: technologiesCreateOneWithoutPartnersInput
    investment_funds?: investment_fundsCreateOneWithoutPartnersInput
    IR_requests?: IR_requestsCreateManyWithoutPartnersInput
    invested_to?: invested_toCreateManyWithoutPartnersInput
  }

  export type partnersUncheckedCreateWithoutInvestment_portfolioInput = {
    id?: number
    company_id: number
    interst_technology_id?: number | null
    invested_total_id?: number | null
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    IR_requests?: IR_requestsUncheckedCreateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedCreateManyWithoutPartnersInput
  }

  export type partnersCreateOrConnectWithoutinvestment_portfolioInput = {
    where: partnersWhereUniqueInput
    create: XOR<partnersUncheckedCreateWithoutInvestment_portfolioInput, partnersCreateWithoutInvestment_portfolioInput>
  }

  export type partnersUpdateWithoutInvestment_portfolioInput = {
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutPartnersInput
    technologies?: technologiesUpdateOneWithoutPartnersInput
    investment_funds?: investment_fundsUpdateOneWithoutPartnersInput
    IR_requests?: IR_requestsUpdateManyWithoutPartnersInput
    invested_to?: invested_toUpdateManyWithoutPartnersInput
  }

  export type partnersUncheckedUpdateWithoutInvestment_portfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    interst_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_total_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedUpdateManyWithoutPartnersInput
  }

  export type partnersUpsertWithoutInvestment_portfolioInput = {
    update: XOR<partnersUncheckedUpdateWithoutInvestment_portfolioInput, partnersUpdateWithoutInvestment_portfolioInput>
    create: XOR<partnersUncheckedCreateWithoutInvestment_portfolioInput, partnersCreateWithoutInvestment_portfolioInput>
  }

  export type invested_fromCreateWithoutInvestment_seriesInput = {
    date: Date | string
    invested_institution: string
    corporate_value: number
    investment_funds: investment_fundsCreateOneWithoutInvested_fromInput
    startups: startupsCreateOneWithoutInvested_fromInput
  }

  export type invested_fromUncheckedCreateWithoutInvestment_seriesInput = {
    id?: number
    startup_id: number
    date: Date | string
    invested_institution: string
    invested_fund_id: number
    corporate_value: number
  }

  export type invested_fromCreateOrConnectWithoutinvestment_seriesInput = {
    where: invested_fromWhereUniqueInput
    create: XOR<invested_fromUncheckedCreateWithoutInvestment_seriesInput, invested_fromCreateWithoutInvestment_seriesInput>
  }

  export type invested_toCreateWithoutInvestment_seriesInput = {
    date: Date | string
    invested_startup: string
    corporate_value: number
    investment_funds: investment_fundsCreateOneWithoutInvested_toInput
    partners: partnersCreateOneWithoutInvested_toInput
  }

  export type invested_toUncheckedCreateWithoutInvestment_seriesInput = {
    id?: number
    partner_id: number
    date: Date | string
    invested_startup: string
    invested_fund_id: number
    corporate_value: number
  }

  export type invested_toCreateOrConnectWithoutinvestment_seriesInput = {
    where: invested_toWhereUniqueInput
    create: XOR<invested_toUncheckedCreateWithoutInvestment_seriesInput, invested_toCreateWithoutInvestment_seriesInput>
  }

  export type startupsCreateWithoutInvestment_seriesInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutInvestment_seriesInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutinvestment_seriesInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutInvestment_seriesInput, startupsCreateWithoutInvestment_seriesInput>
  }

  export type wish_investment_seriesCreateWithoutInvestment_seriesInput = {
    startups: startupsCreateOneWithoutWish_investment_seriesInput
  }

  export type wish_investment_seriesUncheckedCreateWithoutInvestment_seriesInput = {
    id?: number
    startup_id: number
  }

  export type wish_investment_seriesCreateOrConnectWithoutinvestment_seriesInput = {
    where: wish_investment_seriesWhereUniqueInput
    create: XOR<wish_investment_seriesUncheckedCreateWithoutInvestment_seriesInput, wish_investment_seriesCreateWithoutInvestment_seriesInput>
  }

  export type invested_fromUpdateWithWhereUniqueWithoutInvestment_seriesInput = {
    where: invested_fromWhereUniqueInput
    data: XOR<invested_fromUncheckedUpdateWithoutInvestment_seriesInput, invested_fromUpdateWithoutInvestment_seriesInput>
  }

  export type invested_fromUpdateManyWithWhereWithoutInvestment_seriesInput = {
    where: invested_fromScalarWhereInput
    data: XOR<invested_fromUncheckedUpdateManyWithoutInvested_fromInput, invested_fromUpdateManyMutationInput>
  }

  export type invested_fromUpsertWithWhereUniqueWithoutInvestment_seriesInput = {
    where: invested_fromWhereUniqueInput
    update: XOR<invested_fromUncheckedUpdateWithoutInvestment_seriesInput, invested_fromUpdateWithoutInvestment_seriesInput>
    create: XOR<invested_fromUncheckedCreateWithoutInvestment_seriesInput, invested_fromCreateWithoutInvestment_seriesInput>
  }

  export type invested_toUpdateWithWhereUniqueWithoutInvestment_seriesInput = {
    where: invested_toWhereUniqueInput
    data: XOR<invested_toUncheckedUpdateWithoutInvestment_seriesInput, invested_toUpdateWithoutInvestment_seriesInput>
  }

  export type invested_toUpdateManyWithWhereWithoutInvestment_seriesInput = {
    where: invested_toScalarWhereInput
    data: XOR<invested_toUncheckedUpdateManyWithoutInvested_toInput, invested_toUpdateManyMutationInput>
  }

  export type invested_toUpsertWithWhereUniqueWithoutInvestment_seriesInput = {
    where: invested_toWhereUniqueInput
    update: XOR<invested_toUncheckedUpdateWithoutInvestment_seriesInput, invested_toUpdateWithoutInvestment_seriesInput>
    create: XOR<invested_toUncheckedCreateWithoutInvestment_seriesInput, invested_toCreateWithoutInvestment_seriesInput>
  }

  export type startupsUpdateWithWhereUniqueWithoutInvestment_seriesInput = {
    where: startupsWhereUniqueInput
    data: XOR<startupsUncheckedUpdateWithoutInvestment_seriesInput, startupsUpdateWithoutInvestment_seriesInput>
  }

  export type startupsUpdateManyWithWhereWithoutInvestment_seriesInput = {
    where: startupsScalarWhereInput
    data: XOR<startupsUncheckedUpdateManyWithoutStartupsInput, startupsUpdateManyMutationInput>
  }

  export type startupsUpsertWithWhereUniqueWithoutInvestment_seriesInput = {
    where: startupsWhereUniqueInput
    update: XOR<startupsUncheckedUpdateWithoutInvestment_seriesInput, startupsUpdateWithoutInvestment_seriesInput>
    create: XOR<startupsUncheckedCreateWithoutInvestment_seriesInput, startupsCreateWithoutInvestment_seriesInput>
  }

  export type wish_investment_seriesUpdateWithWhereUniqueWithoutInvestment_seriesInput = {
    where: wish_investment_seriesWhereUniqueInput
    data: XOR<wish_investment_seriesUncheckedUpdateWithoutInvestment_seriesInput, wish_investment_seriesUpdateWithoutInvestment_seriesInput>
  }

  export type wish_investment_seriesUpdateManyWithWhereWithoutInvestment_seriesInput = {
    where: wish_investment_seriesScalarWhereInput
    data: XOR<wish_investment_seriesUncheckedUpdateManyWithoutWish_investment_seriesInput, wish_investment_seriesUpdateManyMutationInput>
  }

  export type wish_investment_seriesScalarWhereInput = {
    AND?: Enumerable<wish_investment_seriesScalarWhereInput>
    OR?: Enumerable<wish_investment_seriesScalarWhereInput>
    NOT?: Enumerable<wish_investment_seriesScalarWhereInput>
    id?: IntFilter | number
    startup_id?: IntFilter | number
    investment_series_id?: IntFilter | number
  }

  export type wish_investment_seriesUpsertWithWhereUniqueWithoutInvestment_seriesInput = {
    where: wish_investment_seriesWhereUniqueInput
    update: XOR<wish_investment_seriesUncheckedUpdateWithoutInvestment_seriesInput, wish_investment_seriesUpdateWithoutInvestment_seriesInput>
    create: XOR<wish_investment_seriesUncheckedCreateWithoutInvestment_seriesInput, wish_investment_seriesCreateWithoutInvestment_seriesInput>
  }

  export type company_documentsCreateWithoutIR_requestsInput = {
    doc_url: string
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutCompany_documentsInput
    document_types: document_typesCreateOneWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedCreateWithoutIR_requestsInput = {
    id?: number
    company_id: number
    doc_url: string
    type_id: number
    name: string
    file_type: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicant_documents?: applicant_documentsUncheckedCreateManyWithoutCompany_documentsInput
  }

  export type company_documentsCreateOrConnectWithoutIR_requestsInput = {
    where: company_documentsWhereUniqueInput
    create: XOR<company_documentsUncheckedCreateWithoutIR_requestsInput, company_documentsCreateWithoutIR_requestsInput>
  }

  export type partnersCreateWithoutIR_requestsInput = {
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutPartnersInput
    technologies?: technologiesCreateOneWithoutPartnersInput
    investment_funds?: investment_fundsCreateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioCreateManyWithoutPartnersInput
    invested_to?: invested_toCreateManyWithoutPartnersInput
  }

  export type partnersUncheckedCreateWithoutIR_requestsInput = {
    id?: number
    company_id: number
    interst_technology_id?: number | null
    invested_total_id?: number | null
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    investment_portfolio?: investment_portfolioUncheckedCreateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedCreateManyWithoutPartnersInput
  }

  export type partnersCreateOrConnectWithoutIR_requestsInput = {
    where: partnersWhereUniqueInput
    create: XOR<partnersUncheckedCreateWithoutIR_requestsInput, partnersCreateWithoutIR_requestsInput>
  }

  export type startupsCreateWithoutIR_requestsInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutIR_requestsInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutIR_requestsInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutIR_requestsInput, startupsCreateWithoutIR_requestsInput>
  }

  export type companiesCreateWithoutIR_requestsInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutIR_requestsInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutIR_requestsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutIR_requestsInput, companiesCreateWithoutIR_requestsInput>
  }

  export type company_documentsUpdateWithoutIR_requestsInput = {
    doc_url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_documentsInput
    document_types?: document_typesUpdateOneRequiredWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedUpdateWithoutIR_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    doc_url?: StringFieldUpdateOperationsInput | string
    type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicant_documents?: applicant_documentsUncheckedUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUpsertWithoutIR_requestsInput = {
    update: XOR<company_documentsUncheckedUpdateWithoutIR_requestsInput, company_documentsUpdateWithoutIR_requestsInput>
    create: XOR<company_documentsUncheckedCreateWithoutIR_requestsInput, company_documentsCreateWithoutIR_requestsInput>
  }

  export type partnersUpdateWithoutIR_requestsInput = {
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutPartnersInput
    technologies?: technologiesUpdateOneWithoutPartnersInput
    investment_funds?: investment_fundsUpdateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioUpdateManyWithoutPartnersInput
    invested_to?: invested_toUpdateManyWithoutPartnersInput
  }

  export type partnersUncheckedUpdateWithoutIR_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    interst_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_total_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    investment_portfolio?: investment_portfolioUncheckedUpdateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedUpdateManyWithoutPartnersInput
  }

  export type partnersUpsertWithoutIR_requestsInput = {
    update: XOR<partnersUncheckedUpdateWithoutIR_requestsInput, partnersUpdateWithoutIR_requestsInput>
    create: XOR<partnersUncheckedCreateWithoutIR_requestsInput, partnersCreateWithoutIR_requestsInput>
  }

  export type startupsUpdateWithoutIR_requestsInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutIR_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
  }

  export type startupsUpsertWithoutIR_requestsInput = {
    update: XOR<startupsUncheckedUpdateWithoutIR_requestsInput, startupsUpdateWithoutIR_requestsInput>
    create: XOR<startupsUncheckedCreateWithoutIR_requestsInput, startupsCreateWithoutIR_requestsInput>
  }

  export type companiesUpdateWithoutIR_requestsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutIR_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutIR_requestsInput = {
    update: XOR<companiesUncheckedUpdateWithoutIR_requestsInput, companiesUpdateWithoutIR_requestsInput>
    create: XOR<companiesUncheckedCreateWithoutIR_requestsInput, companiesCreateWithoutIR_requestsInput>
  }

  export type companiesCreateWithoutParticipantsInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutParticipantsInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutparticipantsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutParticipantsInput, companiesCreateWithoutParticipantsInput>
  }

  export type demodaysCreateWithoutParticipantsInput = {
    name?: string | null
    streaming_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies?: companiesCreateOneWithoutDemodaysInput
    questions?: questionsCreateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedCreateWithoutParticipantsInput = {
    id?: number
    name?: string | null
    company_id?: number | null
    streaming_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    questions?: questionsUncheckedCreateManyWithoutDemodaysInput
  }

  export type demodaysCreateOrConnectWithoutparticipantsInput = {
    where: demodaysWhereUniqueInput
    create: XOR<demodaysUncheckedCreateWithoutParticipantsInput, demodaysCreateWithoutParticipantsInput>
  }

  export type votesCreateWithoutParticipantsInput = {
    created_at?: Date | string
    users: usersCreateOneWithoutVotesInput
  }

  export type votesUncheckedCreateWithoutParticipantsInput = {
    id?: number
    user_id: number
    created_at?: Date | string
  }

  export type votesCreateOrConnectWithoutparticipantsInput = {
    where: votesWhereUniqueInput
    create: XOR<votesUncheckedCreateWithoutParticipantsInput, votesCreateWithoutParticipantsInput>
  }

  export type companiesUpdateWithoutParticipantsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutParticipantsInput = {
    update: XOR<companiesUncheckedUpdateWithoutParticipantsInput, companiesUpdateWithoutParticipantsInput>
    create: XOR<companiesUncheckedCreateWithoutParticipantsInput, companiesCreateWithoutParticipantsInput>
  }

  export type demodaysUpdateWithoutParticipantsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneWithoutDemodaysInput
    questions?: questionsUpdateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: questionsUncheckedUpdateManyWithoutDemodaysInput
  }

  export type demodaysUpsertWithoutParticipantsInput = {
    update: XOR<demodaysUncheckedUpdateWithoutParticipantsInput, demodaysUpdateWithoutParticipantsInput>
    create: XOR<demodaysUncheckedCreateWithoutParticipantsInput, demodaysCreateWithoutParticipantsInput>
  }

  export type votesUpdateWithWhereUniqueWithoutParticipantsInput = {
    where: votesWhereUniqueInput
    data: XOR<votesUncheckedUpdateWithoutParticipantsInput, votesUpdateWithoutParticipantsInput>
  }

  export type votesUpdateManyWithWhereWithoutParticipantsInput = {
    where: votesScalarWhereInput
    data: XOR<votesUncheckedUpdateManyWithoutVotesInput, votesUpdateManyMutationInput>
  }

  export type votesScalarWhereInput = {
    AND?: Enumerable<votesScalarWhereInput>
    OR?: Enumerable<votesScalarWhereInput>
    NOT?: Enumerable<votesScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    participants_id?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
  }

  export type votesUpsertWithWhereUniqueWithoutParticipantsInput = {
    where: votesWhereUniqueInput
    update: XOR<votesUncheckedUpdateWithoutParticipantsInput, votesUpdateWithoutParticipantsInput>
    create: XOR<votesUncheckedCreateWithoutParticipantsInput, votesCreateWithoutParticipantsInput>
  }

  export type companiesCreateWithoutPartnersInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutPartnersInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutpartnersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutPartnersInput, companiesCreateWithoutPartnersInput>
  }

  export type technologiesCreateWithoutPartnersInput = {
    name: string
    startups?: startupsCreateManyWithoutTechnologiesInput
  }

  export type technologiesUncheckedCreateWithoutPartnersInput = {
    id?: number
    name: string
    startups?: startupsUncheckedCreateManyWithoutTechnologiesInput
  }

  export type technologiesCreateOrConnectWithoutpartnersInput = {
    where: technologiesWhereUniqueInput
    create: XOR<technologiesUncheckedCreateWithoutPartnersInput, technologiesCreateWithoutPartnersInput>
  }

  export type investment_fundsCreateWithoutPartnersInput = {
    name: string
    startups?: startupsCreateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromCreateManyWithoutInvestment_fundsInput
    invested_to?: invested_toCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedCreateWithoutPartnersInput = {
    id?: number
    name: string
    startups?: startupsUncheckedCreateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUncheckedCreateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUncheckedCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsCreateOrConnectWithoutpartnersInput = {
    where: investment_fundsWhereUniqueInput
    create: XOR<investment_fundsUncheckedCreateWithoutPartnersInput, investment_fundsCreateWithoutPartnersInput>
  }

  export type investment_portfolioCreateWithoutPartnersInput = {
    img_url: string
  }

  export type investment_portfolioUncheckedCreateWithoutPartnersInput = {
    id?: number
    img_url: string
  }

  export type investment_portfolioCreateOrConnectWithoutpartnersInput = {
    where: investment_portfolioWhereUniqueInput
    create: XOR<investment_portfolioUncheckedCreateWithoutPartnersInput, investment_portfolioCreateWithoutPartnersInput>
  }

  export type IR_requestsCreateWithoutPartnersInput = {
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    company_documents?: company_documentsCreateOneWithoutIR_requestsInput
    startups: startupsCreateOneWithoutIR_requestsInput
    companies?: companiesCreateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedCreateWithoutPartnersInput = {
    id?: number
    startup_id: number
    document_id?: number | null
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    companiesId?: number | null
  }

  export type IR_requestsCreateOrConnectWithoutpartnersInput = {
    where: IR_requestsWhereUniqueInput
    create: XOR<IR_requestsUncheckedCreateWithoutPartnersInput, IR_requestsCreateWithoutPartnersInput>
  }

  export type invested_toCreateWithoutPartnersInput = {
    date: Date | string
    invested_startup: string
    corporate_value: number
    investment_series: investment_seriesCreateOneWithoutInvested_toInput
    investment_funds: investment_fundsCreateOneWithoutInvested_toInput
  }

  export type invested_toUncheckedCreateWithoutPartnersInput = {
    id?: number
    date: Date | string
    invested_startup: string
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type invested_toCreateOrConnectWithoutpartnersInput = {
    where: invested_toWhereUniqueInput
    create: XOR<invested_toUncheckedCreateWithoutPartnersInput, invested_toCreateWithoutPartnersInput>
  }

  export type companiesUpdateWithoutPartnersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutPartnersInput = {
    update: XOR<companiesUncheckedUpdateWithoutPartnersInput, companiesUpdateWithoutPartnersInput>
    create: XOR<companiesUncheckedCreateWithoutPartnersInput, companiesCreateWithoutPartnersInput>
  }

  export type technologiesUpdateWithoutPartnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUpdateManyWithoutTechnologiesInput
  }

  export type technologiesUncheckedUpdateWithoutPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUncheckedUpdateManyWithoutTechnologiesInput
  }

  export type technologiesUpsertWithoutPartnersInput = {
    update: XOR<technologiesUncheckedUpdateWithoutPartnersInput, technologiesUpdateWithoutPartnersInput>
    create: XOR<technologiesUncheckedCreateWithoutPartnersInput, technologiesCreateWithoutPartnersInput>
  }

  export type investment_fundsUpdateWithoutPartnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUpdateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUpdateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedUpdateWithoutPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startups?: startupsUncheckedUpdateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUncheckedUpdateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUncheckedUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUpsertWithoutPartnersInput = {
    update: XOR<investment_fundsUncheckedUpdateWithoutPartnersInput, investment_fundsUpdateWithoutPartnersInput>
    create: XOR<investment_fundsUncheckedCreateWithoutPartnersInput, investment_fundsCreateWithoutPartnersInput>
  }

  export type investment_portfolioUpdateWithWhereUniqueWithoutPartnersInput = {
    where: investment_portfolioWhereUniqueInput
    data: XOR<investment_portfolioUncheckedUpdateWithoutPartnersInput, investment_portfolioUpdateWithoutPartnersInput>
  }

  export type investment_portfolioUpdateManyWithWhereWithoutPartnersInput = {
    where: investment_portfolioScalarWhereInput
    data: XOR<investment_portfolioUncheckedUpdateManyWithoutInvestment_portfolioInput, investment_portfolioUpdateManyMutationInput>
  }

  export type investment_portfolioScalarWhereInput = {
    AND?: Enumerable<investment_portfolioScalarWhereInput>
    OR?: Enumerable<investment_portfolioScalarWhereInput>
    NOT?: Enumerable<investment_portfolioScalarWhereInput>
    id?: IntFilter | number
    partner_id?: IntFilter | number
    img_url?: StringFilter | string
  }

  export type investment_portfolioUpsertWithWhereUniqueWithoutPartnersInput = {
    where: investment_portfolioWhereUniqueInput
    update: XOR<investment_portfolioUncheckedUpdateWithoutPartnersInput, investment_portfolioUpdateWithoutPartnersInput>
    create: XOR<investment_portfolioUncheckedCreateWithoutPartnersInput, investment_portfolioCreateWithoutPartnersInput>
  }

  export type IR_requestsUpdateWithWhereUniqueWithoutPartnersInput = {
    where: IR_requestsWhereUniqueInput
    data: XOR<IR_requestsUncheckedUpdateWithoutPartnersInput, IR_requestsUpdateWithoutPartnersInput>
  }

  export type IR_requestsUpdateManyWithWhereWithoutPartnersInput = {
    where: IR_requestsScalarWhereInput
    data: XOR<IR_requestsUncheckedUpdateManyWithoutIR_requestsInput, IR_requestsUpdateManyMutationInput>
  }

  export type IR_requestsUpsertWithWhereUniqueWithoutPartnersInput = {
    where: IR_requestsWhereUniqueInput
    update: XOR<IR_requestsUncheckedUpdateWithoutPartnersInput, IR_requestsUpdateWithoutPartnersInput>
    create: XOR<IR_requestsUncheckedCreateWithoutPartnersInput, IR_requestsCreateWithoutPartnersInput>
  }

  export type invested_toUpdateWithWhereUniqueWithoutPartnersInput = {
    where: invested_toWhereUniqueInput
    data: XOR<invested_toUncheckedUpdateWithoutPartnersInput, invested_toUpdateWithoutPartnersInput>
  }

  export type invested_toUpdateManyWithWhereWithoutPartnersInput = {
    where: invested_toScalarWhereInput
    data: XOR<invested_toUncheckedUpdateManyWithoutInvested_toInput, invested_toUpdateManyMutationInput>
  }

  export type invested_toUpsertWithWhereUniqueWithoutPartnersInput = {
    where: invested_toWhereUniqueInput
    update: XOR<invested_toUncheckedUpdateWithoutPartnersInput, invested_toUpdateWithoutPartnersInput>
    create: XOR<invested_toUncheckedCreateWithoutPartnersInput, invested_toCreateWithoutPartnersInput>
  }

  export type usersCreateWithoutPartner_likesInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPartner_likesInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutpartner_likesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutPartner_likesInput, usersCreateWithoutPartner_likesInput>
  }

  export type companiesCreateWithoutPartner_likesInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutPartner_likesInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutpartner_likesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutPartner_likesInput, companiesCreateWithoutPartner_likesInput>
  }

  export type usersUpdateWithoutPartner_likesInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutPartner_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type usersUpsertWithoutPartner_likesInput = {
    update: XOR<usersUncheckedUpdateWithoutPartner_likesInput, usersUpdateWithoutPartner_likesInput>
    create: XOR<usersUncheckedCreateWithoutPartner_likesInput, usersCreateWithoutPartner_likesInput>
  }

  export type companiesUpdateWithoutPartner_likesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutPartner_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutPartner_likesInput = {
    update: XOR<companiesUncheckedUpdateWithoutPartner_likesInput, companiesUpdateWithoutPartner_likesInput>
    create: XOR<companiesUncheckedCreateWithoutPartner_likesInput, companiesCreateWithoutPartner_likesInput>
  }

  export type projectsCreateWithoutProject_imagesInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligible_sectors?: eligible_sectorsCreateOneWithoutProjectsInput
    eligibilities?: eligibilitiesCreateOneWithoutProjectsInput
    companies?: companiesCreateOneWithoutProjectsInput
    applicants?: applicantsCreateManyWithoutProjectsInput
    project_likes?: project_likesCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectCreateManyWithoutProjectsInput
    required_documents?: required_documentsCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutProject_imagesInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    company_id?: number | null
    host?: string | null
    due_date?: Date | string | null
    eligible_sector?: number | null
    eligibility?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutproject_imagesInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsUncheckedCreateWithoutProject_imagesInput, projectsCreateWithoutProject_imagesInput>
  }

  export type projectsUpdateWithoutProject_imagesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sectors?: eligible_sectorsUpdateOneWithoutProjectsInput
    eligibilities?: eligibilitiesUpdateOneWithoutProjectsInput
    companies?: companiesUpdateOneWithoutProjectsInput
    applicants?: applicantsUpdateManyWithoutProjectsInput
    project_likes?: project_likesUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateWithoutProject_imagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutProjectsInput
  }

  export type projectsUpsertWithoutProject_imagesInput = {
    update: XOR<projectsUncheckedUpdateWithoutProject_imagesInput, projectsUpdateWithoutProject_imagesInput>
    create: XOR<projectsUncheckedCreateWithoutProject_imagesInput, projectsCreateWithoutProject_imagesInput>
  }

  export type usersCreateWithoutProject_likesInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutProject_likesInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutproject_likesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutProject_likesInput, usersCreateWithoutProject_likesInput>
  }

  export type projectsCreateWithoutProject_likesInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligible_sectors?: eligible_sectorsCreateOneWithoutProjectsInput
    eligibilities?: eligibilitiesCreateOneWithoutProjectsInput
    companies?: companiesCreateOneWithoutProjectsInput
    applicants?: applicantsCreateManyWithoutProjectsInput
    project_images?: project_imagesCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectCreateManyWithoutProjectsInput
    required_documents?: required_documentsCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutProject_likesInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    company_id?: number | null
    host?: string | null
    due_date?: Date | string | null
    eligible_sector?: number | null
    eligibility?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutproject_likesInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsUncheckedCreateWithoutProject_likesInput, projectsCreateWithoutProject_likesInput>
  }

  export type companiesCreateWithoutProject_likesInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutProject_likesInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutproject_likesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutProject_likesInput, companiesCreateWithoutProject_likesInput>
  }

  export type usersUpdateWithoutProject_likesInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutProject_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type usersUpsertWithoutProject_likesInput = {
    update: XOR<usersUncheckedUpdateWithoutProject_likesInput, usersUpdateWithoutProject_likesInput>
    create: XOR<usersUncheckedCreateWithoutProject_likesInput, usersCreateWithoutProject_likesInput>
  }

  export type projectsUpdateWithoutProject_likesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sectors?: eligible_sectorsUpdateOneWithoutProjectsInput
    eligibilities?: eligibilitiesUpdateOneWithoutProjectsInput
    companies?: companiesUpdateOneWithoutProjectsInput
    applicants?: applicantsUpdateManyWithoutProjectsInput
    project_images?: project_imagesUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateWithoutProject_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutProjectsInput
  }

  export type projectsUpsertWithoutProject_likesInput = {
    update: XOR<projectsUncheckedUpdateWithoutProject_likesInput, projectsUpdateWithoutProject_likesInput>
    create: XOR<projectsUncheckedCreateWithoutProject_likesInput, projectsCreateWithoutProject_likesInput>
  }

  export type companiesUpdateWithoutProject_likesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutProject_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutProject_likesInput = {
    update: XOR<companiesUncheckedUpdateWithoutProject_likesInput, companiesUpdateWithoutProject_likesInput>
    create: XOR<companiesUncheckedCreateWithoutProject_likesInput, companiesCreateWithoutProject_likesInput>
  }

  export type eligible_sectorsCreateWithoutProjectsInput = {
    name: string
  }

  export type eligible_sectorsUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
  }

  export type eligible_sectorsCreateOrConnectWithoutprojectsInput = {
    where: eligible_sectorsWhereUniqueInput
    create: XOR<eligible_sectorsUncheckedCreateWithoutProjectsInput, eligible_sectorsCreateWithoutProjectsInput>
  }

  export type eligibilitiesCreateWithoutProjectsInput = {
    name: string
  }

  export type eligibilitiesUncheckedCreateWithoutProjectsInput = {
    id?: number
    name: string
  }

  export type eligibilitiesCreateOrConnectWithoutprojectsInput = {
    where: eligibilitiesWhereUniqueInput
    create: XOR<eligibilitiesUncheckedCreateWithoutProjectsInput, eligibilitiesCreateWithoutProjectsInput>
  }

  export type companiesCreateWithoutProjectsInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutProjectsInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutprojectsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutProjectsInput, companiesCreateWithoutProjectsInput>
  }

  export type applicantsCreateWithoutProjectsInput = {
    business_brief?: string | null
    business_model?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutApplicantsInput
    applicant_documents?: applicant_documentsCreateManyWithoutApplicantsInput
  }

  export type applicantsUncheckedCreateWithoutProjectsInput = {
    id?: number
    company_id: number
    business_brief?: string | null
    business_model?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicant_documents?: applicant_documentsUncheckedCreateManyWithoutApplicantsInput
  }

  export type applicantsCreateOrConnectWithoutprojectsInput = {
    where: applicantsWhereUniqueInput
    create: XOR<applicantsUncheckedCreateWithoutProjectsInput, applicantsCreateWithoutProjectsInput>
  }

  export type project_imagesCreateWithoutProjectsInput = {
    img_url?: string | null
  }

  export type project_imagesUncheckedCreateWithoutProjectsInput = {
    id?: number
    img_url?: string | null
  }

  export type project_imagesCreateOrConnectWithoutprojectsInput = {
    where: project_imagesWhereUniqueInput
    create: XOR<project_imagesUncheckedCreateWithoutProjectsInput, project_imagesCreateWithoutProjectsInput>
  }

  export type project_likesCreateWithoutProjectsInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateOneWithoutProject_likesInput
    companies?: companiesCreateOneWithoutProject_likesInput
  }

  export type project_likesUncheckedCreateWithoutProjectsInput = {
    id?: number
    user_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companiesId?: number | null
  }

  export type project_likesCreateOrConnectWithoutprojectsInput = {
    where: project_likesWhereUniqueInput
    create: XOR<project_likesUncheckedCreateWithoutProjectsInput, project_likesCreateWithoutProjectsInput>
  }

  export type recent_views_projectCreateWithoutProjectsInput = {
    created_at?: Date | string
    updated_at?: Date | string
    companies: companiesCreateOneWithoutRecent_views_projectInput
  }

  export type recent_views_projectUncheckedCreateWithoutProjectsInput = {
    id?: number
    company_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type recent_views_projectCreateOrConnectWithoutprojectsInput = {
    where: recent_views_projectWhereUniqueInput
    create: XOR<recent_views_projectUncheckedCreateWithoutProjectsInput, recent_views_projectCreateWithoutProjectsInput>
  }

  export type required_documentsCreateWithoutProjectsInput = {
    document_types: document_typesCreateOneWithoutRequired_documentsInput
  }

  export type required_documentsUncheckedCreateWithoutProjectsInput = {
    id?: number
    document_id: number
  }

  export type required_documentsCreateOrConnectWithoutprojectsInput = {
    where: required_documentsWhereUniqueInput
    create: XOR<required_documentsUncheckedCreateWithoutProjectsInput, required_documentsCreateWithoutProjectsInput>
  }

  export type eligible_sectorsUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type eligible_sectorsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type eligible_sectorsUpsertWithoutProjectsInput = {
    update: XOR<eligible_sectorsUncheckedUpdateWithoutProjectsInput, eligible_sectorsUpdateWithoutProjectsInput>
    create: XOR<eligible_sectorsUncheckedCreateWithoutProjectsInput, eligible_sectorsCreateWithoutProjectsInput>
  }

  export type eligibilitiesUpdateWithoutProjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type eligibilitiesUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type eligibilitiesUpsertWithoutProjectsInput = {
    update: XOR<eligibilitiesUncheckedUpdateWithoutProjectsInput, eligibilitiesUpdateWithoutProjectsInput>
    create: XOR<eligibilitiesUncheckedCreateWithoutProjectsInput, eligibilitiesCreateWithoutProjectsInput>
  }

  export type companiesUpdateWithoutProjectsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutProjectsInput = {
    update: XOR<companiesUncheckedUpdateWithoutProjectsInput, companiesUpdateWithoutProjectsInput>
    create: XOR<companiesUncheckedCreateWithoutProjectsInput, companiesCreateWithoutProjectsInput>
  }

  export type applicantsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: applicantsWhereUniqueInput
    data: XOR<applicantsUncheckedUpdateWithoutProjectsInput, applicantsUpdateWithoutProjectsInput>
  }

  export type applicantsUpdateManyWithWhereWithoutProjectsInput = {
    where: applicantsScalarWhereInput
    data: XOR<applicantsUncheckedUpdateManyWithoutApplicantsInput, applicantsUpdateManyMutationInput>
  }

  export type applicantsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: applicantsWhereUniqueInput
    update: XOR<applicantsUncheckedUpdateWithoutProjectsInput, applicantsUpdateWithoutProjectsInput>
    create: XOR<applicantsUncheckedCreateWithoutProjectsInput, applicantsCreateWithoutProjectsInput>
  }

  export type project_imagesUpdateWithWhereUniqueWithoutProjectsInput = {
    where: project_imagesWhereUniqueInput
    data: XOR<project_imagesUncheckedUpdateWithoutProjectsInput, project_imagesUpdateWithoutProjectsInput>
  }

  export type project_imagesUpdateManyWithWhereWithoutProjectsInput = {
    where: project_imagesScalarWhereInput
    data: XOR<project_imagesUncheckedUpdateManyWithoutProject_imagesInput, project_imagesUpdateManyMutationInput>
  }

  export type project_imagesScalarWhereInput = {
    AND?: Enumerable<project_imagesScalarWhereInput>
    OR?: Enumerable<project_imagesScalarWhereInput>
    NOT?: Enumerable<project_imagesScalarWhereInput>
    id?: IntFilter | number
    project_id?: IntFilter | number
    img_url?: StringNullableFilter | string | null
  }

  export type project_imagesUpsertWithWhereUniqueWithoutProjectsInput = {
    where: project_imagesWhereUniqueInput
    update: XOR<project_imagesUncheckedUpdateWithoutProjectsInput, project_imagesUpdateWithoutProjectsInput>
    create: XOR<project_imagesUncheckedCreateWithoutProjectsInput, project_imagesCreateWithoutProjectsInput>
  }

  export type project_likesUpdateWithWhereUniqueWithoutProjectsInput = {
    where: project_likesWhereUniqueInput
    data: XOR<project_likesUncheckedUpdateWithoutProjectsInput, project_likesUpdateWithoutProjectsInput>
  }

  export type project_likesUpdateManyWithWhereWithoutProjectsInput = {
    where: project_likesScalarWhereInput
    data: XOR<project_likesUncheckedUpdateManyWithoutProject_likesInput, project_likesUpdateManyMutationInput>
  }

  export type project_likesUpsertWithWhereUniqueWithoutProjectsInput = {
    where: project_likesWhereUniqueInput
    update: XOR<project_likesUncheckedUpdateWithoutProjectsInput, project_likesUpdateWithoutProjectsInput>
    create: XOR<project_likesUncheckedCreateWithoutProjectsInput, project_likesCreateWithoutProjectsInput>
  }

  export type recent_views_projectUpdateWithWhereUniqueWithoutProjectsInput = {
    where: recent_views_projectWhereUniqueInput
    data: XOR<recent_views_projectUncheckedUpdateWithoutProjectsInput, recent_views_projectUpdateWithoutProjectsInput>
  }

  export type recent_views_projectUpdateManyWithWhereWithoutProjectsInput = {
    where: recent_views_projectScalarWhereInput
    data: XOR<recent_views_projectUncheckedUpdateManyWithoutRecent_views_projectInput, recent_views_projectUpdateManyMutationInput>
  }

  export type recent_views_projectUpsertWithWhereUniqueWithoutProjectsInput = {
    where: recent_views_projectWhereUniqueInput
    update: XOR<recent_views_projectUncheckedUpdateWithoutProjectsInput, recent_views_projectUpdateWithoutProjectsInput>
    create: XOR<recent_views_projectUncheckedCreateWithoutProjectsInput, recent_views_projectCreateWithoutProjectsInput>
  }

  export type required_documentsUpdateWithWhereUniqueWithoutProjectsInput = {
    where: required_documentsWhereUniqueInput
    data: XOR<required_documentsUncheckedUpdateWithoutProjectsInput, required_documentsUpdateWithoutProjectsInput>
  }

  export type required_documentsUpdateManyWithWhereWithoutProjectsInput = {
    where: required_documentsScalarWhereInput
    data: XOR<required_documentsUncheckedUpdateManyWithoutRequired_documentsInput, required_documentsUpdateManyMutationInput>
  }

  export type required_documentsUpsertWithWhereUniqueWithoutProjectsInput = {
    where: required_documentsWhereUniqueInput
    update: XOR<required_documentsUncheckedUpdateWithoutProjectsInput, required_documentsUpdateWithoutProjectsInput>
    create: XOR<required_documentsUncheckedCreateWithoutProjectsInput, required_documentsCreateWithoutProjectsInput>
  }

  export type companiesCreateWithoutQuestionsInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutQuestionsInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutquestionsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutQuestionsInput, companiesCreateWithoutQuestionsInput>
  }

  export type demodaysCreateWithoutQuestionsInput = {
    name?: string | null
    streaming_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies?: companiesCreateOneWithoutDemodaysInput
    participants?: participantsCreateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedCreateWithoutQuestionsInput = {
    id?: number
    name?: string | null
    company_id?: number | null
    streaming_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    participants?: participantsUncheckedCreateManyWithoutDemodaysInput
  }

  export type demodaysCreateOrConnectWithoutquestionsInput = {
    where: demodaysWhereUniqueInput
    create: XOR<demodaysUncheckedCreateWithoutQuestionsInput, demodaysCreateWithoutQuestionsInput>
  }

  export type usersCreateWithoutQuestionsInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutQuestionsInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutquestionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutQuestionsInput, usersCreateWithoutQuestionsInput>
  }

  export type answersCreateWithoutQuestionsInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type answersUncheckedCreateWithoutQuestionsInput = {
    id?: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type answersCreateOrConnectWithoutquestionsInput = {
    where: answersWhereUniqueInput
    create: XOR<answersUncheckedCreateWithoutQuestionsInput, answersCreateWithoutQuestionsInput>
  }

  export type companiesUpdateWithoutQuestionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutQuestionsInput = {
    update: XOR<companiesUncheckedUpdateWithoutQuestionsInput, companiesUpdateWithoutQuestionsInput>
    create: XOR<companiesUncheckedCreateWithoutQuestionsInput, companiesCreateWithoutQuestionsInput>
  }

  export type demodaysUpdateWithoutQuestionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneWithoutDemodaysInput
    participants?: participantsUpdateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: participantsUncheckedUpdateManyWithoutDemodaysInput
  }

  export type demodaysUpsertWithoutQuestionsInput = {
    update: XOR<demodaysUncheckedUpdateWithoutQuestionsInput, demodaysUpdateWithoutQuestionsInput>
    create: XOR<demodaysUncheckedCreateWithoutQuestionsInput, demodaysCreateWithoutQuestionsInput>
  }

  export type usersUpdateWithoutQuestionsInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type usersUpsertWithoutQuestionsInput = {
    update: XOR<usersUncheckedUpdateWithoutQuestionsInput, usersUpdateWithoutQuestionsInput>
    create: XOR<usersUncheckedCreateWithoutQuestionsInput, usersCreateWithoutQuestionsInput>
  }

  export type answersUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: answersWhereUniqueInput
    data: XOR<answersUncheckedUpdateWithoutQuestionsInput, answersUpdateWithoutQuestionsInput>
  }

  export type answersUpdateManyWithWhereWithoutQuestionsInput = {
    where: answersScalarWhereInput
    data: XOR<answersUncheckedUpdateManyWithoutAnswersInput, answersUpdateManyMutationInput>
  }

  export type answersScalarWhereInput = {
    AND?: Enumerable<answersScalarWhereInput>
    OR?: Enumerable<answersScalarWhereInput>
    NOT?: Enumerable<answersScalarWhereInput>
    id?: IntFilter | number
    content?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    question_id?: IntFilter | number
  }

  export type answersUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: answersWhereUniqueInput
    update: XOR<answersUncheckedUpdateWithoutQuestionsInput, answersUpdateWithoutQuestionsInput>
    create: XOR<answersUncheckedCreateWithoutQuestionsInput, answersCreateWithoutQuestionsInput>
  }

  export type companiesCreateWithoutRecent_views_projectInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutRecent_views_projectInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutrecent_views_projectInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutRecent_views_projectInput, companiesCreateWithoutRecent_views_projectInput>
  }

  export type projectsCreateWithoutRecent_views_projectInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligible_sectors?: eligible_sectorsCreateOneWithoutProjectsInput
    eligibilities?: eligibilitiesCreateOneWithoutProjectsInput
    companies?: companiesCreateOneWithoutProjectsInput
    applicants?: applicantsCreateManyWithoutProjectsInput
    project_images?: project_imagesCreateManyWithoutProjectsInput
    project_likes?: project_likesCreateManyWithoutProjectsInput
    required_documents?: required_documentsCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutRecent_views_projectInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    company_id?: number | null
    host?: string | null
    due_date?: Date | string | null
    eligible_sector?: number | null
    eligibility?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedCreateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedCreateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutrecent_views_projectInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsUncheckedCreateWithoutRecent_views_projectInput, projectsCreateWithoutRecent_views_projectInput>
  }

  export type companiesUpdateWithoutRecent_views_projectInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutRecent_views_projectInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutRecent_views_projectInput = {
    update: XOR<companiesUncheckedUpdateWithoutRecent_views_projectInput, companiesUpdateWithoutRecent_views_projectInput>
    create: XOR<companiesUncheckedCreateWithoutRecent_views_projectInput, companiesCreateWithoutRecent_views_projectInput>
  }

  export type projectsUpdateWithoutRecent_views_projectInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sectors?: eligible_sectorsUpdateOneWithoutProjectsInput
    eligibilities?: eligibilitiesUpdateOneWithoutProjectsInput
    companies?: companiesUpdateOneWithoutProjectsInput
    applicants?: applicantsUpdateManyWithoutProjectsInput
    project_images?: project_imagesUpdateManyWithoutProjectsInput
    project_likes?: project_likesUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateWithoutRecent_views_projectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedUpdateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutProjectsInput
  }

  export type projectsUpsertWithoutRecent_views_projectInput = {
    update: XOR<projectsUncheckedUpdateWithoutRecent_views_projectInput, projectsUpdateWithoutRecent_views_projectInput>
    create: XOR<projectsUncheckedCreateWithoutRecent_views_projectInput, projectsCreateWithoutRecent_views_projectInput>
  }

  export type document_typesCreateWithoutRequired_documentsInput = {
    name: string
    company_documents?: company_documentsCreateManyWithoutDocument_typesInput
  }

  export type document_typesUncheckedCreateWithoutRequired_documentsInput = {
    id?: number
    name: string
    company_documents?: company_documentsUncheckedCreateManyWithoutDocument_typesInput
  }

  export type document_typesCreateOrConnectWithoutrequired_documentsInput = {
    where: document_typesWhereUniqueInput
    create: XOR<document_typesUncheckedCreateWithoutRequired_documentsInput, document_typesCreateWithoutRequired_documentsInput>
  }

  export type projectsCreateWithoutRequired_documentsInput = {
    name?: string | null
    introduction?: string | null
    host?: string | null
    due_date?: Date | string | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    eligible_sectors?: eligible_sectorsCreateOneWithoutProjectsInput
    eligibilities?: eligibilitiesCreateOneWithoutProjectsInput
    companies?: companiesCreateOneWithoutProjectsInput
    applicants?: applicantsCreateManyWithoutProjectsInput
    project_images?: project_imagesCreateManyWithoutProjectsInput
    project_likes?: project_likesCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectCreateManyWithoutProjectsInput
  }

  export type projectsUncheckedCreateWithoutRequired_documentsInput = {
    id?: number
    name?: string | null
    introduction?: string | null
    company_id?: number | null
    host?: string | null
    due_date?: Date | string | null
    eligible_sector?: number | null
    eligibility?: number | null
    outline?: string | null
    detail?: string | null
    application_method?: string | null
    caution?: string | null
    contact?: string | null
    is_opened?: boolean
    hit: number
    application_url?: string | null
    is_saved?: boolean
    request_open?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedCreateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedCreateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutProjectsInput
  }

  export type projectsCreateOrConnectWithoutrequired_documentsInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsUncheckedCreateWithoutRequired_documentsInput, projectsCreateWithoutRequired_documentsInput>
  }

  export type document_typesUpdateWithoutRequired_documentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    company_documents?: company_documentsUpdateManyWithoutDocument_typesInput
  }

  export type document_typesUncheckedUpdateWithoutRequired_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company_documents?: company_documentsUncheckedUpdateManyWithoutDocument_typesInput
  }

  export type document_typesUpsertWithoutRequired_documentsInput = {
    update: XOR<document_typesUncheckedUpdateWithoutRequired_documentsInput, document_typesUpdateWithoutRequired_documentsInput>
    create: XOR<document_typesUncheckedCreateWithoutRequired_documentsInput, document_typesCreateWithoutRequired_documentsInput>
  }

  export type projectsUpdateWithoutRequired_documentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sectors?: eligible_sectorsUpdateOneWithoutProjectsInput
    eligibilities?: eligibilitiesUpdateOneWithoutProjectsInput
    companies?: companiesUpdateOneWithoutProjectsInput
    applicants?: applicantsUpdateManyWithoutProjectsInput
    project_images?: project_imagesUpdateManyWithoutProjectsInput
    project_likes?: project_likesUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateWithoutRequired_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedUpdateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutProjectsInput
  }

  export type projectsUpsertWithoutRequired_documentsInput = {
    update: XOR<projectsUncheckedUpdateWithoutRequired_documentsInput, projectsUpdateWithoutRequired_documentsInput>
    create: XOR<projectsUncheckedCreateWithoutRequired_documentsInput, projectsCreateWithoutRequired_documentsInput>
  }

  export type startupsCreateWithoutSectorsInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutSectorsInput = {
    id?: number
    company_id: number
    rep?: string | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutsectorsInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutSectorsInput, startupsCreateWithoutSectorsInput>
  }

  export type startupsUpdateWithWhereUniqueWithoutSectorsInput = {
    where: startupsWhereUniqueInput
    data: XOR<startupsUncheckedUpdateWithoutSectorsInput, startupsUpdateWithoutSectorsInput>
  }

  export type startupsUpdateManyWithWhereWithoutSectorsInput = {
    where: startupsScalarWhereInput
    data: XOR<startupsUncheckedUpdateManyWithoutStartupsInput, startupsUpdateManyMutationInput>
  }

  export type startupsUpsertWithWhereUniqueWithoutSectorsInput = {
    where: startupsWhereUniqueInput
    update: XOR<startupsUncheckedUpdateWithoutSectorsInput, startupsUpdateWithoutSectorsInput>
    create: XOR<startupsUncheckedCreateWithoutSectorsInput, startupsCreateWithoutSectorsInput>
  }

  export type startupsCreateWithoutService_typesInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutService_typesInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutservice_typesInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutService_typesInput, startupsCreateWithoutService_typesInput>
  }

  export type startupsUpdateWithWhereUniqueWithoutService_typesInput = {
    where: startupsWhereUniqueInput
    data: XOR<startupsUncheckedUpdateWithoutService_typesInput, startupsUpdateWithoutService_typesInput>
  }

  export type startupsUpdateManyWithWhereWithoutService_typesInput = {
    where: startupsScalarWhereInput
    data: XOR<startupsUncheckedUpdateManyWithoutStartupsInput, startupsUpdateManyMutationInput>
  }

  export type startupsUpsertWithWhereUniqueWithoutService_typesInput = {
    where: startupsWhereUniqueInput
    update: XOR<startupsUncheckedUpdateWithoutService_typesInput, startupsUpdateWithoutService_typesInput>
    create: XOR<startupsUncheckedCreateWithoutService_typesInput, startupsCreateWithoutService_typesInput>
  }

  export type usersCreateWithoutSignup_methodsInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSignup_methodsInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutsignup_methodsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutSignup_methodsInput, usersCreateWithoutSignup_methodsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutSignup_methodsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUncheckedUpdateWithoutSignup_methodsInput, usersUpdateWithoutSignup_methodsInput>
  }

  export type usersUpdateManyWithWhereWithoutSignup_methodsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUncheckedUpdateManyWithoutUsersInput, usersUpdateManyMutationInput>
  }

  export type usersUpsertWithWhereUniqueWithoutSignup_methodsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUncheckedUpdateWithoutSignup_methodsInput, usersUpdateWithoutSignup_methodsInput>
    create: XOR<usersUncheckedCreateWithoutSignup_methodsInput, usersCreateWithoutSignup_methodsInput>
  }

  export type startupsCreateWithoutStartup_imagesInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutStartup_imagesInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutstartup_imagesInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutStartup_imagesInput, startupsCreateWithoutStartup_imagesInput>
  }

  export type startupsUpdateWithoutStartup_imagesInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutStartup_imagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type startupsUpsertWithoutStartup_imagesInput = {
    update: XOR<startupsUncheckedUpdateWithoutStartup_imagesInput, startupsUpdateWithoutStartup_imagesInput>
    create: XOR<startupsUncheckedCreateWithoutStartup_imagesInput, startupsCreateWithoutStartup_imagesInput>
  }

  export type business_typesCreateWithoutStartupsInput = {
    name: string
  }

  export type business_typesUncheckedCreateWithoutStartupsInput = {
    id?: number
    name: string
  }

  export type business_typesCreateOrConnectWithoutstartupsInput = {
    where: business_typesWhereUniqueInput
    create: XOR<business_typesUncheckedCreateWithoutStartupsInput, business_typesCreateWithoutStartupsInput>
  }

  export type companiesCreateWithoutStartupsInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutStartupsInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutstartupsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutStartupsInput, companiesCreateWithoutStartupsInput>
  }

  export type technologiesCreateWithoutStartupsInput = {
    name: string
    partners?: partnersCreateManyWithoutTechnologiesInput
  }

  export type technologiesUncheckedCreateWithoutStartupsInput = {
    id?: number
    name: string
    partners?: partnersUncheckedCreateManyWithoutTechnologiesInput
  }

  export type technologiesCreateOrConnectWithoutstartupsInput = {
    where: technologiesWhereUniqueInput
    create: XOR<technologiesUncheckedCreateWithoutStartupsInput, technologiesCreateWithoutStartupsInput>
  }

  export type sectorsCreateWithoutStartupsInput = {
    name: string
  }

  export type sectorsUncheckedCreateWithoutStartupsInput = {
    id?: number
    name: string
  }

  export type sectorsCreateOrConnectWithoutstartupsInput = {
    where: sectorsWhereUniqueInput
    create: XOR<sectorsUncheckedCreateWithoutStartupsInput, sectorsCreateWithoutStartupsInput>
  }

  export type service_typesCreateWithoutStartupsInput = {
    name: string
  }

  export type service_typesUncheckedCreateWithoutStartupsInput = {
    id?: number
    name: string
  }

  export type service_typesCreateOrConnectWithoutstartupsInput = {
    where: service_typesWhereUniqueInput
    create: XOR<service_typesUncheckedCreateWithoutStartupsInput, service_typesCreateWithoutStartupsInput>
  }

  export type investment_seriesCreateWithoutStartupsInput = {
    name: string
    invested_from?: invested_fromCreateManyWithoutInvestment_seriesInput
    invested_to?: invested_toCreateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedCreateWithoutStartupsInput = {
    id?: number
    name: string
    invested_from?: invested_fromUncheckedCreateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUncheckedCreateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesCreateOrConnectWithoutstartupsInput = {
    where: investment_seriesWhereUniqueInput
    create: XOR<investment_seriesUncheckedCreateWithoutStartupsInput, investment_seriesCreateWithoutStartupsInput>
  }

  export type investment_fundsCreateWithoutStartupsInput = {
    name: string
    partners?: partnersCreateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromCreateManyWithoutInvestment_fundsInput
    invested_to?: invested_toCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedCreateWithoutStartupsInput = {
    id?: number
    name: string
    partners?: partnersUncheckedCreateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUncheckedCreateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUncheckedCreateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsCreateOrConnectWithoutstartupsInput = {
    where: investment_fundsWhereUniqueInput
    create: XOR<investment_fundsUncheckedCreateWithoutStartupsInput, investment_fundsCreateWithoutStartupsInput>
  }

  export type invested_fromCreateWithoutStartupsInput = {
    date: Date | string
    invested_institution: string
    corporate_value: number
    investment_series: investment_seriesCreateOneWithoutInvested_fromInput
    investment_funds: investment_fundsCreateOneWithoutInvested_fromInput
  }

  export type invested_fromUncheckedCreateWithoutStartupsInput = {
    id?: number
    date: Date | string
    invested_institution: string
    invested_fund_id: number
    corporate_value: number
    series_id: number
  }

  export type invested_fromCreateOrConnectWithoutstartupsInput = {
    where: invested_fromWhereUniqueInput
    create: XOR<invested_fromUncheckedCreateWithoutStartupsInput, invested_fromCreateWithoutStartupsInput>
  }

  export type startup_imagesCreateWithoutStartupsInput = {
    img_url: string
  }

  export type startup_imagesUncheckedCreateWithoutStartupsInput = {
    id?: number
    img_url: string
  }

  export type startup_imagesCreateOrConnectWithoutstartupsInput = {
    where: startup_imagesWhereUniqueInput
    create: XOR<startup_imagesUncheckedCreateWithoutStartupsInput, startup_imagesCreateWithoutStartupsInput>
  }

  export type wish_investment_seriesCreateWithoutStartupsInput = {
    investment_series: investment_seriesCreateOneWithoutWish_investment_seriesInput
  }

  export type wish_investment_seriesUncheckedCreateWithoutStartupsInput = {
    id?: number
    investment_series_id: number
  }

  export type wish_investment_seriesCreateOrConnectWithoutstartupsInput = {
    where: wish_investment_seriesWhereUniqueInput
    create: XOR<wish_investment_seriesUncheckedCreateWithoutStartupsInput, wish_investment_seriesCreateWithoutStartupsInput>
  }

  export type IR_requestsCreateWithoutStartupsInput = {
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    company_documents?: company_documentsCreateOneWithoutIR_requestsInput
    partners: partnersCreateOneWithoutIR_requestsInput
    companies?: companiesCreateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedCreateWithoutStartupsInput = {
    id?: number
    partner_id: number
    document_id?: number | null
    is_checked: number
    from_partner: number
    created_at?: Date | string
    updated_at?: Date | string
    companiesId?: number | null
  }

  export type IR_requestsCreateOrConnectWithoutstartupsInput = {
    where: IR_requestsWhereUniqueInput
    create: XOR<IR_requestsUncheckedCreateWithoutStartupsInput, IR_requestsCreateWithoutStartupsInput>
  }

  export type business_typesUpdateWithoutStartupsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type business_typesUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type business_typesUpsertWithoutStartupsInput = {
    update: XOR<business_typesUncheckedUpdateWithoutStartupsInput, business_typesUpdateWithoutStartupsInput>
    create: XOR<business_typesUncheckedCreateWithoutStartupsInput, business_typesCreateWithoutStartupsInput>
  }

  export type companiesUpdateWithoutStartupsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutStartupsInput = {
    update: XOR<companiesUncheckedUpdateWithoutStartupsInput, companiesUpdateWithoutStartupsInput>
    create: XOR<companiesUncheckedCreateWithoutStartupsInput, companiesCreateWithoutStartupsInput>
  }

  export type technologiesUpdateWithoutStartupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUpdateManyWithoutTechnologiesInput
  }

  export type technologiesUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUncheckedUpdateManyWithoutTechnologiesInput
  }

  export type technologiesUpsertWithoutStartupsInput = {
    update: XOR<technologiesUncheckedUpdateWithoutStartupsInput, technologiesUpdateWithoutStartupsInput>
    create: XOR<technologiesUncheckedCreateWithoutStartupsInput, technologiesCreateWithoutStartupsInput>
  }

  export type sectorsUpdateWithoutStartupsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type sectorsUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type sectorsUpsertWithoutStartupsInput = {
    update: XOR<sectorsUncheckedUpdateWithoutStartupsInput, sectorsUpdateWithoutStartupsInput>
    create: XOR<sectorsUncheckedCreateWithoutStartupsInput, sectorsCreateWithoutStartupsInput>
  }

  export type service_typesUpdateWithoutStartupsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type service_typesUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type service_typesUpsertWithoutStartupsInput = {
    update: XOR<service_typesUncheckedUpdateWithoutStartupsInput, service_typesUpdateWithoutStartupsInput>
    create: XOR<service_typesUncheckedCreateWithoutStartupsInput, service_typesCreateWithoutStartupsInput>
  }

  export type investment_seriesUpdateWithoutStartupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    invested_from?: invested_fromUpdateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUpdateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    invested_from?: invested_fromUncheckedUpdateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUncheckedUpdateManyWithoutInvestment_seriesInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUpsertWithoutStartupsInput = {
    update: XOR<investment_seriesUncheckedUpdateWithoutStartupsInput, investment_seriesUpdateWithoutStartupsInput>
    create: XOR<investment_seriesUncheckedCreateWithoutStartupsInput, investment_seriesCreateWithoutStartupsInput>
  }

  export type investment_fundsUpdateWithoutStartupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUpdateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUpdateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    partners?: partnersUncheckedUpdateManyWithoutInvestment_fundsInput
    invested_from?: invested_fromUncheckedUpdateManyWithoutInvestment_fundsInput
    invested_to?: invested_toUncheckedUpdateManyWithoutInvestment_fundsInput
  }

  export type investment_fundsUpsertWithoutStartupsInput = {
    update: XOR<investment_fundsUncheckedUpdateWithoutStartupsInput, investment_fundsUpdateWithoutStartupsInput>
    create: XOR<investment_fundsUncheckedCreateWithoutStartupsInput, investment_fundsCreateWithoutStartupsInput>
  }

  export type invested_fromUpdateWithWhereUniqueWithoutStartupsInput = {
    where: invested_fromWhereUniqueInput
    data: XOR<invested_fromUncheckedUpdateWithoutStartupsInput, invested_fromUpdateWithoutStartupsInput>
  }

  export type invested_fromUpdateManyWithWhereWithoutStartupsInput = {
    where: invested_fromScalarWhereInput
    data: XOR<invested_fromUncheckedUpdateManyWithoutInvested_fromInput, invested_fromUpdateManyMutationInput>
  }

  export type invested_fromUpsertWithWhereUniqueWithoutStartupsInput = {
    where: invested_fromWhereUniqueInput
    update: XOR<invested_fromUncheckedUpdateWithoutStartupsInput, invested_fromUpdateWithoutStartupsInput>
    create: XOR<invested_fromUncheckedCreateWithoutStartupsInput, invested_fromCreateWithoutStartupsInput>
  }

  export type startup_imagesUpdateWithWhereUniqueWithoutStartupsInput = {
    where: startup_imagesWhereUniqueInput
    data: XOR<startup_imagesUncheckedUpdateWithoutStartupsInput, startup_imagesUpdateWithoutStartupsInput>
  }

  export type startup_imagesUpdateManyWithWhereWithoutStartupsInput = {
    where: startup_imagesScalarWhereInput
    data: XOR<startup_imagesUncheckedUpdateManyWithoutStartup_imagesInput, startup_imagesUpdateManyMutationInput>
  }

  export type startup_imagesScalarWhereInput = {
    AND?: Enumerable<startup_imagesScalarWhereInput>
    OR?: Enumerable<startup_imagesScalarWhereInput>
    NOT?: Enumerable<startup_imagesScalarWhereInput>
    id?: IntFilter | number
    startup_id?: IntFilter | number
    img_url?: StringFilter | string
  }

  export type startup_imagesUpsertWithWhereUniqueWithoutStartupsInput = {
    where: startup_imagesWhereUniqueInput
    update: XOR<startup_imagesUncheckedUpdateWithoutStartupsInput, startup_imagesUpdateWithoutStartupsInput>
    create: XOR<startup_imagesUncheckedCreateWithoutStartupsInput, startup_imagesCreateWithoutStartupsInput>
  }

  export type wish_investment_seriesUpdateWithWhereUniqueWithoutStartupsInput = {
    where: wish_investment_seriesWhereUniqueInput
    data: XOR<wish_investment_seriesUncheckedUpdateWithoutStartupsInput, wish_investment_seriesUpdateWithoutStartupsInput>
  }

  export type wish_investment_seriesUpdateManyWithWhereWithoutStartupsInput = {
    where: wish_investment_seriesScalarWhereInput
    data: XOR<wish_investment_seriesUncheckedUpdateManyWithoutWish_investment_seriesInput, wish_investment_seriesUpdateManyMutationInput>
  }

  export type wish_investment_seriesUpsertWithWhereUniqueWithoutStartupsInput = {
    where: wish_investment_seriesWhereUniqueInput
    update: XOR<wish_investment_seriesUncheckedUpdateWithoutStartupsInput, wish_investment_seriesUpdateWithoutStartupsInput>
    create: XOR<wish_investment_seriesUncheckedCreateWithoutStartupsInput, wish_investment_seriesCreateWithoutStartupsInput>
  }

  export type IR_requestsUpdateWithWhereUniqueWithoutStartupsInput = {
    where: IR_requestsWhereUniqueInput
    data: XOR<IR_requestsUncheckedUpdateWithoutStartupsInput, IR_requestsUpdateWithoutStartupsInput>
  }

  export type IR_requestsUpdateManyWithWhereWithoutStartupsInput = {
    where: IR_requestsScalarWhereInput
    data: XOR<IR_requestsUncheckedUpdateManyWithoutIR_requestsInput, IR_requestsUpdateManyMutationInput>
  }

  export type IR_requestsUpsertWithWhereUniqueWithoutStartupsInput = {
    where: IR_requestsWhereUniqueInput
    update: XOR<IR_requestsUncheckedUpdateWithoutStartupsInput, IR_requestsUpdateWithoutStartupsInput>
    create: XOR<IR_requestsUncheckedCreateWithoutStartupsInput, IR_requestsCreateWithoutStartupsInput>
  }

  export type startupsCreateWithoutWish_investment_seriesInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    technologies?: technologiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutWish_investment_seriesInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    core_technology_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithoutwish_investment_seriesInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutWish_investment_seriesInput, startupsCreateWithoutWish_investment_seriesInput>
  }

  export type investment_seriesCreateWithoutWish_investment_seriesInput = {
    name: string
    invested_from?: invested_fromCreateManyWithoutInvestment_seriesInput
    invested_to?: invested_toCreateManyWithoutInvestment_seriesInput
    startups?: startupsCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedCreateWithoutWish_investment_seriesInput = {
    id?: number
    name: string
    invested_from?: invested_fromUncheckedCreateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUncheckedCreateManyWithoutInvestment_seriesInput
    startups?: startupsUncheckedCreateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesCreateOrConnectWithoutwish_investment_seriesInput = {
    where: investment_seriesWhereUniqueInput
    create: XOR<investment_seriesUncheckedCreateWithoutWish_investment_seriesInput, investment_seriesCreateWithoutWish_investment_seriesInput>
  }

  export type startupsUpdateWithoutWish_investment_seriesInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutWish_investment_seriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type startupsUpsertWithoutWish_investment_seriesInput = {
    update: XOR<startupsUncheckedUpdateWithoutWish_investment_seriesInput, startupsUpdateWithoutWish_investment_seriesInput>
    create: XOR<startupsUncheckedCreateWithoutWish_investment_seriesInput, startupsCreateWithoutWish_investment_seriesInput>
  }

  export type investment_seriesUpdateWithoutWish_investment_seriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    invested_from?: invested_fromUpdateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUpdateManyWithoutInvestment_seriesInput
    startups?: startupsUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUncheckedUpdateWithoutWish_investment_seriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    invested_from?: invested_fromUncheckedUpdateManyWithoutInvestment_seriesInput
    invested_to?: invested_toUncheckedUpdateManyWithoutInvestment_seriesInput
    startups?: startupsUncheckedUpdateManyWithoutInvestment_seriesInput
  }

  export type investment_seriesUpsertWithoutWish_investment_seriesInput = {
    update: XOR<investment_seriesUncheckedUpdateWithoutWish_investment_seriesInput, investment_seriesUpdateWithoutWish_investment_seriesInput>
    create: XOR<investment_seriesUncheckedCreateWithoutWish_investment_seriesInput, investment_seriesCreateWithoutWish_investment_seriesInput>
  }

  export type companiesCreateWithoutStartup_likesInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    users?: usersCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutStartup_likesInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    users?: usersUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutstartup_likesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutStartup_likesInput, companiesCreateWithoutStartup_likesInput>
  }

  export type usersCreateWithoutStartup_likesInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutStartup_likesInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutstartup_likesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutStartup_likesInput, usersCreateWithoutStartup_likesInput>
  }

  export type companiesUpdateWithoutStartup_likesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutStartup_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutStartup_likesInput = {
    update: XOR<companiesUncheckedUpdateWithoutStartup_likesInput, companiesUpdateWithoutStartup_likesInput>
    create: XOR<companiesUncheckedCreateWithoutStartup_likesInput, companiesCreateWithoutStartup_likesInput>
  }

  export type usersUpdateWithoutStartup_likesInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutStartup_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type usersUpsertWithoutStartup_likesInput = {
    update: XOR<usersUncheckedUpdateWithoutStartup_likesInput, usersUpdateWithoutStartup_likesInput>
    create: XOR<usersUncheckedCreateWithoutStartup_likesInput, usersCreateWithoutStartup_likesInput>
  }

  export type partnersCreateWithoutTechnologiesInput = {
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    companies: companiesCreateOneWithoutPartnersInput
    investment_funds?: investment_fundsCreateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsCreateManyWithoutPartnersInput
    invested_to?: invested_toCreateManyWithoutPartnersInput
  }

  export type partnersUncheckedCreateWithoutTechnologiesInput = {
    id?: number
    company_id: number
    invested_total_id?: number | null
    invested_counts?: number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    investment_portfolio?: investment_portfolioUncheckedCreateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedCreateManyWithoutPartnersInput
  }

  export type partnersCreateOrConnectWithouttechnologiesInput = {
    where: partnersWhereUniqueInput
    create: XOR<partnersUncheckedCreateWithoutTechnologiesInput, partnersCreateWithoutTechnologiesInput>
  }

  export type startupsCreateWithoutTechnologiesInput = {
    rep?: string | null
    item_description?: string | null
    contact?: string | null
    address_road?: string | null
    address_detail?: string | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    business_types?: business_typesCreateOneWithoutStartupsInput
    companies: companiesCreateOneWithoutStartupsInput
    sectors?: sectorsCreateOneWithoutStartupsInput
    service_types?: service_typesCreateOneWithoutStartupsInput
    investment_series?: investment_seriesCreateOneWithoutStartupsInput
    investment_funds?: investment_fundsCreateOneWithoutStartupsInput
    invested_from?: invested_fromCreateManyWithoutStartupsInput
    startup_images?: startup_imagesCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsCreateManyWithoutStartupsInput
  }

  export type startupsUncheckedCreateWithoutTechnologiesInput = {
    id?: number
    company_id: number
    rep?: string | null
    sector_id?: number | null
    item_description?: string | null
    contact?: string | null
    investment_series_id?: number | null
    investment_fund_id?: number | null
    address_road?: string | null
    address_detail?: string | null
    service_type_id?: number | null
    business_type_id?: number | null
    business_license_number?: string | null
    email?: string | null
    instagram_url?: string | null
    facebook_url?: string | null
    thumbnail?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    invested_from?: invested_fromUncheckedCreateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedCreateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedCreateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutStartupsInput
  }

  export type startupsCreateOrConnectWithouttechnologiesInput = {
    where: startupsWhereUniqueInput
    create: XOR<startupsUncheckedCreateWithoutTechnologiesInput, startupsCreateWithoutTechnologiesInput>
  }

  export type partnersUpdateWithWhereUniqueWithoutTechnologiesInput = {
    where: partnersWhereUniqueInput
    data: XOR<partnersUncheckedUpdateWithoutTechnologiesInput, partnersUpdateWithoutTechnologiesInput>
  }

  export type partnersUpdateManyWithWhereWithoutTechnologiesInput = {
    where: partnersScalarWhereInput
    data: XOR<partnersUncheckedUpdateManyWithoutPartnersInput, partnersUpdateManyMutationInput>
  }

  export type partnersUpsertWithWhereUniqueWithoutTechnologiesInput = {
    where: partnersWhereUniqueInput
    update: XOR<partnersUncheckedUpdateWithoutTechnologiesInput, partnersUpdateWithoutTechnologiesInput>
    create: XOR<partnersUncheckedCreateWithoutTechnologiesInput, partnersCreateWithoutTechnologiesInput>
  }

  export type startupsUpdateWithWhereUniqueWithoutTechnologiesInput = {
    where: startupsWhereUniqueInput
    data: XOR<startupsUncheckedUpdateWithoutTechnologiesInput, startupsUpdateWithoutTechnologiesInput>
  }

  export type startupsUpdateManyWithWhereWithoutTechnologiesInput = {
    where: startupsScalarWhereInput
    data: XOR<startupsUncheckedUpdateManyWithoutStartupsInput, startupsUpdateManyMutationInput>
  }

  export type startupsUpsertWithWhereUniqueWithoutTechnologiesInput = {
    where: startupsWhereUniqueInput
    update: XOR<startupsUncheckedUpdateWithoutTechnologiesInput, startupsUpdateWithoutTechnologiesInput>
    create: XOR<startupsUncheckedCreateWithoutTechnologiesInput, startupsCreateWithoutTechnologiesInput>
  }

  export type user_agreementsCreateWithoutTermsInput = {
    users: usersCreateOneWithoutUser_agreementsInput
  }

  export type user_agreementsUncheckedCreateWithoutTermsInput = {
    id?: number
    user_id: number
  }

  export type user_agreementsCreateOrConnectWithouttermsInput = {
    where: user_agreementsWhereUniqueInput
    create: XOR<user_agreementsUncheckedCreateWithoutTermsInput, user_agreementsCreateWithoutTermsInput>
  }

  export type user_agreementsUpdateWithWhereUniqueWithoutTermsInput = {
    where: user_agreementsWhereUniqueInput
    data: XOR<user_agreementsUncheckedUpdateWithoutTermsInput, user_agreementsUpdateWithoutTermsInput>
  }

  export type user_agreementsUpdateManyWithWhereWithoutTermsInput = {
    where: user_agreementsScalarWhereInput
    data: XOR<user_agreementsUncheckedUpdateManyWithoutUser_agreementsInput, user_agreementsUpdateManyMutationInput>
  }

  export type user_agreementsScalarWhereInput = {
    AND?: Enumerable<user_agreementsScalarWhereInput>
    OR?: Enumerable<user_agreementsScalarWhereInput>
    NOT?: Enumerable<user_agreementsScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    term_id?: IntFilter | number
  }

  export type user_agreementsUpsertWithWhereUniqueWithoutTermsInput = {
    where: user_agreementsWhereUniqueInput
    update: XOR<user_agreementsUncheckedUpdateWithoutTermsInput, user_agreementsUpdateWithoutTermsInput>
    create: XOR<user_agreementsUncheckedCreateWithoutTermsInput, user_agreementsCreateWithoutTermsInput>
  }

  export type termsCreateWithoutUser_agreementsInput = {
    name: string
    content: string
    required: boolean
  }

  export type termsUncheckedCreateWithoutUser_agreementsInput = {
    id?: number
    name: string
    content: string
    required: boolean
  }

  export type termsCreateOrConnectWithoutuser_agreementsInput = {
    where: termsWhereUniqueInput
    create: XOR<termsUncheckedCreateWithoutUser_agreementsInput, termsCreateWithoutUser_agreementsInput>
  }

  export type usersCreateWithoutUser_agreementsInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_agreementsInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutuser_agreementsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutUser_agreementsInput, usersCreateWithoutUser_agreementsInput>
  }

  export type termsUpdateWithoutUser_agreementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type termsUncheckedUpdateWithoutUser_agreementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
  }

  export type termsUpsertWithoutUser_agreementsInput = {
    update: XOR<termsUncheckedUpdateWithoutUser_agreementsInput, termsUpdateWithoutUser_agreementsInput>
    create: XOR<termsUncheckedCreateWithoutUser_agreementsInput, termsCreateWithoutUser_agreementsInput>
  }

  export type usersUpdateWithoutUser_agreementsInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutUser_agreementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type usersUpsertWithoutUser_agreementsInput = {
    update: XOR<usersUncheckedUpdateWithoutUser_agreementsInput, usersUpdateWithoutUser_agreementsInput>
    create: XOR<usersUncheckedCreateWithoutUser_agreementsInput, usersCreateWithoutUser_agreementsInput>
  }

  export type usersCreateWithoutUser_typesInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    votes?: votesCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_typesInput = {
    id?: number
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    votes?: votesUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutuser_typesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutUser_typesInput, usersCreateWithoutUser_typesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutUser_typesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUncheckedUpdateWithoutUser_typesInput, usersUpdateWithoutUser_typesInput>
  }

  export type usersUpdateManyWithWhereWithoutUser_typesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUncheckedUpdateManyWithoutUsersInput, usersUpdateManyMutationInput>
  }

  export type usersUpsertWithWhereUniqueWithoutUser_typesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUncheckedUpdateWithoutUser_typesInput, usersUpdateWithoutUser_typesInput>
    create: XOR<usersUncheckedCreateWithoutUser_typesInput, usersCreateWithoutUser_typesInput>
  }

  export type companiesCreateWithoutUsersInput = {
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    company_types?: company_typesCreateOneWithoutCompaniesInput
    applicants?: applicantsCreateManyWithoutCompaniesInput
    company_documents?: company_documentsCreateManyWithoutCompaniesInput
    company_members?: company_membersCreateManyWithoutCompaniesInput
    company_news?: company_newsCreateManyWithoutCompaniesInput
    demodays?: demodaysCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsCreateManyWithoutCompaniesInput
    participants?: participantsCreateManyWithoutCompaniesInput
    partners?: partnersCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesCreateManyWithoutCompaniesInput
    project_likes?: project_likesCreateManyWithoutCompaniesInput
    projects?: projectsCreateManyWithoutCompaniesInput
    questions?: questionsCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectCreateManyWithoutCompaniesInput
    startups?: startupsCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesCreateManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutUsersInput = {
    id?: number
    type_id?: number | null
    name?: string | null
    logo_img?: string | null
    established_date?: Date | string | null
    homepage?: string | null
    description?: string | null
    team_intro?: string | null
    member_count?: number | null
    is_saved?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    applicants?: applicantsUncheckedCreateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedCreateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedCreateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedCreateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedCreateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedCreateManyWithoutCompaniesInput
    participants?: participantsUncheckedCreateManyWithoutCompaniesInput
    partners?: partnersUncheckedCreateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedCreateManyWithoutCompaniesInput
    projects?: projectsUncheckedCreateManyWithoutCompaniesInput
    questions?: questionsUncheckedCreateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedCreateManyWithoutCompaniesInput
    startups?: startupsUncheckedCreateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutusersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesUncheckedCreateWithoutUsersInput, companiesCreateWithoutUsersInput>
  }

  export type signup_methodsCreateWithoutUsersInput = {
    name: string
  }

  export type signup_methodsUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
  }

  export type signup_methodsCreateOrConnectWithoutusersInput = {
    where: signup_methodsWhereUniqueInput
    create: XOR<signup_methodsUncheckedCreateWithoutUsersInput, signup_methodsCreateWithoutUsersInput>
  }

  export type user_typesCreateWithoutUsersInput = {
    name: string
  }

  export type user_typesUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
  }

  export type user_typesCreateOrConnectWithoutusersInput = {
    where: user_typesWhereUniqueInput
    create: XOR<user_typesUncheckedCreateWithoutUsersInput, user_typesCreateWithoutUsersInput>
  }

  export type questionsCreateWithoutUsersInput = {
    content: string
    created_at: Date | string
    updated_at: Date | string
    companies: companiesCreateOneWithoutQuestionsInput
    demodays: demodaysCreateOneWithoutQuestionsInput
    answers?: answersCreateManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutUsersInput = {
    id?: number
    content: string
    company_id: number
    created_at: Date | string
    updated_at: Date | string
    demoday_id: number
    answers?: answersUncheckedCreateManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutusersInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsUncheckedCreateWithoutUsersInput, questionsCreateWithoutUsersInput>
  }

  export type startup_likesCreateWithoutUsersInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies: companiesCreateOneWithoutStartup_likesInput
  }

  export type startup_likesUncheckedCreateWithoutUsersInput = {
    id?: number
    company_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type startup_likesCreateOrConnectWithoutusersInput = {
    where: startup_likesWhereUniqueInput
    create: XOR<startup_likesUncheckedCreateWithoutUsersInput, startup_likesCreateWithoutUsersInput>
  }

  export type user_agreementsCreateWithoutUsersInput = {
    terms: termsCreateOneWithoutUser_agreementsInput
  }

  export type user_agreementsUncheckedCreateWithoutUsersInput = {
    id?: number
    term_id: number
  }

  export type user_agreementsCreateOrConnectWithoutusersInput = {
    where: user_agreementsWhereUniqueInput
    create: XOR<user_agreementsUncheckedCreateWithoutUsersInput, user_agreementsCreateWithoutUsersInput>
  }

  export type votesCreateWithoutUsersInput = {
    created_at?: Date | string
    participants: participantsCreateOneWithoutVotesInput
  }

  export type votesUncheckedCreateWithoutUsersInput = {
    id?: number
    participants_id: number
    created_at?: Date | string
  }

  export type votesCreateOrConnectWithoutusersInput = {
    where: votesWhereUniqueInput
    create: XOR<votesUncheckedCreateWithoutUsersInput, votesCreateWithoutUsersInput>
  }

  export type partner_likesCreateWithoutUsersInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies: companiesCreateOneWithoutPartner_likesInput
  }

  export type partner_likesUncheckedCreateWithoutUsersInput = {
    id?: number
    company_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type partner_likesCreateOrConnectWithoutusersInput = {
    where: partner_likesWhereUniqueInput
    create: XOR<partner_likesUncheckedCreateWithoutUsersInput, partner_likesCreateWithoutUsersInput>
  }

  export type project_likesCreateWithoutUsersInput = {
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    projects: projectsCreateOneWithoutProject_likesInput
    companies?: companiesCreateOneWithoutProject_likesInput
  }

  export type project_likesUncheckedCreateWithoutUsersInput = {
    id?: number
    project_id: number
    is_liked: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companiesId?: number | null
  }

  export type project_likesCreateOrConnectWithoutusersInput = {
    where: project_likesWhereUniqueInput
    create: XOR<project_likesUncheckedCreateWithoutUsersInput, project_likesCreateWithoutUsersInput>
  }

  export type companiesUpdateWithoutUsersInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_types?: company_typesUpdateOneWithoutCompaniesInput
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUpsertWithoutUsersInput = {
    update: XOR<companiesUncheckedUpdateWithoutUsersInput, companiesUpdateWithoutUsersInput>
    create: XOR<companiesUncheckedCreateWithoutUsersInput, companiesCreateWithoutUsersInput>
  }

  export type signup_methodsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type signup_methodsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type signup_methodsUpsertWithoutUsersInput = {
    update: XOR<signup_methodsUncheckedUpdateWithoutUsersInput, signup_methodsUpdateWithoutUsersInput>
    create: XOR<signup_methodsUncheckedCreateWithoutUsersInput, signup_methodsCreateWithoutUsersInput>
  }

  export type user_typesUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type user_typesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type user_typesUpsertWithoutUsersInput = {
    update: XOR<user_typesUncheckedUpdateWithoutUsersInput, user_typesUpdateWithoutUsersInput>
    create: XOR<user_typesUncheckedCreateWithoutUsersInput, user_typesCreateWithoutUsersInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUncheckedUpdateWithoutUsersInput, questionsUpdateWithoutUsersInput>
  }

  export type questionsUpdateManyWithWhereWithoutUsersInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUncheckedUpdateManyWithoutQuestionsInput, questionsUpdateManyMutationInput>
  }

  export type questionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUncheckedUpdateWithoutUsersInput, questionsUpdateWithoutUsersInput>
    create: XOR<questionsUncheckedCreateWithoutUsersInput, questionsCreateWithoutUsersInput>
  }

  export type startup_likesUpdateWithWhereUniqueWithoutUsersInput = {
    where: startup_likesWhereUniqueInput
    data: XOR<startup_likesUncheckedUpdateWithoutUsersInput, startup_likesUpdateWithoutUsersInput>
  }

  export type startup_likesUpdateManyWithWhereWithoutUsersInput = {
    where: startup_likesScalarWhereInput
    data: XOR<startup_likesUncheckedUpdateManyWithoutStartup_likesInput, startup_likesUpdateManyMutationInput>
  }

  export type startup_likesUpsertWithWhereUniqueWithoutUsersInput = {
    where: startup_likesWhereUniqueInput
    update: XOR<startup_likesUncheckedUpdateWithoutUsersInput, startup_likesUpdateWithoutUsersInput>
    create: XOR<startup_likesUncheckedCreateWithoutUsersInput, startup_likesCreateWithoutUsersInput>
  }

  export type user_agreementsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_agreementsWhereUniqueInput
    data: XOR<user_agreementsUncheckedUpdateWithoutUsersInput, user_agreementsUpdateWithoutUsersInput>
  }

  export type user_agreementsUpdateManyWithWhereWithoutUsersInput = {
    where: user_agreementsScalarWhereInput
    data: XOR<user_agreementsUncheckedUpdateManyWithoutUser_agreementsInput, user_agreementsUpdateManyMutationInput>
  }

  export type user_agreementsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_agreementsWhereUniqueInput
    update: XOR<user_agreementsUncheckedUpdateWithoutUsersInput, user_agreementsUpdateWithoutUsersInput>
    create: XOR<user_agreementsUncheckedCreateWithoutUsersInput, user_agreementsCreateWithoutUsersInput>
  }

  export type votesUpdateWithWhereUniqueWithoutUsersInput = {
    where: votesWhereUniqueInput
    data: XOR<votesUncheckedUpdateWithoutUsersInput, votesUpdateWithoutUsersInput>
  }

  export type votesUpdateManyWithWhereWithoutUsersInput = {
    where: votesScalarWhereInput
    data: XOR<votesUncheckedUpdateManyWithoutVotesInput, votesUpdateManyMutationInput>
  }

  export type votesUpsertWithWhereUniqueWithoutUsersInput = {
    where: votesWhereUniqueInput
    update: XOR<votesUncheckedUpdateWithoutUsersInput, votesUpdateWithoutUsersInput>
    create: XOR<votesUncheckedCreateWithoutUsersInput, votesCreateWithoutUsersInput>
  }

  export type partner_likesUpdateWithWhereUniqueWithoutUsersInput = {
    where: partner_likesWhereUniqueInput
    data: XOR<partner_likesUncheckedUpdateWithoutUsersInput, partner_likesUpdateWithoutUsersInput>
  }

  export type partner_likesUpdateManyWithWhereWithoutUsersInput = {
    where: partner_likesScalarWhereInput
    data: XOR<partner_likesUncheckedUpdateManyWithoutPartner_likesInput, partner_likesUpdateManyMutationInput>
  }

  export type partner_likesUpsertWithWhereUniqueWithoutUsersInput = {
    where: partner_likesWhereUniqueInput
    update: XOR<partner_likesUncheckedUpdateWithoutUsersInput, partner_likesUpdateWithoutUsersInput>
    create: XOR<partner_likesUncheckedCreateWithoutUsersInput, partner_likesCreateWithoutUsersInput>
  }

  export type project_likesUpdateWithWhereUniqueWithoutUsersInput = {
    where: project_likesWhereUniqueInput
    data: XOR<project_likesUncheckedUpdateWithoutUsersInput, project_likesUpdateWithoutUsersInput>
  }

  export type project_likesUpdateManyWithWhereWithoutUsersInput = {
    where: project_likesScalarWhereInput
    data: XOR<project_likesUncheckedUpdateManyWithoutProject_likesInput, project_likesUpdateManyMutationInput>
  }

  export type project_likesUpsertWithWhereUniqueWithoutUsersInput = {
    where: project_likesWhereUniqueInput
    update: XOR<project_likesUncheckedUpdateWithoutUsersInput, project_likesUpdateWithoutUsersInput>
    create: XOR<project_likesUncheckedCreateWithoutUsersInput, project_likesCreateWithoutUsersInput>
  }

  export type participantsCreateWithoutVotesInput = {
    order: number
    companies: companiesCreateOneWithoutParticipantsInput
    demodays: demodaysCreateOneWithoutParticipantsInput
  }

  export type participantsUncheckedCreateWithoutVotesInput = {
    id?: number
    demoday_id: number
    order: number
    company_id: number
  }

  export type participantsCreateOrConnectWithoutvotesInput = {
    where: participantsWhereUniqueInput
    create: XOR<participantsUncheckedCreateWithoutVotesInput, participantsCreateWithoutVotesInput>
  }

  export type usersCreateWithoutVotesInput = {
    sns_id?: string | null
    name: string
    profile_picture?: string | null
    email: string
    password?: string | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    companies?: companiesCreateOneWithoutUsersInput
    signup_methods?: signup_methodsCreateOneWithoutUsersInput
    user_types?: user_typesCreateOneWithoutUsersInput
    questions?: questionsCreateManyWithoutUsersInput
    startup_likes?: startup_likesCreateManyWithoutUsersInput
    user_agreements?: user_agreementsCreateManyWithoutUsersInput
    partner_likes?: partner_likesCreateManyWithoutUsersInput
    project_likes?: project_likesCreateManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVotesInput = {
    id?: number
    sns_id?: string | null
    name: string
    type_id?: number | null
    profile_picture?: string | null
    email: string
    password?: string | null
    signup_method_id?: number
    company_id?: number | null
    phone_number?: string | null
    is_verified?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    questions?: questionsUncheckedCreateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedCreateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedCreateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedCreateManyWithoutUsersInput
    project_likes?: project_likesUncheckedCreateManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutvotesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersUncheckedCreateWithoutVotesInput, usersCreateWithoutVotesInput>
  }

  export type participantsUpdateWithoutVotesInput = {
    order?: IntFieldUpdateOperationsInput | number
    companies?: companiesUpdateOneRequiredWithoutParticipantsInput
    demodays?: demodaysUpdateOneRequiredWithoutParticipantsInput
  }

  export type participantsUncheckedUpdateWithoutVotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    demoday_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
  }

  export type participantsUpsertWithoutVotesInput = {
    update: XOR<participantsUncheckedUpdateWithoutVotesInput, participantsUpdateWithoutVotesInput>
    create: XOR<participantsUncheckedCreateWithoutVotesInput, participantsCreateWithoutVotesInput>
  }

  export type usersUpdateWithoutVotesInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutVotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type usersUpsertWithoutVotesInput = {
    update: XOR<usersUncheckedUpdateWithoutVotesInput, usersUpdateWithoutVotesInput>
    create: XOR<usersUncheckedCreateWithoutVotesInput, usersCreateWithoutVotesInput>
  }

  export type applicant_documentsUpdateWithoutApplicantsInput = {
    company_documents?: company_documentsUpdateOneRequiredWithoutApplicant_documentsInput
  }

  export type applicant_documentsUncheckedUpdateWithoutApplicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_id?: IntFieldUpdateOperationsInput | number
  }

  export type applicant_documentsUncheckedUpdateManyWithoutApplicant_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_id?: IntFieldUpdateOperationsInput | number
  }

  export type startupsUpdateWithoutBusiness_typesInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutBusiness_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateManyWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type applicantsUpdateWithoutCompaniesInput = {
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projects?: projectsUpdateOneRequiredWithoutApplicantsInput
    applicant_documents?: applicant_documentsUpdateManyWithoutApplicantsInput
  }

  export type applicantsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicant_documents?: applicant_documentsUncheckedUpdateManyWithoutApplicantsInput
  }

  export type applicantsUncheckedUpdateManyWithoutApplicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_documentsUpdateWithoutCompaniesInput = {
    doc_url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    document_types?: document_typesUpdateOneRequiredWithoutCompany_documentsInput
    IR_requests?: IR_requestsUpdateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_url?: StringFieldUpdateOperationsInput | string
    type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUncheckedUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedUpdateManyWithoutCompany_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_url?: StringFieldUpdateOperationsInput | string
    type_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_membersUpdateWithoutCompaniesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_membersUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_membersUncheckedUpdateManyWithoutCompany_membersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    img?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type company_newsUpdateWithoutCompaniesInput = {
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type company_newsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type company_newsUncheckedUpdateManyWithoutCompany_newsInput = {
    id?: IntFieldUpdateOperationsInput | number
    URL?: StringFieldUpdateOperationsInput | string
  }

  export type demodaysUpdateWithoutCompaniesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: participantsUpdateManyWithoutDemodaysInput
    questions?: questionsUpdateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: participantsUncheckedUpdateManyWithoutDemodaysInput
    questions?: questionsUncheckedUpdateManyWithoutDemodaysInput
  }

  export type demodaysUncheckedUpdateManyWithoutDemodaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    streaming_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IR_requestsUpdateWithoutCompaniesInput = {
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_documents?: company_documentsUpdateOneWithoutIR_requestsInput
    partners?: partnersUpdateOneRequiredWithoutIR_requestsInput
    startups?: startupsUpdateOneRequiredWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    document_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IR_requestsUncheckedUpdateManyWithoutIR_requestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    document_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type participantsUpdateWithoutCompaniesInput = {
    order?: IntFieldUpdateOperationsInput | number
    demodays?: demodaysUpdateOneRequiredWithoutParticipantsInput
    votes?: votesUpdateManyWithoutParticipantsInput
  }

  export type participantsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    demoday_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    votes?: votesUncheckedUpdateManyWithoutParticipantsInput
  }

  export type participantsUncheckedUpdateManyWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    demoday_id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type partnersUpdateWithoutCompaniesInput = {
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    technologies?: technologiesUpdateOneWithoutPartnersInput
    investment_funds?: investment_fundsUpdateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUpdateManyWithoutPartnersInput
    invested_to?: invested_toUpdateManyWithoutPartnersInput
  }

  export type partnersUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    interst_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_total_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    investment_portfolio?: investment_portfolioUncheckedUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedUpdateManyWithoutPartnersInput
  }

  export type partnersUncheckedUpdateManyWithoutPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    interst_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_total_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type partner_likesUpdateWithoutCompaniesInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutPartner_likesInput
  }

  export type partner_likesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type partner_likesUncheckedUpdateManyWithoutPartner_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type project_likesUpdateWithoutCompaniesInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutProject_likesInput
    projects?: projectsUpdateOneRequiredWithoutProject_likesInput
  }

  export type project_likesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type project_likesUncheckedUpdateManyWithoutProject_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type projectsUpdateWithoutCompaniesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sectors?: eligible_sectorsUpdateOneWithoutProjectsInput
    eligibilities?: eligibilitiesUpdateOneWithoutProjectsInput
    applicants?: applicantsUpdateManyWithoutProjectsInput
    project_images?: project_imagesUpdateManyWithoutProjectsInput
    project_likes?: project_likesUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedUpdateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateManyWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsUpdateWithoutCompaniesInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demodays?: demodaysUpdateOneRequiredWithoutQuestionsInput
    users?: usersUpdateOneRequiredWithoutQuestionsInput
    answers?: answersUpdateManyWithoutQuestionsInput
  }

  export type questionsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demoday_id?: IntFieldUpdateOperationsInput | number
    answers?: answersUncheckedUpdateManyWithoutQuestionsInput
  }

  export type questionsUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demoday_id?: IntFieldUpdateOperationsInput | number
  }

  export type recent_views_projectUpdateWithoutCompaniesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: projectsUpdateOneRequiredWithoutRecent_views_projectInput
  }

  export type recent_views_projectUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recent_views_projectUncheckedUpdateManyWithoutRecent_views_projectInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type startupsUpdateWithoutCompaniesInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type startup_likesUpdateWithoutCompaniesInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutStartup_likesInput
  }

  export type startup_likesUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type startup_likesUncheckedUpdateManyWithoutStartup_likesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutCompaniesInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IR_requestsUpdateWithoutCompany_documentsInput = {
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    partners?: partnersUpdateOneRequiredWithoutIR_requestsInput
    startups?: startupsUpdateOneRequiredWithoutIR_requestsInput
    companies?: companiesUpdateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedUpdateWithoutCompany_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type applicant_documentsUpdateWithoutCompany_documentsInput = {
    applicants?: applicantsUpdateOneRequiredWithoutApplicant_documentsInput
  }

  export type applicant_documentsUncheckedUpdateWithoutCompany_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: IntFieldUpdateOperationsInput | number
  }

  export type companiesUpdateWithoutCompany_typesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUpdateManyWithoutCompaniesInput
    company_members?: company_membersUpdateManyWithoutCompaniesInput
    company_news?: company_newsUpdateManyWithoutCompaniesInput
    demodays?: demodaysUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUpdateManyWithoutCompaniesInput
    participants?: participantsUpdateManyWithoutCompaniesInput
    partners?: partnersUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUpdateManyWithoutCompaniesInput
    projects?: projectsUpdateManyWithoutCompaniesInput
    questions?: questionsUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUpdateManyWithoutCompaniesInput
    startups?: startupsUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUpdateManyWithoutCompaniesInput
    users?: usersUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateWithoutCompany_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCompaniesInput
    company_documents?: company_documentsUncheckedUpdateManyWithoutCompaniesInput
    company_members?: company_membersUncheckedUpdateManyWithoutCompaniesInput
    company_news?: company_newsUncheckedUpdateManyWithoutCompaniesInput
    demodays?: demodaysUncheckedUpdateManyWithoutCompaniesInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompaniesInput
    participants?: participantsUncheckedUpdateManyWithoutCompaniesInput
    partners?: partnersUncheckedUpdateManyWithoutCompaniesInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutCompaniesInput
    project_likes?: project_likesUncheckedUpdateManyWithoutCompaniesInput
    projects?: projectsUncheckedUpdateManyWithoutCompaniesInput
    questions?: questionsUncheckedUpdateManyWithoutCompaniesInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutCompaniesInput
    startups?: startupsUncheckedUpdateManyWithoutCompaniesInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutCompaniesInput
    users?: usersUncheckedUpdateManyWithoutCompaniesInput
  }

  export type companiesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_img?: NullableStringFieldUpdateOperationsInput | string | null
    established_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    team_intro?: NullableStringFieldUpdateOperationsInput | string | null
    member_count?: NullableIntFieldUpdateOperationsInput | number | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type participantsUpdateWithoutDemodaysInput = {
    order?: IntFieldUpdateOperationsInput | number
    companies?: companiesUpdateOneRequiredWithoutParticipantsInput
    votes?: votesUpdateManyWithoutParticipantsInput
  }

  export type participantsUncheckedUpdateWithoutDemodaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    votes?: votesUncheckedUpdateManyWithoutParticipantsInput
  }

  export type questionsUpdateWithoutDemodaysInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutQuestionsInput
    users?: usersUpdateOneRequiredWithoutQuestionsInput
    answers?: answersUpdateManyWithoutQuestionsInput
  }

  export type questionsUncheckedUpdateWithoutDemodaysInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: answersUncheckedUpdateManyWithoutQuestionsInput
  }

  export type company_documentsUpdateWithoutDocument_typesInput = {
    doc_url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_documentsInput
    IR_requests?: IR_requestsUpdateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUpdateManyWithoutCompany_documentsInput
  }

  export type company_documentsUncheckedUpdateWithoutDocument_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    doc_url?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutCompany_documentsInput
    applicant_documents?: applicant_documentsUncheckedUpdateManyWithoutCompany_documentsInput
  }

  export type required_documentsUpdateWithoutDocument_typesInput = {
    projects?: projectsUpdateOneRequiredWithoutRequired_documentsInput
  }

  export type required_documentsUncheckedUpdateWithoutDocument_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
  }

  export type required_documentsUncheckedUpdateManyWithoutRequired_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
  }

  export type projectsUpdateWithoutEligibilitiesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sectors?: eligible_sectorsUpdateOneWithoutProjectsInput
    companies?: companiesUpdateOneWithoutProjectsInput
    applicants?: applicantsUpdateManyWithoutProjectsInput
    project_images?: project_imagesUpdateManyWithoutProjectsInput
    project_likes?: project_likesUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateWithoutEligibilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligible_sector?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedUpdateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutProjectsInput
  }

  export type projectsUpdateWithoutEligible_sectorsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibilities?: eligibilitiesUpdateOneWithoutProjectsInput
    companies?: companiesUpdateOneWithoutProjectsInput
    applicants?: applicantsUpdateManyWithoutProjectsInput
    project_images?: project_imagesUpdateManyWithoutProjectsInput
    project_likes?: project_likesUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUpdateManyWithoutProjectsInput
  }

  export type projectsUncheckedUpdateWithoutEligible_sectorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    host?: NullableStringFieldUpdateOperationsInput | string | null
    due_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eligibility?: NullableIntFieldUpdateOperationsInput | number | null
    outline?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    application_method?: NullableStringFieldUpdateOperationsInput | string | null
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    is_opened?: BoolFieldUpdateOperationsInput | boolean
    hit?: IntFieldUpdateOperationsInput | number
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_saved?: BoolFieldUpdateOperationsInput | boolean
    request_open?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutProjectsInput
    project_images?: project_imagesUncheckedUpdateManyWithoutProjectsInput
    project_likes?: project_likesUncheckedUpdateManyWithoutProjectsInput
    recent_views_project?: recent_views_projectUncheckedUpdateManyWithoutProjectsInput
    required_documents?: required_documentsUncheckedUpdateManyWithoutProjectsInput
  }

  export type partnersUpdateWithoutInvestment_fundsInput = {
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutPartnersInput
    technologies?: technologiesUpdateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUpdateManyWithoutPartnersInput
    invested_to?: invested_toUpdateManyWithoutPartnersInput
  }

  export type partnersUncheckedUpdateWithoutInvestment_fundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    interst_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    investment_portfolio?: investment_portfolioUncheckedUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedUpdateManyWithoutPartnersInput
  }

  export type startupsUpdateWithoutInvestment_fundsInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutInvestment_fundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type invested_fromUpdateWithoutInvestment_fundsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    investment_series?: investment_seriesUpdateOneRequiredWithoutInvested_fromInput
    startups?: startupsUpdateOneRequiredWithoutInvested_fromInput
  }

  export type invested_fromUncheckedUpdateWithoutInvestment_fundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type invested_fromUncheckedUpdateManyWithoutInvested_fromInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type invested_toUpdateWithoutInvestment_fundsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    investment_series?: investment_seriesUpdateOneRequiredWithoutInvested_toInput
    partners?: partnersUpdateOneRequiredWithoutInvested_toInput
  }

  export type invested_toUncheckedUpdateWithoutInvestment_fundsInput = {
    id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type invested_toUncheckedUpdateManyWithoutInvested_toInput = {
    id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type invested_fromUpdateWithoutInvestment_seriesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    investment_funds?: investment_fundsUpdateOneRequiredWithoutInvested_fromInput
    startups?: startupsUpdateOneRequiredWithoutInvested_fromInput
  }

  export type invested_fromUncheckedUpdateWithoutInvestment_seriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    invested_fund_id?: IntFieldUpdateOperationsInput | number
    corporate_value?: IntFieldUpdateOperationsInput | number
  }

  export type invested_toUpdateWithoutInvestment_seriesInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    investment_funds?: investment_fundsUpdateOneRequiredWithoutInvested_toInput
    partners?: partnersUpdateOneRequiredWithoutInvested_toInput
  }

  export type invested_toUncheckedUpdateWithoutInvestment_seriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    invested_fund_id?: IntFieldUpdateOperationsInput | number
    corporate_value?: IntFieldUpdateOperationsInput | number
  }

  export type startupsUpdateWithoutInvestment_seriesInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutInvestment_seriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type wish_investment_seriesUpdateWithoutInvestment_seriesInput = {
    startups?: startupsUpdateOneRequiredWithoutWish_investment_seriesInput
  }

  export type wish_investment_seriesUncheckedUpdateWithoutInvestment_seriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
  }

  export type wish_investment_seriesUncheckedUpdateManyWithoutWish_investment_seriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
  }

  export type votesUpdateWithoutParticipantsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutVotesInput
  }

  export type votesUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type votesUncheckedUpdateManyWithoutVotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type investment_portfolioUpdateWithoutPartnersInput = {
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type investment_portfolioUncheckedUpdateWithoutPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type investment_portfolioUncheckedUpdateManyWithoutInvestment_portfolioInput = {
    id?: IntFieldUpdateOperationsInput | number
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type IR_requestsUpdateWithoutPartnersInput = {
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_documents?: company_documentsUpdateOneWithoutIR_requestsInput
    startups?: startupsUpdateOneRequiredWithoutIR_requestsInput
    companies?: companiesUpdateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedUpdateWithoutPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    startup_id?: IntFieldUpdateOperationsInput | number
    document_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type invested_toUpdateWithoutPartnersInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    investment_series?: investment_seriesUpdateOneRequiredWithoutInvested_toInput
    investment_funds?: investment_fundsUpdateOneRequiredWithoutInvested_toInput
  }

  export type invested_toUncheckedUpdateWithoutPartnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_startup?: StringFieldUpdateOperationsInput | string
    invested_fund_id?: IntFieldUpdateOperationsInput | number
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type applicantsUpdateWithoutProjectsInput = {
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutApplicantsInput
    applicant_documents?: applicant_documentsUpdateManyWithoutApplicantsInput
  }

  export type applicantsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    business_brief?: NullableStringFieldUpdateOperationsInput | string | null
    business_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicant_documents?: applicant_documentsUncheckedUpdateManyWithoutApplicantsInput
  }

  export type project_imagesUpdateWithoutProjectsInput = {
    img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_imagesUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_imagesUncheckedUpdateManyWithoutProject_imagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    img_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type project_likesUpdateWithoutProjectsInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutProject_likesInput
    companies?: companiesUpdateOneWithoutProject_likesInput
  }

  export type project_likesUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type recent_views_projectUpdateWithoutProjectsInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutRecent_views_projectInput
  }

  export type recent_views_projectUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type required_documentsUpdateWithoutProjectsInput = {
    document_types?: document_typesUpdateOneRequiredWithoutRequired_documentsInput
  }

  export type required_documentsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    document_id?: IntFieldUpdateOperationsInput | number
  }

  export type answersUpdateWithoutQuestionsInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type answersUncheckedUpdateManyWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type startupsUpdateWithoutSectorsInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutSectorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type startupsUpdateWithoutService_typesInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    technologies?: technologiesUpdateOneWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutService_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    core_technology_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type usersUpdateWithoutSignup_methodsInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    user_types?: user_typesUpdateOneWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutSignup_methodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type invested_fromUpdateWithoutStartupsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    corporate_value?: IntFieldUpdateOperationsInput | number
    investment_series?: investment_seriesUpdateOneRequiredWithoutInvested_fromInput
    investment_funds?: investment_fundsUpdateOneRequiredWithoutInvested_fromInput
  }

  export type invested_fromUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    invested_institution?: StringFieldUpdateOperationsInput | string
    invested_fund_id?: IntFieldUpdateOperationsInput | number
    corporate_value?: IntFieldUpdateOperationsInput | number
    series_id?: IntFieldUpdateOperationsInput | number
  }

  export type startup_imagesUpdateWithoutStartupsInput = {
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type startup_imagesUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type startup_imagesUncheckedUpdateManyWithoutStartup_imagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    img_url?: StringFieldUpdateOperationsInput | string
  }

  export type wish_investment_seriesUpdateWithoutStartupsInput = {
    investment_series?: investment_seriesUpdateOneRequiredWithoutWish_investment_seriesInput
  }

  export type wish_investment_seriesUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    investment_series_id?: IntFieldUpdateOperationsInput | number
  }

  export type IR_requestsUpdateWithoutStartupsInput = {
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    company_documents?: company_documentsUpdateOneWithoutIR_requestsInput
    partners?: partnersUpdateOneRequiredWithoutIR_requestsInput
    companies?: companiesUpdateOneWithoutIR_requestsInput
  }

  export type IR_requestsUncheckedUpdateWithoutStartupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    partner_id?: IntFieldUpdateOperationsInput | number
    document_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_checked?: IntFieldUpdateOperationsInput | number
    from_partner?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type partnersUpdateWithoutTechnologiesInput = {
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutPartnersInput
    investment_funds?: investment_fundsUpdateOneWithoutPartnersInput
    investment_portfolio?: investment_portfolioUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUpdateManyWithoutPartnersInput
    invested_to?: invested_toUpdateManyWithoutPartnersInput
  }

  export type partnersUncheckedUpdateWithoutTechnologiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    invested_total_id?: NullableIntFieldUpdateOperationsInput | number | null
    invested_counts?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    investment_portfolio?: investment_portfolioUncheckedUpdateManyWithoutPartnersInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutPartnersInput
    invested_to?: invested_toUncheckedUpdateManyWithoutPartnersInput
  }

  export type startupsUpdateWithoutTechnologiesInput = {
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business_types?: business_typesUpdateOneWithoutStartupsInput
    companies?: companiesUpdateOneRequiredWithoutStartupsInput
    sectors?: sectorsUpdateOneWithoutStartupsInput
    service_types?: service_typesUpdateOneWithoutStartupsInput
    investment_series?: investment_seriesUpdateOneWithoutStartupsInput
    investment_funds?: investment_fundsUpdateOneWithoutStartupsInput
    invested_from?: invested_fromUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUpdateManyWithoutStartupsInput
  }

  export type startupsUncheckedUpdateWithoutTechnologiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    rep?: NullableStringFieldUpdateOperationsInput | string | null
    sector_id?: NullableIntFieldUpdateOperationsInput | number | null
    item_description?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    investment_series_id?: NullableIntFieldUpdateOperationsInput | number | null
    investment_fund_id?: NullableIntFieldUpdateOperationsInput | number | null
    address_road?: NullableStringFieldUpdateOperationsInput | string | null
    address_detail?: NullableStringFieldUpdateOperationsInput | string | null
    service_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    business_license_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    instagram_url?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invested_from?: invested_fromUncheckedUpdateManyWithoutStartupsInput
    startup_images?: startup_imagesUncheckedUpdateManyWithoutStartupsInput
    wish_investment_series?: wish_investment_seriesUncheckedUpdateManyWithoutStartupsInput
    IR_requests?: IR_requestsUncheckedUpdateManyWithoutStartupsInput
  }

  export type user_agreementsUpdateWithoutTermsInput = {
    users?: usersUpdateOneRequiredWithoutUser_agreementsInput
  }

  export type user_agreementsUncheckedUpdateWithoutTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_agreementsUncheckedUpdateManyWithoutUser_agreementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersUpdateWithoutUser_typesInput = {
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneWithoutUsersInput
    signup_methods?: signup_methodsUpdateOneRequiredWithoutUsersInput
    questions?: questionsUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUpdateManyWithoutUsersInput
    votes?: votesUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUpdateManyWithoutUsersInput
    project_likes?: project_likesUpdateManyWithoutUsersInput
  }

  export type usersUncheckedUpdateWithoutUser_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sns_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    signup_method_id?: IntFieldUpdateOperationsInput | number
    company_id?: NullableIntFieldUpdateOperationsInput | number | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: questionsUncheckedUpdateManyWithoutUsersInput
    startup_likes?: startup_likesUncheckedUpdateManyWithoutUsersInput
    user_agreements?: user_agreementsUncheckedUpdateManyWithoutUsersInput
    votes?: votesUncheckedUpdateManyWithoutUsersInput
    partner_likes?: partner_likesUncheckedUpdateManyWithoutUsersInput
    project_likes?: project_likesUncheckedUpdateManyWithoutUsersInput
  }

  export type questionsUpdateWithoutUsersInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutQuestionsInput
    demodays?: demodaysUpdateOneRequiredWithoutQuestionsInput
    answers?: answersUpdateManyWithoutQuestionsInput
  }

  export type questionsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    demoday_id?: IntFieldUpdateOperationsInput | number
    answers?: answersUncheckedUpdateManyWithoutQuestionsInput
  }

  export type startup_likesUpdateWithoutUsersInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutStartup_likesInput
  }

  export type startup_likesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_agreementsUpdateWithoutUsersInput = {
    terms?: termsUpdateOneRequiredWithoutUser_agreementsInput
  }

  export type user_agreementsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    term_id?: IntFieldUpdateOperationsInput | number
  }

  export type votesUpdateWithoutUsersInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: participantsUpdateOneRequiredWithoutVotesInput
  }

  export type votesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    participants_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type partner_likesUpdateWithoutUsersInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutPartner_likesInput
  }

  export type partner_likesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type project_likesUpdateWithoutUsersInput = {
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: projectsUpdateOneRequiredWithoutProject_likesInput
    companies?: companiesUpdateOneWithoutProject_likesInput
  }

  export type project_likesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    project_id?: IntFieldUpdateOperationsInput | number
    is_liked?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companiesId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}